{
  "PFN_vkAllocationFunction": "Application-defined memory allocation function.",
  "PFN_vkAllocationFunction.alignment": "The requested alignment of the allocation in bytes and must be a power of two.",
  "PFN_vkAllocationFunction.allocationScope": "A SystemAllocationScope value specifying the allocation scope of the lifetime of the allocation.",
  "PFN_vkAllocationFunction.pUserData": "The value specified for AllocationCallbacks.UserData in the allocator specified by the application.",
  "PFN_vkAllocationFunction.size": "The size in bytes of the requested allocation.",
  "PFN_vkDebugReportCallbackEXT": "Application-defined debug report callback function.",
  "PFN_vkDebugReportCallbackEXT.flags": "Indicates the DebugReportFlags that triggered this callback.",
  "PFN_vkDebugReportCallbackEXT.location": "A component (layer, driver, loader) defined value that indicates the _location_ of the trigger. This is an optional value.",
  "PFN_vkDebugReportCallbackEXT.messageCode": "A layer-defined value indicating what test triggered this callback.",
  "PFN_vkDebugReportCallbackEXT.object": "The object where the issue was detected. May be null if there is no object associated with the event.",
  "PFN_vkDebugReportCallbackEXT.objectType": "A DebugReportObjectType specifying the type of object being used or created at the time the event was triggered.",
  "PFN_vkDebugReportCallbackEXT.pLayerPrefix": "The abbreviation of the component making the callback.",
  "PFN_vkDebugReportCallbackEXT.pMessage": "A string detailing the trigger conditions.",
  "PFN_vkDebugReportCallbackEXT.pUserData": "The user data given when the DebugReportCallback was created.",
  "PFN_vkFreeFunction": "Application-defined memory free function.",
  "PFN_vkFreeFunction.pMemory": "The allocation to be freed.",
  "PFN_vkFreeFunction.pUserData": "The value specified for AllocationCallbacks.UserData in the allocator specified by the application.",
  "PFN_vkInternalAllocationNotification": "Application-defined memory allocation notification function.",
  "PFN_vkInternalAllocationNotification.allocationScope": "A SystemAllocationScope value specifying the allocation scope of the lifetime of the allocation.",
  "PFN_vkInternalAllocationNotification.allocationType": "The requested type of an allocation.",
  "PFN_vkInternalAllocationNotification.pUserData": "The value specified for AllocationCallbacks.UserData in the allocator specified by the application.",
  "PFN_vkInternalAllocationNotification.size": "The requested size of an allocation.",
  "PFN_vkInternalFreeNotification": "Application-defined memory free notification function.",
  "PFN_vkInternalFreeNotification.allocationScope": "A SystemAllocationScope value specifying the allocation scope of the lifetime of the allocation.",
  "PFN_vkInternalFreeNotification.allocationType": "The requested type of an allocation.",
  "PFN_vkInternalFreeNotification.pUserData": "The value specified for AllocationCallbacks.UserData in the allocator specified by the application.",
  "PFN_vkInternalFreeNotification.size": "The requested size of an allocation.",
  "PFN_vkReallocationFunction": "Application-defined memory reallocation function.",
  "PFN_vkReallocationFunction.alignment": "The requested alignment of the allocation in bytes and must be a power of two.",
  "PFN_vkReallocationFunction.allocationScope": "A SystemAllocationScope value specifying the allocation scope of the lifetime of the allocation.",
  "PFN_vkReallocationFunction.pOriginal": "Null or a pointer previously returned by Reallocation or Allocation of the same allocator.",
  "PFN_vkReallocationFunction.pUserData": "AllocationCallbacks.UserData in the allocator specified by the application.",
  "PFN_vkReallocationFunction.size": "The size in bytes of the requested allocation.",
  "PFN_vkVoidFunction": "Dummy function pointer type returned by queries.",
  "VkAccessFlagBits": "Bitmask specifying memory access types that will participate in a memory dependency.",
  "VkAccessFlagBits.__none": "No access type specified.",
  "VkAccessFlagBits.VK_ACCESS_COLOR_ATTACHMENT_READ_BIT": "Read access to a color attachment, such as via blending, logic operations, or via certain subpass load operations.",
  "VkAccessFlagBits.VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT": "",
  "VkAccessFlagBits.VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT": "Write access to a color or resolve attachment during a render pass or via certain subpass load and store operations.",
  "VkAccessFlagBits.VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX": "Reads from Buffer inputs to CommandBuffer.ProcessCommands.",
  "VkAccessFlagBits.VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX": "Writes to the target command buffer in CommandBuffer.ProcessCommands.",
  "VkAccessFlagBits.VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT": "Read access to a depth/stencil attachment, via depth or stencil operations or via certain subpass load operations.",
  "VkAccessFlagBits.VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT": "Write access to a depth/stencil attachment, via depth or stencil operations or via certain subpass load and store operations.",
  "VkAccessFlagBits.VK_ACCESS_HOST_READ_BIT": "Read access by a host operation. Accesses of this type are not performed through a resource, but directly on memory.",
  "VkAccessFlagBits.VK_ACCESS_HOST_WRITE_BIT": "Write access by a host operation. Accesses of this type are not performed through a resource, but directly on memory.",
  "VkAccessFlagBits.VK_ACCESS_INDEX_READ_BIT": "Read access to an index buffer as part of an indexed drawing command, bound by CommandBuffer.BindIndexBuffer.",
  "VkAccessFlagBits.VK_ACCESS_INDIRECT_COMMAND_READ_BIT": "Read access to an indirect command structure read as part of an indirect drawing or dispatch command.",
  "VkAccessFlagBits.VK_ACCESS_INPUT_ATTACHMENT_READ_BIT": "Read access to an input attachment within a renderpass during fragment shading.",
  "VkAccessFlagBits.VK_ACCESS_MEMORY_READ_BIT": "Read access via non-specific entities. These entities include the Vulkan device and host, but may also include entities external to the Vulkan device or otherwise not part of the core Vulkan pipeline. When included in a destination access mask, makes all available writes visible to all future read accesses on entities known to the Vulkan device.",
  "VkAccessFlagBits.VK_ACCESS_MEMORY_WRITE_BIT": "Write access via non-specific entities. These entities include the Vulkan device and host, but may also include entities external to the Vulkan device or otherwise not part of the core Vulkan pipeline. When included in a source access mask, all writes that are performed by entities known to the Vulkan device are made available. When included in a destination access mask, makes all available writes visible to all future write accesses on entities known to the Vulkan device.",
  "VkAccessFlagBits.VK_ACCESS_SHADER_READ_BIT": "Read access to a storage buffer, uniform texel buffer, storage texel buffer, sampled image, or storage image.",
  "VkAccessFlagBits.VK_ACCESS_SHADER_WRITE_BIT": "Write access to a storage buffer, storage texel buffer, or storage image.",
  "VkAccessFlagBits.VK_ACCESS_TRANSFER_READ_BIT": "Read access to an image or buffer in a copy operation.",
  "VkAccessFlagBits.VK_ACCESS_TRANSFER_WRITE_BIT": "Write access to an image or buffer in a clear or copy operation.",
  "VkAccessFlagBits.VK_ACCESS_UNIFORM_READ_BIT": "Read access to a uniform buffer.",
  "VkAccessFlagBits.VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT": "Read access to a vertex buffer as part of a drawing command, bound by CommandBuffer.BindVertexBuffers.",
  "VkAccessFlags": "",
  "vkAcquireNextImage2KHX": "Retrieve the index of the next available presentable image.",
  "vkAcquireNextImage2KHX.device": "",
  "vkAcquireNextImage2KHX.pAcquireInfo": "",
  "vkAcquireNextImage2KHX.pImageIndex": "",
  "VkAcquireNextImageInfoKHX": "Structure specifying parameters of the acquire.",
  "VkAcquireNextImageInfoKHX.deviceMask": "A mask of physical devices for which the swapchain image will be ready to use when the semaphore or fence is signaled.",
  "VkAcquireNextImageInfoKHX.fence": "Null or a fence to signal.",
  "VkAcquireNextImageInfoKHX.pNext": "Null or an extension-specific structure.",
  "VkAcquireNextImageInfoKHX.semaphore": "Null or a semaphore to signal.",
  "VkAcquireNextImageInfoKHX.sType": "The type of this structure.",
  "VkAcquireNextImageInfoKHX.swapchain": "The swapchain from which an image is being acquired.",
  "VkAcquireNextImageInfoKHX.timeout": "Indicates how long the function waits, in nanoseconds, if no image is available.",
  "vkAcquireNextImageKHR": "Retrieve the index of the next available presentable image.",
  "vkAcquireNextImageKHR.device": "The device assocated with swapchain.",
  "vkAcquireNextImageKHR.fence": "Null or a fence to signal.",
  "vkAcquireNextImageKHR.pImageIndex": "A pointer to a UInt32 that is set to the index of the next image to use (i.e. an index into the array of images returned by Swapchain.GetImages())",
  "vkAcquireNextImageKHR.semaphore": "Null or a semaphore to signal.",
  "vkAcquireNextImageKHR.swapchain": "The swapchain from which an image is being acquired.",
  "vkAcquireNextImageKHR.timeout": "Indicates how long the function waits, in nanoseconds, if no image is available.",
  "vkAcquireXlibDisplayEXT": "Acquire access to a Display using Xlib.",
  "vkAcquireXlibDisplayEXT.display": "The display the caller wishes to control in Vulkan.",
  "vkAcquireXlibDisplayEXT.dpy": "A connection to the X11 server that currently owns the display.",
  "vkAcquireXlibDisplayEXT.physicalDevice": "The physical device the display is on.",
  "vkAllocateCommandBuffers": "Allocate command buffers from an existing command pool.",
  "vkAllocateCommandBuffers.device": "The logical device that owns the command pool.",
  "vkAllocateCommandBuffers.pAllocateInfo": "An instance of the VkCommandBufferAllocateInfo structure describing parameters of the allocation.",
  "vkAllocateCommandBuffers.pCommandBuffers": "An array of CommandBuffer handles in which the resulting command buffer objects are returned. The array must be at least the length specified by the commandBufferCount member of allocateInfo. Each allocated command buffer begins in the initial state.",
  "vkAllocateDescriptorSets": "Allocate one or more descriptor sets.",
  "vkAllocateDescriptorSets.device": "The logical device that owns the descriptor pool.",
  "vkAllocateDescriptorSets.pAllocateInfo": "An instance of the DescriptorSetAllocateInfo structure describing parameters of the allocation.",
  "vkAllocateDescriptorSets.pDescriptorSets": "An array of DescriptorSet handles in which the resulting descriptor set objects are returned. The array must be at least the length specified by the descriptorSetCount member of allocateInfo.",
  "vkAllocateMemory": "Allocate GPU memory.",
  "vkAllocateMemory.device": "The logical device that owns the memory.",
  "vkAllocateMemory.pAllocateInfo": "An instance of the MemoryAllocateInfo structure describing parameters of the allocation.",
  "vkAllocateMemory.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkAllocateMemory.pMemory": "A DeviceMemory handle in which information about the allocated memory is returned.",
  "VkAllocationCallbacks": "Structure containing callback function pointers for memory allocation.",
  "VkAllocationCallbacks.pfnAllocation": "An application-defined memory allocation function of type AllocationFunction.",
  "VkAllocationCallbacks.pfnFree": "An application-defined memory free function of type FreeFunction.",
  "VkAllocationCallbacks.pfnInternalAllocation": "An application-defined function that is called by the implementation when the implementation makes internal allocations, and it is of type InternalAllocationNotification.",
  "VkAllocationCallbacks.pfnInternalFree": "An application-defined function that is called by the implementation when the implementation frees internal allocations, and it is of type InternalFreeNotification.",
  "VkAllocationCallbacks.pfnReallocation": "An application-defined memory reallocation function of type ReallocationFunction.",
  "VkAllocationCallbacks.pUserData": "A value to be interpreted by the implementation of the callbacks. When any of the callbacks in AllocationCallbacks are called, the Vulkan implementation will pass this value as the first parameter to the callback. This value can vary each time an allocator is passed into a command, even when the same object takes an allocator in multiple commands.",
  "VkAndroidSurfaceCreateFlagsKHR": "",
  "VkAndroidSurfaceCreateFlagsKHR.__none": "",
  "VkAndroidSurfaceCreateInfoKHR": "Structure specifying parameters of a newly created Android surface object.",
  "VkAndroidSurfaceCreateInfoKHR.flags": "Reserved for future use.",
  "VkAndroidSurfaceCreateInfoKHR.pNext": "Null or an extension-specific structure.",
  "VkAndroidSurfaceCreateInfoKHR.sType": "The type of this structure.",
  "VkAndroidSurfaceCreateInfoKHR.window": "A pointer to the ANativeWindow to associate the surface with.",
  "VkApplicationInfo": "Structure specifying application info.",
  "VkApplicationInfo.apiVersion": "The version of the Vulkan API against which the application expects to run. If apiVersion is 0.0.0 the implementation must ignore it, otherwise if the implementation does not support the requested apiVersion it must throw IncompatibleDriverException. The patch version number specified in apiVersion is ignored when creating an instance object. Only the major and minor versions of the instance must match those requested in apiVersion.",
  "VkApplicationInfo.applicationVersion": "The developer-supplied version number of the application.",
  "VkApplicationInfo.engineVersion": "The developer-supplied version number of the engine used to create the application.",
  "VkApplicationInfo.pApplicationName": "A string containing the name of the application.",
  "VkApplicationInfo.pEngineName": "Astring containing the name of the engine (if any) used to create the application.",
  "VkApplicationInfo.pNext": "Null or an extension-specific structure.",
  "VkApplicationInfo.sType": "The type of this structure.",
  "VkAttachmentDescription": "Structure specifying an attachment description.",
  "VkAttachmentDescription.finalLayout": "The layout the attachment image subresource will be transitioned to when a render pass instance ends.",
  "VkAttachmentDescription.flags": "A bitmask describing additional properties of the attachment.",
  "VkAttachmentDescription.format": "A Format value specifying the format of the image that will be used for the attachment.",
  "VkAttachmentDescription.initialLayout": "The layout the attachment image subresource will be in when a render pass instance begins.",
  "VkAttachmentDescription.loadOp": "An AttachmentLoadOp value specifying how the contents of color and depth components of the attachment are treated at the beginning of the subpass where it is first used.",
  "VkAttachmentDescription.samples": "The number of samples of the image as defined in SampleCountFlags.",
  "VkAttachmentDescription.stencilLoadOp": "An AttachmentLoadOp value specifying how the contents of stencil components of the attachment are treated at the beginning of the subpass where it is first used.",
  "VkAttachmentDescription.stencilStoreOp": "An AttachmentStoreOp value specifying how the contents of stencil components of the attachment are treated at the end of the last subpass where it is used.",
  "VkAttachmentDescription.storeOp": "An AttachmentStoreOp value specifying how the contents of color and depth components of the attachment are treated at the end of the subpass where it is last used.",
  "VkAttachmentDescriptionFlagBits": "Bitmask specifying additional properties of an attachment.",
  "VkAttachmentDescriptionFlagBits.__none": "",
  "VkAttachmentDescriptionFlagBits.VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT": "",
  "VkAttachmentDescriptionFlags": "",
  "VkAttachmentLoadOp": "Specify how contents of an attachment are treated at the beginning of a subpass.",
  "VkAttachmentLoadOp.VK_ATTACHMENT_LOAD_OP_CLEAR": "",
  "VkAttachmentLoadOp.VK_ATTACHMENT_LOAD_OP_DONT_CARE": "",
  "VkAttachmentLoadOp.VK_ATTACHMENT_LOAD_OP_LOAD": "",
  "VkAttachmentReference": "Structure specifying an attachment reference.",
  "VkAttachmentReference.attachment": "The index of the attachment of the render pass, and corresponds to the index of the corresponding element in the attachments array of Device.CreateRenderPass. If any color or depth/stencil attachments are Attachment.Unused, then no writes occur for those attachments.",
  "VkAttachmentReference.layout": "An ImageLayout value specifying the layout the attachment uses during the subpass.",
  "VkAttachmentSampleLocationsEXT": "",
  "VkAttachmentSampleLocationsEXT.attachmentIndex": "",
  "VkAttachmentSampleLocationsEXT.sampleLocationsInfo": "",
  "VkAttachmentStoreOp": "Specify how contents of an attachment are treated at the end of a subpass.",
  "VkAttachmentStoreOp.VK_ATTACHMENT_STORE_OP_DONT_CARE": "",
  "VkAttachmentStoreOp.VK_ATTACHMENT_STORE_OP_STORE": "",
  "vkBeginCommandBuffer": "Start recording a command buffer.",
  "vkBeginCommandBuffer.commandBuffer": "",
  "vkBeginCommandBuffer.pBeginInfo": "",
  "vkBindBufferMemory": "Bind device memory to a buffer object.",
  "vkBindBufferMemory.buffer": "",
  "vkBindBufferMemory.device": "",
  "vkBindBufferMemory.memory": "",
  "vkBindBufferMemory.memoryOffset": "",
  "vkBindBufferMemory2KHR": "Bind device memory to buffer objects.",
  "vkBindBufferMemory2KHR.bindInfoCount": "",
  "vkBindBufferMemory2KHR.device": "",
  "vkBindBufferMemory2KHR.pBindInfos": "",
  "VkBindBufferMemoryDeviceGroupInfoKHX": "",
  "VkBindBufferMemoryDeviceGroupInfoKHX.deviceIndexCount": "The number of elements in DeviceIndices.",
  "VkBindBufferMemoryDeviceGroupInfoKHX.pDeviceIndices": "An array of device indices.",
  "VkBindBufferMemoryDeviceGroupInfoKHX.pNext": "Null or an extension-specific structure.",
  "VkBindBufferMemoryDeviceGroupInfoKHX.sType": "The type of this structure.",
  "VkBindBufferMemoryInfoKHR": "Structure specifying how to bind a buffer to memory.",
  "VkBindBufferMemoryInfoKHR.buffer": "The buffer to be attached to memory.",
  "VkBindBufferMemoryInfoKHR.memory": "A DeviceMemory object describing the device memory to attach.",
  "VkBindBufferMemoryInfoKHR.memoryOffset": "The start offset of the region of memory which is to be bound to the buffer. The number of bytes returned in the MemoryRequirements.size member in memory, starting from memoryOffset bytes, will be bound to the specified buffer.",
  "VkBindBufferMemoryInfoKHR.pNext": "Null or an extension-specific structure.",
  "VkBindBufferMemoryInfoKHR.sType": "The type of this structure.",
  "vkBindImageMemory": "Bind device memory to an image object.",
  "vkBindImageMemory.device": "",
  "vkBindImageMemory.image": "",
  "vkBindImageMemory.memory": "",
  "vkBindImageMemory.memoryOffset": "",
  "vkBindImageMemory2KHR": "Bind device memory to image objects.",
  "vkBindImageMemory2KHR.bindInfoCount": "",
  "vkBindImageMemory2KHR.device": "",
  "vkBindImageMemory2KHR.pBindInfos": "",
  "VkBindImageMemoryDeviceGroupInfoKHX": "",
  "VkBindImageMemoryDeviceGroupInfoKHX.deviceIndexCount": "The number of elements in DeviceIndices.",
  "VkBindImageMemoryDeviceGroupInfoKHX.pDeviceIndices": "An array of device indices.",
  "VkBindImageMemoryDeviceGroupInfoKHX.pNext": "Null or an extension-specific structure.",
  "VkBindImageMemoryDeviceGroupInfoKHX.pSFRRects": "An array of rectangles describing which regions of the image are attached to each instance of memory.",
  "VkBindImageMemoryDeviceGroupInfoKHX.SFRRectCount": "The number of elements in SFRRects.",
  "VkBindImageMemoryDeviceGroupInfoKHX.sType": "The type of this structure.",
  "VkBindImageMemoryInfoKHR": "Structure specifying how to bind an image to memory.",
  "VkBindImageMemoryInfoKHR.image": "The image to be attached to memory.",
  "VkBindImageMemoryInfoKHR.memory": "DeviceMemory object describing the device memory to attach.",
  "VkBindImageMemoryInfoKHR.memoryOffset": "The start offset of the region of memory which is to be bound to the image. If SFRRectCount is zero, the number of bytes returned in the MemoryRequirements::size member in memory, starting from memoryOffset bytes, will be bound to the specified image.",
  "VkBindImageMemoryInfoKHR.pNext": "Null or an extension-specific structure.",
  "VkBindImageMemoryInfoKHR.sType": "The type of this structure.",
  "VkBindImageMemorySwapchainInfoKHX": "Structure specifying swapchain image memory to bind to.",
  "VkBindImageMemorySwapchainInfoKHX.imageIndex": "An image index within swapchain.",
  "VkBindImageMemorySwapchainInfoKHX.pNext": "Null or an extension-specific structure.",
  "VkBindImageMemorySwapchainInfoKHX.sType": "The type of this structure.",
  "VkBindImageMemorySwapchainInfoKHX.swapchain": "Null or a swapchain handle.",
  "VkBindImagePlaneMemoryInfoKHR": "",
  "VkBindImagePlaneMemoryInfoKHR.planeAspect": "",
  "VkBindImagePlaneMemoryInfoKHR.pNext": "",
  "VkBindImagePlaneMemoryInfoKHR.sType": "",
  "VkBindSparseInfo": "Structure specifying a sparse binding operation.",
  "VkBindSparseInfo.bufferBindCount": "The number of sparse buffer bindings to perform in the batch.",
  "VkBindSparseInfo.imageBindCount": "The number of sparse image bindings to perform.",
  "VkBindSparseInfo.imageOpaqueBindCount": "The number of opaque sparse image bindings to perform.",
  "VkBindSparseInfo.pBufferBinds": "An array of SparseBufferMemoryBindInfo structures.",
  "VkBindSparseInfo.pImageBinds": "An array of SparseImageMemoryBindInfo structures, indicating sparse image bindings to perform.",
  "VkBindSparseInfo.pImageOpaqueBinds": "An array of SparseImageOpaqueMemoryBindInfo structures, indicating opaque sparse image bindings to perform.",
  "VkBindSparseInfo.pNext": "Null or an extension-specific structure.",
  "VkBindSparseInfo.pSignalSemaphores": "An array of semaphores which will be signaled when the sparse binding operations for this batch have completed execution. If semaphores to be signaled are provided, they define a semaphore signal operation.",
  "VkBindSparseInfo.pWaitSemaphores": "An array of semaphores upon which to wait on before the sparse binding operations for this batch begin execution. If semaphores to wait on are provided, they define a semaphore wait operation.",
  "VkBindSparseInfo.signalSemaphoreCount": "The number of semaphores to be signaled once the sparse binding operations specified by the structure have completed execution.",
  "VkBindSparseInfo.sType": "The type of this structure.",
  "VkBindSparseInfo.waitSemaphoreCount": "The number of semaphores upon which to wait before executing the sparse binding operations for the batch.",
  "VkBlendFactor": "Framebuffer blending factors.",
  "VkBlendFactor.VK_BLEND_FACTOR_CONSTANT_ALPHA": "",
  "VkBlendFactor.VK_BLEND_FACTOR_CONSTANT_COLOR": "",
  "VkBlendFactor.VK_BLEND_FACTOR_DST_ALPHA": "",
  "VkBlendFactor.VK_BLEND_FACTOR_DST_COLOR": "",
  "VkBlendFactor.VK_BLEND_FACTOR_ONE": "",
  "VkBlendFactor.VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA": "",
  "VkBlendFactor.VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR": "",
  "VkBlendFactor.VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA": "",
  "VkBlendFactor.VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR": "",
  "VkBlendFactor.VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA": "",
  "VkBlendFactor.VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR": "",
  "VkBlendFactor.VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA": "",
  "VkBlendFactor.VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR": "",
  "VkBlendFactor.VK_BLEND_FACTOR_SRC_ALPHA": "",
  "VkBlendFactor.VK_BLEND_FACTOR_SRC_ALPHA_SATURATE": "",
  "VkBlendFactor.VK_BLEND_FACTOR_SRC_COLOR": "",
  "VkBlendFactor.VK_BLEND_FACTOR_SRC1_ALPHA": "",
  "VkBlendFactor.VK_BLEND_FACTOR_SRC1_COLOR": "",
  "VkBlendFactor.VK_BLEND_FACTOR_ZERO": "",
  "VkBlendOp": "Framebuffer blending operations.",
  "VkBlendOp.VK_BLEND_OP_ADD": "",
  "VkBlendOp.VK_BLEND_OP_BLUE_EXT": "",
  "VkBlendOp.VK_BLEND_OP_COLORBURN_EXT": "",
  "VkBlendOp.VK_BLEND_OP_COLORDODGE_EXT": "",
  "VkBlendOp.VK_BLEND_OP_CONTRAST_EXT": "",
  "VkBlendOp.VK_BLEND_OP_DARKEN_EXT": "",
  "VkBlendOp.VK_BLEND_OP_DIFFERENCE_EXT": "",
  "VkBlendOp.VK_BLEND_OP_DST_ATOP_EXT": "",
  "VkBlendOp.VK_BLEND_OP_DST_EXT": "",
  "VkBlendOp.VK_BLEND_OP_DST_IN_EXT": "",
  "VkBlendOp.VK_BLEND_OP_DST_OUT_EXT": "",
  "VkBlendOp.VK_BLEND_OP_DST_OVER_EXT": "",
  "VkBlendOp.VK_BLEND_OP_EXCLUSION_EXT": "",
  "VkBlendOp.VK_BLEND_OP_GREEN_EXT": "",
  "VkBlendOp.VK_BLEND_OP_HARDLIGHT_EXT": "",
  "VkBlendOp.VK_BLEND_OP_HARDMIX_EXT": "",
  "VkBlendOp.VK_BLEND_OP_HSL_COLOR_EXT": "",
  "VkBlendOp.VK_BLEND_OP_HSL_HUE_EXT": "",
  "VkBlendOp.VK_BLEND_OP_HSL_LUMINOSITY_EXT": "",
  "VkBlendOp.VK_BLEND_OP_HSL_SATURATION_EXT": "",
  "VkBlendOp.VK_BLEND_OP_INVERT_EXT": "",
  "VkBlendOp.VK_BLEND_OP_INVERT_OVG_EXT": "",
  "VkBlendOp.VK_BLEND_OP_INVERT_RGB_EXT": "",
  "VkBlendOp.VK_BLEND_OP_LIGHTEN_EXT": "",
  "VkBlendOp.VK_BLEND_OP_LINEARBURN_EXT": "",
  "VkBlendOp.VK_BLEND_OP_LINEARDODGE_EXT": "",
  "VkBlendOp.VK_BLEND_OP_LINEARLIGHT_EXT": "",
  "VkBlendOp.VK_BLEND_OP_MAX": "",
  "VkBlendOp.VK_BLEND_OP_MIN": "",
  "VkBlendOp.VK_BLEND_OP_MINUS_CLAMPED_EXT": "",
  "VkBlendOp.VK_BLEND_OP_MINUS_EXT": "",
  "VkBlendOp.VK_BLEND_OP_MULTIPLY_EXT": "",
  "VkBlendOp.VK_BLEND_OP_OVERLAY_EXT": "",
  "VkBlendOp.VK_BLEND_OP_PINLIGHT_EXT": "",
  "VkBlendOp.VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT": "",
  "VkBlendOp.VK_BLEND_OP_PLUS_CLAMPED_EXT": "",
  "VkBlendOp.VK_BLEND_OP_PLUS_DARKER_EXT": "",
  "VkBlendOp.VK_BLEND_OP_PLUS_EXT": "",
  "VkBlendOp.VK_BLEND_OP_RED_EXT": "",
  "VkBlendOp.VK_BLEND_OP_REVERSE_SUBTRACT": "",
  "VkBlendOp.VK_BLEND_OP_SCREEN_EXT": "",
  "VkBlendOp.VK_BLEND_OP_SOFTLIGHT_EXT": "",
  "VkBlendOp.VK_BLEND_OP_SRC_ATOP_EXT": "",
  "VkBlendOp.VK_BLEND_OP_SRC_EXT": "",
  "VkBlendOp.VK_BLEND_OP_SRC_IN_EXT": "",
  "VkBlendOp.VK_BLEND_OP_SRC_OUT_EXT": "",
  "VkBlendOp.VK_BLEND_OP_SRC_OVER_EXT": "",
  "VkBlendOp.VK_BLEND_OP_SUBTRACT": "",
  "VkBlendOp.VK_BLEND_OP_VIVIDLIGHT_EXT": "",
  "VkBlendOp.VK_BLEND_OP_XOR_EXT": "",
  "VkBlendOp.VK_BLEND_OP_ZERO_EXT": "",
  "VkBlendOverlapEXT": "",
  "VkBlendOverlapEXT.VK_BLEND_OVERLAP_CONJOINT_EXT": "",
  "VkBlendOverlapEXT.VK_BLEND_OVERLAP_DISJOINT_EXT": "",
  "VkBlendOverlapEXT.VK_BLEND_OVERLAP_UNCORRELATED_EXT": "",
  "VkBorderColor": "Specify border color used for texture lookups.",
  "VkBorderColor.VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK": "",
  "VkBorderColor.VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE": "",
  "VkBorderColor.VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK": "",
  "VkBorderColor.VK_BORDER_COLOR_INT_OPAQUE_BLACK": "",
  "VkBorderColor.VK_BORDER_COLOR_INT_OPAQUE_WHITE": "",
  "VkBorderColor.VK_BORDER_COLOR_INT_TRANSPARENT_BLACK": "",
  "VkBuffer": "Buffers represent linear arrays of data which are used for various purposes by binding them to a graphics or compute pipeline via descriptor sets or via certain commands, or by directly specifying them as parameters to certain commands.",
  "VkBufferCopy": "Structure specifying a buffer copy operation.",
  "VkBufferCopy.dstOffset": "The starting offset in bytes from the start of the destination buffer.",
  "VkBufferCopy.size": "The number of bytes to copy.",
  "VkBufferCopy.srcOffset": "The starting offset in bytes from the start of source buffer.",
  "VkBufferCreateFlagBits": "Bitmask specifying additional parameters of a buffer.",
  "VkBufferCreateFlagBits.__none": "",
  "VkBufferCreateFlagBits.VK_BUFFER_CREATE_SPARSE_ALIASED_BIT": "Indicates that the buffer will be backed using sparse memory binding with memory ranges that might also simultaneously be backing another buffer (or another portion of the same buffer). Buffers created with this flag must also be created with the CreateSparseBinding flag.",
  "VkBufferCreateFlagBits.VK_BUFFER_CREATE_SPARSE_BINDING_BIT": "Indicates that the buffer will be backed using sparse memory binding.",
  "VkBufferCreateFlagBits.VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT": "Indicates that the buffer can be partially backed using sparse memory binding. Buffers created with this flag must also be created with the CreateSparseBinding flag.",
  "VkBufferCreateFlags": "",
  "VkBufferCreateInfo": "Structure specifying the parameters of a newly created buffer object.",
  "VkBufferCreateInfo.flags": "A bitmask describing additional parameters of the buffer.",
  "VkBufferCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkBufferCreateInfo.pQueueFamilyIndices": "A list of queue families that will access this buffer (ignored if sharingMode is not Concurrent).",
  "VkBufferCreateInfo.queueFamilyIndexCount": "The number of entries in the queueFamilyIndices array.",
  "VkBufferCreateInfo.sharingMode": "The sharing mode of the buffer when it will be accessed by multiple queue families.",
  "VkBufferCreateInfo.size": "The size in bytes of the buffer to be created.",
  "VkBufferCreateInfo.sType": "The type of this structure.",
  "VkBufferCreateInfo.usage": "A bitmask describing the allowed usages of the buffer.",
  "VkBufferImageCopy": "Structure specifying a buffer image copy operation.",
  "VkBufferImageCopy.bufferImageHeight": "",
  "VkBufferImageCopy.bufferOffset": "The offset in bytes from the start of the buffer object where the image data is copied from or to.",
  "VkBufferImageCopy.bufferRowLength": "bufferRowLength and bufferImageHeight specify the data in buffer memory as a subregion of a larger two- or three-dimensional image, and control the addressing calculations of data in buffer memory. If either of these values is zero, that aspect of the buffer memory is considered to be tightly packed according to the imageExtent.",
  "VkBufferImageCopy.imageExtent": "The size in texels of the image to copy in width, height and depth.",
  "VkBufferImageCopy.imageOffset": "imageOffset selects the initial x, y, z offsets in texels of the sub-region of the source or destination image data.",
  "VkBufferImageCopy.imageSubresource": "A ImageSubresourceLayers used to specify the specific image subresources of the image used for the source or destination image data.",
  "VkBufferMemoryBarrier": "Structure specifying a buffer memory barrier.",
  "VkBufferMemoryBarrier.buffer": "A handle to the buffer whose backing memory is affected by the barrier.",
  "VkBufferMemoryBarrier.dstAccessMask": "dstAccessMask defines a destination access mask.",
  "VkBufferMemoryBarrier.dstQueueFamilyIndex": "The destination queue family for a queue family ownership transfer.",
  "VkBufferMemoryBarrier.offset": "An offset in bytes into the backing memory for buffer; this is relative to the base offset as bound to the buffer (see flink:vkBindBufferMemory).",
  "VkBufferMemoryBarrier.pNext": "Null or an extension-specific structure.",
  "VkBufferMemoryBarrier.size": "A size in bytes of the affected area of backing memory for buffer, or VK_WHOLE_SIZE to use the range from offset to the end of the buffer.",
  "VkBufferMemoryBarrier.srcAccessMask": "srcAccessMask defines a source access mask.",
  "VkBufferMemoryBarrier.srcQueueFamilyIndex": "The source queue family for a queue family ownership transfer.",
  "VkBufferMemoryBarrier.sType": "The type of this structure.",
  "VkBufferMemoryRequirementsInfo2KHR": "",
  "VkBufferMemoryRequirementsInfo2KHR.buffer": "",
  "VkBufferMemoryRequirementsInfo2KHR.pNext": "",
  "VkBufferMemoryRequirementsInfo2KHR.sType": "",
  "VkBufferUsageFlagBits": "Bitmask specifying allowed usage of a buffer.",
  "VkBufferUsageFlagBits.__none": "",
  "VkBufferUsageFlagBits.VK_BUFFER_USAGE_INDEX_BUFFER_BIT": "Indicates that the buffer is suitable for passing as the buffer parameter to fname:vkCmdBindIndexBuffer.",
  "VkBufferUsageFlagBits.VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT": "Indicates that the buffer is suitable for passing as the buffer parameter to fname:vkCmdDrawIndirect, fname:vkCmdDrawIndexedIndirect, or fname:vkCmdDispatchIndirect. It is also suitable for passing as the buffer member of IndirectCommandsTokenNVX, or sequencesCountBuffer or sequencesIndexBuffer member of CmdProcessCommandsInfoNVX",
  "VkBufferUsageFlagBits.VK_BUFFER_USAGE_STORAGE_BUFFER_BIT": "Indicates that the buffer can be used in a DescriptorBufferInfo suitable for occupying a DescriptorSet slot either of type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC.",
  "VkBufferUsageFlagBits.VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT": "Indicates that the buffer can be used to create a BufferView suitable for occupying a DescriptorSet slot of type VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER.",
  "VkBufferUsageFlagBits.VK_BUFFER_USAGE_TRANSFER_DST_BIT": "Indicates that the buffer can be used as the destination of a transfer command.",
  "VkBufferUsageFlagBits.VK_BUFFER_USAGE_TRANSFER_SRC_BIT": "Indicates that the buffer can be used as the source of a _transfer command_ (see the definition of VK_PIPELINE_STAGE_TRANSFER_BIT).",
  "VkBufferUsageFlagBits.VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT": "Indicates that the buffer can be used in a DescriptorBufferInfo suitable for occupying a DescriptorSet slot either of type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC.",
  "VkBufferUsageFlagBits.VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT": "Indicates that the buffer can be used to create a BufferView suitable for occupying a DescriptorSet slot of type VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER.",
  "VkBufferUsageFlagBits.VK_BUFFER_USAGE_VERTEX_BUFFER_BIT": "Indicates that the buffer is suitable for passing as an element of the pBuffers array to fname:vkCmdBindVertexBuffers.",
  "VkBufferUsageFlags": "",
  "VkBufferView": "Opaque handle to a buffer view object.",
  "VkBufferViewCreateFlagBits": "",
  "VkBufferViewCreateFlags": "",
  "VkBufferViewCreateFlags.__none": "",
  "VkBufferViewCreateInfo": "Structure specifying parameters of a newly created buffer view.",
  "VkBufferViewCreateInfo.buffer": "A Buffer on which the view will be created.",
  "VkBufferViewCreateInfo.flags": "Reserved for future use.",
  "VkBufferViewCreateInfo.format": "A Format describing the format of the data elements in the buffer.",
  "VkBufferViewCreateInfo.offset": "An offset in bytes from the base address of the buffer. Accesses to the buffer view from shaders use addressing that is relative to this starting offset.",
  "VkBufferViewCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkBufferViewCreateInfo.range": "A size in bytes of the buffer view. If range is equal to VK_WHOLE_SIZE, the range from offset to the end of the buffer is used. If VK_WHOLE_SIZE is used and the remaining size of the buffer is not a multiple of the element size of format, then the nearest smaller multiple is used.",
  "VkBufferViewCreateInfo.sType": "The type of this structure.",
  "VkChromaLocationKHR": "",
  "VkChromaLocationKHR.VK_CHROMA_LOCATION_COSITED_EVEN_KHR": "",
  "VkChromaLocationKHR.VK_CHROMA_LOCATION_MIDPOINT_KHR": "",
  "VkClearAttachment": "Structure specifying a clear attachment.",
  "VkClearAttachment.aspectMask": "A mask selecting the color, depth and/or stencil aspects of the attachment to be cleared. aspectMask can include VK_IMAGE_ASPECT_COLOR_BIT for color attachments, VK_IMAGE_ASPECT_DEPTH_BIT for depth/stencil attachments with a depth component, and VK_IMAGE_ASPECT_STENCIL_BIT for depth/stencil attachments with a stencil component. If the subpass's depth/stencil attachment is VK_ATTACHMENT_UNUSED, then the clear has no effect.",
  "VkClearAttachment.clearValue": "The color or depth/stencil value to clear the attachment to.",
  "VkClearAttachment.colorAttachment": "colorAttachment is only meaningful if VK_IMAGE_ASPECT_COLOR_BIT is set in aspectMask, in which case it is an index to the pColorAttachments array in the SubpassDescription structure of the current subpass which selects the color attachment to clear. If colorAttachment is VK_ATTACHMENT_UNUSED then the clear has no effect.",
  "VkClearColorValue": "Structure specifying a clear color value.",
  "VkClearColorValue.float32": "float32 are the color clear values when the format of the image or attachment is one of the formats in the Interpretation of Numeric Format table other than signed integer (etext:SINT) or unsigned integer (etext:UINT). Floating point values are automatically converted to the format of the image, with the clear value being treated as linear if the image is sRGB.",
  "VkClearColorValue.int32": "int32 are the color clear values when the format of the image or attachment is signed integer (etext:SINT). Signed integer values are converted to the format of the image by casting to the smaller type (with negative 32-bit values mapping to negative values in the smaller type). If the integer clear value is not representable in the target type (e.g. would overflow in conversion to that type), the clear value is undefined.",
  "VkClearColorValue.uint32": "uint32 are the color clear values when the format of the image or attachment is unsigned integer (etext:UINT). Unsigned integer values are converted to the format of the image by casting to the integer type with fewer bits.",
  "VkClearDepthStencilValue": "Structure specifying a clear depth stencil value.",
  "VkClearDepthStencilValue.depth": "The clear value for the depth aspect of the depth/stencil attachment. It is a floating-point value which is automatically converted to the attachment's format.",
  "VkClearDepthStencilValue.stencil": "The clear value for the stencil aspect of the depth/stencil attachment. It is a 32-bit integer value which is converted to the attachment's format by taking the appropriate number of LSBs.",
  "VkClearRect": "Structure specifying a clear rectangle.",
  "VkClearRect.baseArrayLayer": "The first layer to be cleared.",
  "VkClearRect.layerCount": "The number of layers to clear.",
  "VkClearRect.rect": "The two-dimensional region to be cleared.",
  "VkClearValue": "Structure specifying a clear value.",
  "VkClearValue.color": "Specifies the color image clear values to use when clearing a color image or attachment.",
  "VkClearValue.depthStencil": "Specifies the depth and stencil clear values to use when clearing a depth/stencil image or attachment.",
  "vkCmdBeginQuery": "Begin a query.",
  "vkCmdBeginQuery.commandBuffer": "",
  "vkCmdBeginQuery.flags": "",
  "vkCmdBeginQuery.query": "",
  "vkCmdBeginQuery.queryPool": "",
  "vkCmdBeginRenderPass": "Begin a new render pass.",
  "vkCmdBeginRenderPass.commandBuffer": "",
  "vkCmdBeginRenderPass.contents": "",
  "vkCmdBeginRenderPass.pRenderPassBegin": "",
  "vkCmdBindDescriptorSets": "Binds descriptor sets to a command buffer.",
  "vkCmdBindDescriptorSets.commandBuffer": "",
  "vkCmdBindDescriptorSets.descriptorSetCount": "",
  "vkCmdBindDescriptorSets.dynamicOffsetCount": "",
  "vkCmdBindDescriptorSets.firstSet": "",
  "vkCmdBindDescriptorSets.layout": "",
  "vkCmdBindDescriptorSets.pDescriptorSets": "",
  "vkCmdBindDescriptorSets.pDynamicOffsets": "",
  "vkCmdBindDescriptorSets.pipelineBindPoint": "",
  "vkCmdBindIndexBuffer": "Bind an index buffer to a command buffer.",
  "vkCmdBindIndexBuffer.buffer": "",
  "vkCmdBindIndexBuffer.commandBuffer": "",
  "vkCmdBindIndexBuffer.indexType": "",
  "vkCmdBindIndexBuffer.offset": "",
  "vkCmdBindPipeline": "Bind a pipeline object to a command buffer.",
  "vkCmdBindPipeline.commandBuffer": "",
  "vkCmdBindPipeline.pipeline": "",
  "vkCmdBindPipeline.pipelineBindPoint": "",
  "vkCmdBindVertexBuffers": "Bind vertex buffers to a command buffer.",
  "vkCmdBindVertexBuffers.bindingCount": "",
  "vkCmdBindVertexBuffers.commandBuffer": "",
  "vkCmdBindVertexBuffers.firstBinding": "",
  "vkCmdBindVertexBuffers.pBuffers": "",
  "vkCmdBindVertexBuffers.pOffsets": "",
  "vkCmdBlitImage": "Copy regions of an image, potentially performing format conversion,.",
  "vkCmdBlitImage.commandBuffer": "",
  "vkCmdBlitImage.dstImage": "",
  "vkCmdBlitImage.dstImageLayout": "",
  "vkCmdBlitImage.filter": "",
  "vkCmdBlitImage.pRegions": "",
  "vkCmdBlitImage.regionCount": "",
  "vkCmdBlitImage.srcImage": "",
  "vkCmdBlitImage.srcImageLayout": "",
  "vkCmdClearAttachments": "Clear regions within currently bound framebuffer attachments.",
  "vkCmdClearAttachments.attachmentCount": "",
  "vkCmdClearAttachments.commandBuffer": "",
  "vkCmdClearAttachments.pAttachments": "",
  "vkCmdClearAttachments.pRects": "",
  "vkCmdClearAttachments.rectCount": "",
  "vkCmdClearColorImage": "Clear regions of a color image.",
  "vkCmdClearColorImage.commandBuffer": "",
  "vkCmdClearColorImage.image": "",
  "vkCmdClearColorImage.imageLayout": "",
  "vkCmdClearColorImage.pColor": "",
  "vkCmdClearColorImage.pRanges": "",
  "vkCmdClearColorImage.rangeCount": "",
  "vkCmdClearDepthStencilImage": "Fill regions of a combined depth/stencil image.",
  "vkCmdClearDepthStencilImage.commandBuffer": "",
  "vkCmdClearDepthStencilImage.image": "",
  "vkCmdClearDepthStencilImage.imageLayout": "",
  "vkCmdClearDepthStencilImage.pDepthStencil": "",
  "vkCmdClearDepthStencilImage.pRanges": "",
  "vkCmdClearDepthStencilImage.rangeCount": "",
  "vkCmdCopyBuffer": "Copy data between buffer regions.",
  "vkCmdCopyBuffer.commandBuffer": "",
  "vkCmdCopyBuffer.dstBuffer": "",
  "vkCmdCopyBuffer.pRegions": "",
  "vkCmdCopyBuffer.regionCount": "",
  "vkCmdCopyBuffer.srcBuffer": "",
  "vkCmdCopyBufferToImage": "Copy data from a buffer into an image.",
  "vkCmdCopyBufferToImage.commandBuffer": "",
  "vkCmdCopyBufferToImage.dstImage": "",
  "vkCmdCopyBufferToImage.dstImageLayout": "",
  "vkCmdCopyBufferToImage.pRegions": "",
  "vkCmdCopyBufferToImage.regionCount": "",
  "vkCmdCopyBufferToImage.srcBuffer": "",
  "vkCmdCopyImage": "Copy data between images.",
  "vkCmdCopyImage.commandBuffer": "",
  "vkCmdCopyImage.dstImage": "",
  "vkCmdCopyImage.dstImageLayout": "",
  "vkCmdCopyImage.pRegions": "",
  "vkCmdCopyImage.regionCount": "",
  "vkCmdCopyImage.srcImage": "",
  "vkCmdCopyImage.srcImageLayout": "",
  "vkCmdCopyImageToBuffer": "Copy image data into a buffer.",
  "vkCmdCopyImageToBuffer.commandBuffer": "",
  "vkCmdCopyImageToBuffer.dstBuffer": "",
  "vkCmdCopyImageToBuffer.pRegions": "",
  "vkCmdCopyImageToBuffer.regionCount": "",
  "vkCmdCopyImageToBuffer.srcImage": "",
  "vkCmdCopyImageToBuffer.srcImageLayout": "",
  "vkCmdCopyQueryPoolResults": "Copy the results of queries in a query pool to a buffer object.",
  "vkCmdCopyQueryPoolResults.commandBuffer": "",
  "vkCmdCopyQueryPoolResults.dstBuffer": "",
  "vkCmdCopyQueryPoolResults.dstOffset": "",
  "vkCmdCopyQueryPoolResults.firstQuery": "",
  "vkCmdCopyQueryPoolResults.flags": "",
  "vkCmdCopyQueryPoolResults.queryCount": "",
  "vkCmdCopyQueryPoolResults.queryPool": "",
  "vkCmdCopyQueryPoolResults.stride": "",
  "vkCmdDebugMarkerBeginEXT": "Open a command buffer marker region.",
  "vkCmdDebugMarkerBeginEXT.commandBuffer": "",
  "vkCmdDebugMarkerBeginEXT.pMarkerInfo": "",
  "vkCmdDebugMarkerEndEXT": "Close a command buffer marker region.",
  "vkCmdDebugMarkerEndEXT.commandBuffer": "",
  "vkCmdDebugMarkerInsertEXT": "Insert a marker label into a command buffer.",
  "vkCmdDebugMarkerInsertEXT.commandBuffer": "",
  "vkCmdDebugMarkerInsertEXT.pMarkerInfo": "",
  "vkCmdDispatch": "Dispatch compute work items.",
  "vkCmdDispatch.commandBuffer": "",
  "vkCmdDispatch.groupCountX": "",
  "vkCmdDispatch.groupCountY": "",
  "vkCmdDispatch.groupCountZ": "",
  "vkCmdDispatchBaseKHX": "Dispatch compute work items.",
  "vkCmdDispatchBaseKHX.baseGroupX": "",
  "vkCmdDispatchBaseKHX.baseGroupY": "",
  "vkCmdDispatchBaseKHX.baseGroupZ": "",
  "vkCmdDispatchBaseKHX.commandBuffer": "",
  "vkCmdDispatchBaseKHX.groupCountX": "",
  "vkCmdDispatchBaseKHX.groupCountY": "",
  "vkCmdDispatchBaseKHX.groupCountZ": "",
  "vkCmdDispatchIndirect": "Dispatch compute work items using indirect parameters.",
  "vkCmdDispatchIndirect.buffer": "",
  "vkCmdDispatchIndirect.commandBuffer": "",
  "vkCmdDispatchIndirect.offset": "",
  "vkCmdDraw": "Draw primitives.",
  "vkCmdDraw.commandBuffer": "",
  "vkCmdDraw.firstInstance": "",
  "vkCmdDraw.firstVertex": "",
  "vkCmdDraw.instanceCount": "",
  "vkCmdDraw.vertexCount": "",
  "vkCmdDrawIndexed": "Issue an indexed draw into a command buffer.",
  "vkCmdDrawIndexed.commandBuffer": "",
  "vkCmdDrawIndexed.firstIndex": "",
  "vkCmdDrawIndexed.firstInstance": "",
  "vkCmdDrawIndexed.indexCount": "",
  "vkCmdDrawIndexed.instanceCount": "",
  "vkCmdDrawIndexed.vertexOffset": "",
  "vkCmdDrawIndexedIndirect": "Perform an indexed indirect draw.",
  "vkCmdDrawIndexedIndirect.buffer": "",
  "vkCmdDrawIndexedIndirect.commandBuffer": "",
  "vkCmdDrawIndexedIndirect.drawCount": "",
  "vkCmdDrawIndexedIndirect.offset": "",
  "vkCmdDrawIndexedIndirect.stride": "",
  "vkCmdDrawIndexedIndirectCountAMD": "Perform an indexed indirect draw with the draw count sourced from a buffer.",
  "vkCmdDrawIndexedIndirectCountAMD.buffer": "",
  "vkCmdDrawIndexedIndirectCountAMD.commandBuffer": "",
  "vkCmdDrawIndexedIndirectCountAMD.countBuffer": "",
  "vkCmdDrawIndexedIndirectCountAMD.countBufferOffset": "",
  "vkCmdDrawIndexedIndirectCountAMD.maxDrawCount": "",
  "vkCmdDrawIndexedIndirectCountAMD.offset": "",
  "vkCmdDrawIndexedIndirectCountAMD.stride": "",
  "vkCmdDrawIndirect": "Issue an indirect draw into a command buffer.",
  "vkCmdDrawIndirect.buffer": "",
  "vkCmdDrawIndirect.commandBuffer": "",
  "vkCmdDrawIndirect.drawCount": "",
  "vkCmdDrawIndirect.offset": "",
  "vkCmdDrawIndirect.stride": "",
  "vkCmdDrawIndirectCountAMD": "Perform an indirect draw with the draw count sourced from a buffer.",
  "vkCmdDrawIndirectCountAMD.buffer": "",
  "vkCmdDrawIndirectCountAMD.commandBuffer": "",
  "vkCmdDrawIndirectCountAMD.countBuffer": "",
  "vkCmdDrawIndirectCountAMD.countBufferOffset": "",
  "vkCmdDrawIndirectCountAMD.maxDrawCount": "",
  "vkCmdDrawIndirectCountAMD.offset": "",
  "vkCmdDrawIndirectCountAMD.stride": "",
  "vkCmdEndQuery": "Ends a query.",
  "vkCmdEndQuery.commandBuffer": "",
  "vkCmdEndQuery.query": "",
  "vkCmdEndQuery.queryPool": "",
  "vkCmdEndRenderPass": "End the current render pass.",
  "vkCmdEndRenderPass.commandBuffer": "",
  "vkCmdExecuteCommands": "Execute a secondary command buffer from a primary command buffer.",
  "vkCmdExecuteCommands.commandBuffer": "",
  "vkCmdExecuteCommands.commandBufferCount": "",
  "vkCmdExecuteCommands.pCommandBuffers": "",
  "vkCmdFillBuffer": "Fill a region of a buffer with a fixed value.",
  "vkCmdFillBuffer.commandBuffer": "",
  "vkCmdFillBuffer.data": "",
  "vkCmdFillBuffer.dstBuffer": "",
  "vkCmdFillBuffer.dstOffset": "",
  "vkCmdFillBuffer.size": "",
  "vkCmdNextSubpass": "Transition to the next subpass of a render pass.",
  "vkCmdNextSubpass.commandBuffer": "",
  "vkCmdNextSubpass.contents": "",
  "vkCmdPipelineBarrier": "Insert a memory dependency.",
  "vkCmdPipelineBarrier.bufferMemoryBarrierCount": "",
  "vkCmdPipelineBarrier.commandBuffer": "",
  "vkCmdPipelineBarrier.dependencyFlags": "",
  "vkCmdPipelineBarrier.dstStageMask": "",
  "vkCmdPipelineBarrier.imageMemoryBarrierCount": "",
  "vkCmdPipelineBarrier.memoryBarrierCount": "",
  "vkCmdPipelineBarrier.pBufferMemoryBarriers": "",
  "vkCmdPipelineBarrier.pImageMemoryBarriers": "",
  "vkCmdPipelineBarrier.pMemoryBarriers": "",
  "vkCmdPipelineBarrier.srcStageMask": "",
  "VkCmdProcessCommandsInfoNVX": "Structure specifying parameters for the generation of commands.",
  "VkCmdProcessCommandsInfoNVX.indirectCommandsLayout": "The IndirectCommandsLayoutNVX that provides the command sequence to generate.",
  "VkCmdProcessCommandsInfoNVX.indirectCommandsTokenCount": "indirectCommandsTokenCount defines the number of input tokens used.",
  "VkCmdProcessCommandsInfoNVX.maxSequencesCount": "The maximum number of sequences for which command buffer space will be reserved. If sequencesCountBuffer is null, this is also the actual number of sequences generated.",
  "VkCmdProcessCommandsInfoNVX.objectTable": "The ObjectTableNVX to be used for the generation process. Only registered objects at the time flink:vkCmdReserveSpaceForCommandsNVX is called, will be taken into account for the reservation.",
  "VkCmdProcessCommandsInfoNVX.pIndirectCommandsTokens": "pIndirectCommandsTokens provides an array of IndirectCommandsTokenNVX that reference the input data for each token command.",
  "VkCmdProcessCommandsInfoNVX.pNext": "Null or an extension-specific structure.",
  "VkCmdProcessCommandsInfoNVX.sequencesCountBuffer": "sequencesCountBuffer can be Buffer from which the actual amount of sequences is sourced from as ftext:uint32_t value.",
  "VkCmdProcessCommandsInfoNVX.sequencesCountOffset": "The byte offset into sequencesCountBuffer where the count value is stored.",
  "VkCmdProcessCommandsInfoNVX.sequencesIndexBuffer": "sequencesIndexBuffer must be set if indirectCommandsLayout's VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT is set and provides the used sequence indices as ftext:uint32_t array. Otherwise it must be null.",
  "VkCmdProcessCommandsInfoNVX.sequencesIndexOffset": "The byte offset into sequencesIndexBuffer where the index values start.",
  "VkCmdProcessCommandsInfoNVX.sType": "The type of this structure.",
  "VkCmdProcessCommandsInfoNVX.targetCommandBuffer": "targetCommandBuffer can be the secondary CommandBuffer in which the commands should be recorded. If targetCommandBuffer is Null an implicit reservation as well as execution takes place on the processing CommandBuffer.",
  "vkCmdProcessCommandsNVX": "Performs the generation of commands on the device.",
  "vkCmdProcessCommandsNVX.commandBuffer": "",
  "vkCmdProcessCommandsNVX.pProcessCommandsInfo": "",
  "vkCmdPushConstants": "Update the values of push constants.",
  "vkCmdPushConstants.commandBuffer": "",
  "vkCmdPushConstants.layout": "",
  "vkCmdPushConstants.offset": "",
  "vkCmdPushConstants.pValues": "",
  "vkCmdPushConstants.size": "",
  "vkCmdPushConstants.stageFlags": "",
  "vkCmdPushDescriptorSetKHR": "Pushes descriptor updates into a command buffer.",
  "vkCmdPushDescriptorSetKHR.commandBuffer": "",
  "vkCmdPushDescriptorSetKHR.descriptorWriteCount": "",
  "vkCmdPushDescriptorSetKHR.layout": "",
  "vkCmdPushDescriptorSetKHR.pDescriptorWrites": "",
  "vkCmdPushDescriptorSetKHR.pipelineBindPoint": "",
  "vkCmdPushDescriptorSetKHR.set": "",
  "vkCmdPushDescriptorSetWithTemplateKHR": "Pushes descriptor updates into a command buffer using a descriptor update template.",
  "vkCmdPushDescriptorSetWithTemplateKHR.commandBuffer": "",
  "vkCmdPushDescriptorSetWithTemplateKHR.descriptorUpdateTemplate": "",
  "vkCmdPushDescriptorSetWithTemplateKHR.layout": "",
  "vkCmdPushDescriptorSetWithTemplateKHR.pData": "",
  "vkCmdPushDescriptorSetWithTemplateKHR.set": "",
  "VkCmdReserveSpaceForCommandsInfoNVX": "Structure specifying parameters for the reservation of command buffer space.",
  "VkCmdReserveSpaceForCommandsInfoNVX.indirectCommandsLayout": "The IndirectCommandsLayoutNVX that must also be used at generation time.",
  "VkCmdReserveSpaceForCommandsInfoNVX.maxSequencesCount": "The maximum number of sequences for which command buffer space will be reserved.",
  "VkCmdReserveSpaceForCommandsInfoNVX.objectTable": "The ObjectTableNVX to be used for the generation process. Only registered objects at the time flink:vkCmdReserveSpaceForCommandsNVX is called, will be taken into account for the reservation.",
  "VkCmdReserveSpaceForCommandsInfoNVX.pNext": "Null or an extension-specific structure.",
  "VkCmdReserveSpaceForCommandsInfoNVX.sType": "The type of this structure.",
  "vkCmdReserveSpaceForCommandsNVX": "Perform a reservation of command buffer space.",
  "vkCmdReserveSpaceForCommandsNVX.commandBuffer": "",
  "vkCmdReserveSpaceForCommandsNVX.pReserveSpaceInfo": "",
  "vkCmdResetEvent": "Reset an event object to non-signaled state.",
  "vkCmdResetEvent.commandBuffer": "",
  "vkCmdResetEvent.event": "",
  "vkCmdResetEvent.stageMask": "",
  "vkCmdResetQueryPool": "Reset queries in a query pool.",
  "vkCmdResetQueryPool.commandBuffer": "",
  "vkCmdResetQueryPool.firstQuery": "",
  "vkCmdResetQueryPool.queryCount": "",
  "vkCmdResetQueryPool.queryPool": "",
  "vkCmdResolveImage": "Resolve regions of an image.",
  "vkCmdResolveImage.commandBuffer": "",
  "vkCmdResolveImage.dstImage": "",
  "vkCmdResolveImage.dstImageLayout": "",
  "vkCmdResolveImage.pRegions": "",
  "vkCmdResolveImage.regionCount": "",
  "vkCmdResolveImage.srcImage": "",
  "vkCmdResolveImage.srcImageLayout": "",
  "vkCmdSetBlendConstants": "Set the values of blend constants.",
  "vkCmdSetBlendConstants.blendConstants": "",
  "vkCmdSetBlendConstants.commandBuffer": "",
  "vkCmdSetDepthBias": "Set the depth bias dynamic state.",
  "vkCmdSetDepthBias.commandBuffer": "",
  "vkCmdSetDepthBias.depthBiasClamp": "",
  "vkCmdSetDepthBias.depthBiasConstantFactor": "",
  "vkCmdSetDepthBias.depthBiasSlopeFactor": "",
  "vkCmdSetDepthBounds": "Set the depth bounds test values for a command buffer.",
  "vkCmdSetDepthBounds.commandBuffer": "",
  "vkCmdSetDepthBounds.maxDepthBounds": "",
  "vkCmdSetDepthBounds.minDepthBounds": "",
  "vkCmdSetDeviceMaskKHX": "Modify device mask of a command buffer.",
  "vkCmdSetDeviceMaskKHX.commandBuffer": "",
  "vkCmdSetDeviceMaskKHX.deviceMask": "",
  "vkCmdSetDiscardRectangleEXT": "",
  "vkCmdSetDiscardRectangleEXT.commandBuffer": "",
  "vkCmdSetDiscardRectangleEXT.discardRectangleCount": "",
  "vkCmdSetDiscardRectangleEXT.firstDiscardRectangle": "",
  "vkCmdSetDiscardRectangleEXT.pDiscardRectangles": "",
  "vkCmdSetEvent": "Set an event object to signaled state.",
  "vkCmdSetEvent.commandBuffer": "",
  "vkCmdSetEvent.event": "",
  "vkCmdSetEvent.stageMask": "",
  "vkCmdSetLineWidth": "Set the dynamic line width state.",
  "vkCmdSetLineWidth.commandBuffer": "",
  "vkCmdSetLineWidth.lineWidth": "",
  "vkCmdSetSampleLocationsEXT": "",
  "vkCmdSetSampleLocationsEXT.commandBuffer": "",
  "vkCmdSetSampleLocationsEXT.pSampleLocationsInfo": "",
  "vkCmdSetScissor": "Set the dynamic scissor rectangles on a command buffer.",
  "vkCmdSetScissor.commandBuffer": "",
  "vkCmdSetScissor.firstScissor": "",
  "vkCmdSetScissor.pScissors": "",
  "vkCmdSetScissor.scissorCount": "",
  "vkCmdSetStencilCompareMask": "Set the stencil compare mask dynamic state.",
  "vkCmdSetStencilCompareMask.commandBuffer": "",
  "vkCmdSetStencilCompareMask.compareMask": "",
  "vkCmdSetStencilCompareMask.faceMask": "",
  "vkCmdSetStencilReference": "Set the stencil reference dynamic state.",
  "vkCmdSetStencilReference.commandBuffer": "",
  "vkCmdSetStencilReference.faceMask": "",
  "vkCmdSetStencilReference.reference": "",
  "vkCmdSetStencilWriteMask": "Set the stencil write mask dynamic state.",
  "vkCmdSetStencilWriteMask.commandBuffer": "",
  "vkCmdSetStencilWriteMask.faceMask": "",
  "vkCmdSetStencilWriteMask.writeMask": "",
  "vkCmdSetViewport": "Set the viewport on a command buffer.",
  "vkCmdSetViewport.commandBuffer": "",
  "vkCmdSetViewport.firstViewport": "",
  "vkCmdSetViewport.pViewports": "",
  "vkCmdSetViewport.viewportCount": "",
  "vkCmdSetViewportWScalingNV": "Set the viewport W scaling on a command buffer.",
  "vkCmdSetViewportWScalingNV.commandBuffer": "",
  "vkCmdSetViewportWScalingNV.firstViewport": "",
  "vkCmdSetViewportWScalingNV.pViewportWScalings": "",
  "vkCmdSetViewportWScalingNV.viewportCount": "",
  "vkCmdUpdateBuffer": "Update a buffer's contents from host memory.",
  "vkCmdUpdateBuffer.commandBuffer": "",
  "vkCmdUpdateBuffer.dataSize": "",
  "vkCmdUpdateBuffer.dstBuffer": "",
  "vkCmdUpdateBuffer.dstOffset": "",
  "vkCmdUpdateBuffer.pData": "",
  "vkCmdWaitEvents": "Wait for one or more events and insert a set of memory.",
  "vkCmdWaitEvents.bufferMemoryBarrierCount": "",
  "vkCmdWaitEvents.commandBuffer": "",
  "vkCmdWaitEvents.dstStageMask": "",
  "vkCmdWaitEvents.eventCount": "",
  "vkCmdWaitEvents.imageMemoryBarrierCount": "",
  "vkCmdWaitEvents.memoryBarrierCount": "",
  "vkCmdWaitEvents.pBufferMemoryBarriers": "",
  "vkCmdWaitEvents.pEvents": "",
  "vkCmdWaitEvents.pImageMemoryBarriers": "",
  "vkCmdWaitEvents.pMemoryBarriers": "",
  "vkCmdWaitEvents.srcStageMask": "",
  "vkCmdWriteBufferMarkerAMD": "Execute a pipelined write of a marker value into a buffer.",
  "vkCmdWriteBufferMarkerAMD.commandBuffer": "The command buffer into which the command will be recorded.",
  "vkCmdWriteBufferMarkerAMD.dstBuffer": "The buffer where the marker will be written to.",
  "vkCmdWriteBufferMarkerAMD.dstOffset": "The byte offset into the buffer where the marker will be written to.",
  "vkCmdWriteBufferMarkerAMD.marker": "The 32-bit value of the marker.",
  "vkCmdWriteBufferMarkerAMD.pipelineStage": "One of the PipelineStageFlags values, specifying the pipeline stage whose completion triggers the marker write.",
  "vkCmdWriteTimestamp": "Write a device timestamp into a query object.",
  "vkCmdWriteTimestamp.commandBuffer": "",
  "vkCmdWriteTimestamp.pipelineStage": "",
  "vkCmdWriteTimestamp.query": "",
  "vkCmdWriteTimestamp.queryPool": "",
  "VkColorComponentFlagBits": "Bitmask controlling which components are written to the framebuffer.",
  "VkColorComponentFlagBits.__none": "",
  "VkColorComponentFlagBits.VK_COLOR_COMPONENT_A_BIT": "",
  "VkColorComponentFlagBits.VK_COLOR_COMPONENT_B_BIT": "",
  "VkColorComponentFlagBits.VK_COLOR_COMPONENT_G_BIT": "",
  "VkColorComponentFlagBits.VK_COLOR_COMPONENT_R_BIT": "",
  "VkColorComponentFlags": "",
  "VkColorSpaceKHR": "Supported color space of the presentation engine.",
  "VkColorSpaceKHR.VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT": "Supports the AdobeRGB color space and applies a linear OETF.",
  "VkColorSpaceKHR.VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT": "Supports the AdobeRGB color space and applies the Gamma 2.2 OETF.",
  "VkColorSpaceKHR.VK_COLOR_SPACE_BT2020_LINEAR_EXT": "Supports the BT2020 color space and applies a linear OETF.",
  "VkColorSpaceKHR.VK_COLOR_SPACE_BT709_LINEAR_EXT": "Supports the BT709 color space and applies a linear OETF.",
  "VkColorSpaceKHR.VK_COLOR_SPACE_BT709_NONLINEAR_EXT": "Supports the BT709 color space and applies the SMPTE 170M OETF.",
  "VkColorSpaceKHR.VK_COLOR_SPACE_DCI_P3_LINEAR_EXT": "Supports the DCI-P3 color space and applies a linear OETF.",
  "VkColorSpaceKHR.VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT": "Supports the DCI-P3 color space and applies the Gamma 2.6 OETF.",
  "VkColorSpaceKHR.VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT": "",
  "VkColorSpaceKHR.VK_COLOR_SPACE_DOLBYVISION_EXT": "",
  "VkColorSpaceKHR.VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT": "",
  "VkColorSpaceKHR.VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT": "",
  "VkColorSpaceKHR.VK_COLOR_SPACE_HDR10_HLG_EXT": "",
  "VkColorSpaceKHR.VK_COLOR_SPACE_HDR10_ST2084_EXT": "",
  "VkColorSpaceKHR.VK_COLOR_SPACE_PASS_THROUGH_EXT": "",
  "VkColorSpaceKHR.VK_COLOR_SPACE_SRGB_NONLINEAR_KHR": "Supports the sRGB color space.",
  "VkCommandBuffer": "Opaque handle to a command buffer object.",
  "VkCommandBufferAllocateInfo": "Structure specifying the allocation parameters for command buffer object.",
  "VkCommandBufferAllocateInfo.commandBufferCount": "",
  "VkCommandBufferAllocateInfo.commandPool": "The command pool from which the command buffers are allocated.",
  "VkCommandBufferAllocateInfo.level": "level determines whether the command buffers are primary or secondary command buffers. Possible values include: + --",
  "VkCommandBufferAllocateInfo.pNext": "Null or an extension-specific structure.",
  "VkCommandBufferAllocateInfo.sType": "The type of this structure.",
  "VkCommandBufferBeginInfo": "Structure specifying a command buffer begin operation.",
  "VkCommandBufferBeginInfo.flags": "A bitmask indicating usage behavior for the command buffer. Bits which can be set include: + --",
  "VkCommandBufferBeginInfo.pInheritanceInfo": "",
  "VkCommandBufferBeginInfo.pNext": "Null or an extension-specific structure.",
  "VkCommandBufferBeginInfo.sType": "The type of this structure.",
  "VkCommandBufferInheritanceInfo": "Structure specifying command buffer inheritance info.",
  "VkCommandBufferInheritanceInfo.framebuffer": "framebuffer optionally refers to the Framebuffer object that the CommandBuffer will be rendering to if it is executed within a render pass instance. It can be null if the framebuffer is not known, or if the CommandBuffer will not be executed within a render pass instance. + [NOTE] .Note ==== Specifying the exact framebuffer that the secondary command buffer will be executed with may result in better performance at command buffer execution time. ====",
  "VkCommandBufferInheritanceInfo.occlusionQueryEnable": "Indicates whether the command buffer can be executed while an occlusion query is active in the primary command buffer. If this is VK_TRUE, then this command buffer can be executed whether the primary command buffer has an occlusion query active or not. If this is VK_FALSE, then the primary command buffer must not have an occlusion query active.",
  "VkCommandBufferInheritanceInfo.pipelineStatistics": "Indicates the set of pipeline statistics that can be counted by an active query in the primary command buffer when this secondary command buffer is executed. If this value includes a given bit, then this command buffer can be executed whether the primary command buffer has a pipeline statistics query active that includes this bit or not. If this value excludes a given bit, then the active pipeline statistics query must not be from a query pool that counts that statistic.",
  "VkCommandBufferInheritanceInfo.pNext": "Null or an extension-specific structure.",
  "VkCommandBufferInheritanceInfo.queryFlags": "Indicates the query flags that can be used by an active occlusion query in the primary command buffer when this secondary command buffer is executed. If this value includes the VK_QUERY_CONTROL_PRECISE_BIT bit, then the active query can return boolean results or actual sample counts. If this bit is not set, then the active query must not use the VK_QUERY_CONTROL_PRECISE_BIT bit.",
  "VkCommandBufferInheritanceInfo.renderPass": "A RenderPass object defining which render passes the CommandBuffer will be compatible with and can be executed within. If the CommandBuffer will not be executed within a render pass instance, renderPass is ignored.",
  "VkCommandBufferInheritanceInfo.sType": "The type of this structure.",
  "VkCommandBufferInheritanceInfo.subpass": "The index of the subpass within the render pass instance that the CommandBuffer will be executed within. If the CommandBuffer will not be executed within a render pass instance, subpass is ignored.",
  "VkCommandBufferLevel": "Structure specifying a command buffer level.",
  "VkCommandBufferLevel.VK_COMMAND_BUFFER_LEVEL_PRIMARY": "",
  "VkCommandBufferLevel.VK_COMMAND_BUFFER_LEVEL_SECONDARY": "",
  "VkCommandBufferResetFlagBits": "Bitmask controlling behavior of a command buffer reset.",
  "VkCommandBufferResetFlagBits.__none": "",
  "VkCommandBufferResetFlagBits.VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT": "",
  "VkCommandBufferResetFlags": "",
  "VkCommandBufferUsageFlagBits": "Bitmask specifying usage behavior for command buffer.",
  "VkCommandBufferUsageFlagBits.__none": "",
  "VkCommandBufferUsageFlagBits.VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT": "",
  "VkCommandBufferUsageFlagBits.VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT": "",
  "VkCommandBufferUsageFlagBits.VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT": "",
  "VkCommandBufferUsageFlags": "",
  "VkCommandPool": "Opaque handle to a command pool object.",
  "VkCommandPoolCreateFlagBits": "Bitmask specifying usage behavior for a command pool.",
  "VkCommandPoolCreateFlagBits.__none": "",
  "VkCommandPoolCreateFlagBits.VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT": "",
  "VkCommandPoolCreateFlagBits.VK_COMMAND_POOL_CREATE_TRANSIENT_BIT": "",
  "VkCommandPoolCreateFlags": "",
  "VkCommandPoolCreateInfo": "Structure specifying parameters of a newly created command pool.",
  "VkCommandPoolCreateInfo.flags": "A bitmask indicating usage behavior for the pool and command buffers allocated from it. Bits which can be set include: + --",
  "VkCommandPoolCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkCommandPoolCreateInfo.queueFamilyIndex": "",
  "VkCommandPoolCreateInfo.sType": "The type of this structure.",
  "VkCommandPoolResetFlagBits": "Bitmask controlling behavior of a command pool reset.",
  "VkCommandPoolResetFlagBits.__none": "",
  "VkCommandPoolResetFlagBits.VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT": "",
  "VkCommandPoolResetFlags": "",
  "VkCommandPoolTrimFlagsKHR": "",
  "VkCommandPoolTrimFlagsKHR.__none": "",
  "VkCompareOp": "Stencil comparison function.",
  "VkCompareOp.VK_COMPARE_OP_ALWAYS": "The test always passes.",
  "VkCompareOp.VK_COMPARE_OP_EQUAL": "The test passes when [eq]#R = S#.",
  "VkCompareOp.VK_COMPARE_OP_GREATER": "The test passes when [eq]#R > S#.",
  "VkCompareOp.VK_COMPARE_OP_GREATER_OR_EQUAL": "The test passes when [eq]#R {geq} S#.",
  "VkCompareOp.VK_COMPARE_OP_LESS": "The test passes when [eq]#R < S#.",
  "VkCompareOp.VK_COMPARE_OP_LESS_OR_EQUAL": "The test passes when [eq]#R {leq} S#.",
  "VkCompareOp.VK_COMPARE_OP_NEVER": "The test never passes.",
  "VkCompareOp.VK_COMPARE_OP_NOT_EQUAL": "The test passes when [eq]#R {neq} S#.",
  "VkComponentMapping": "Structure specifying a color component mapping.",
  "VkComponentMapping.a": "a determines the component value placed in the A component of the output vector.",
  "VkComponentMapping.b": "b determines the component value placed in the B component of the output vector.",
  "VkComponentMapping.g": "g determines the component value placed in the G component of the output vector.",
  "VkComponentMapping.r": "r determines the component value placed in the R component of the output vector.",
  "VkComponentSwizzle": "Specify how a component is swizzled.",
  "VkComponentSwizzle.VK_COMPONENT_SWIZZLE_A": "The component is set to the value of the A component of the image.",
  "VkComponentSwizzle.VK_COMPONENT_SWIZZLE_B": "The component is set to the value of the B component of the image.",
  "VkComponentSwizzle.VK_COMPONENT_SWIZZLE_G": "The component is set to the value of the G component of the image.",
  "VkComponentSwizzle.VK_COMPONENT_SWIZZLE_IDENTITY": "The component is set to the identity swizzle.",
  "VkComponentSwizzle.VK_COMPONENT_SWIZZLE_ONE": "The component is set to either 1 or 1.0 depending on whether the type of the image view format is integer or floating-point respectively, as determined by the Format Definition section for each Format.",
  "VkComponentSwizzle.VK_COMPONENT_SWIZZLE_R": "The component is set to the value of the R component of the image.",
  "VkComponentSwizzle.VK_COMPONENT_SWIZZLE_ZERO": "The component is set to zero.",
  "VkCompositeAlphaFlagBitsKHR": "Alpha compositing modes supported on a device.",
  "VkCompositeAlphaFlagBitsKHR.__none": "",
  "VkCompositeAlphaFlagBitsKHR.VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR": "The way in which the presentation engine treats the alpha channel in the images is unknown to the Vulkan API. Instead, the application is responsible for setting the composite alpha blending mode using native window system commands. If the application does not set the blending mode using native window system commands, then a platform-specific default will be used.",
  "VkCompositeAlphaFlagBitsKHR.VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR": "The alpha channel, if it exists, of the images is ignored in the compositing process. Instead, the image is treated as if it has a constant alpha of 1.0.",
  "VkCompositeAlphaFlagBitsKHR.VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR": "The alpha channel, if it exists, of the images is respected in the compositing process. The non-alpha channels of the image are not expected to already be multiplied by the alpha channel by the application; instead, the compositor will multiply the non-alpha channels of the image by the alpha channel during compositing.",
  "VkCompositeAlphaFlagBitsKHR.VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR": "The alpha channel, if it exists, of the images is respected in the compositing process. The non-alpha channels of the image are expected to already be multiplied by the alpha channel by the application.",
  "VkCompositeAlphaFlagsKHR": "",
  "VkComputePipelineCreateInfo": "Structure specifying parameters of a newly created compute pipeline.",
  "VkComputePipelineCreateInfo.basePipelineHandle": "A pipeline to derive from",
  "VkComputePipelineCreateInfo.basePipelineIndex": "An index into the pCreateInfos parameter to use as a pipeline to derive from",
  "VkComputePipelineCreateInfo.flags": "flags provides options for pipeline creation, and is of type PipelineCreateFlagBits.",
  "VkComputePipelineCreateInfo.layout": "The description of binding locations used by both the pipeline and descriptor sets used with the pipeline.",
  "VkComputePipelineCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkComputePipelineCreateInfo.stage": "A PipelineShaderStageCreateInfo describing the compute shader.",
  "VkComputePipelineCreateInfo.sType": "The type of this structure.",
  "VkConservativeRasterizationModeEXT": "",
  "VkConservativeRasterizationModeEXT.VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT": "",
  "VkConservativeRasterizationModeEXT.VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT": "",
  "VkConservativeRasterizationModeEXT.VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT": "",
  "VkCopyDescriptorSet": "Structure specifying a copy descriptor set operation.",
  "VkCopyDescriptorSet.descriptorCount": "The number of descriptors to copy from the source to destination. If descriptorCount is greater than the number of remaining array elements in the source or destination binding, those affect consecutive bindings in a manner similar to WriteDescriptorSet above.",
  "VkCopyDescriptorSet.dstArrayElement": "",
  "VkCopyDescriptorSet.dstBinding": "",
  "VkCopyDescriptorSet.dstSet": "dstSet, dstBinding, and dstArrayElement are the destination set, binding, and array element, respectively.",
  "VkCopyDescriptorSet.pNext": "Null or an extension-specific structure.",
  "VkCopyDescriptorSet.srcArrayElement": "",
  "VkCopyDescriptorSet.srcBinding": "",
  "VkCopyDescriptorSet.srcSet": "srcSet, srcBinding, and srcArrayElement are the source set, binding, and array element, respectively.",
  "VkCopyDescriptorSet.sType": "The type of this structure.",
  "VkCoverageModulationModeNV": "",
  "VkCoverageModulationModeNV.VK_COVERAGE_MODULATION_MODE_ALPHA_NV": "",
  "VkCoverageModulationModeNV.VK_COVERAGE_MODULATION_MODE_NONE_NV": "",
  "VkCoverageModulationModeNV.VK_COVERAGE_MODULATION_MODE_RGB_NV": "",
  "VkCoverageModulationModeNV.VK_COVERAGE_MODULATION_MODE_RGBA_NV": "",
  "vkCreateAndroidSurfaceKHR": "Create a SurfaceKHR object for an Android native window.",
  "vkCreateAndroidSurfaceKHR.instance": "",
  "vkCreateAndroidSurfaceKHR.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateAndroidSurfaceKHR.pCreateInfo": "",
  "vkCreateAndroidSurfaceKHR.pSurface": "",
  "vkCreateBuffer": "Create a new buffer object.",
  "vkCreateBuffer.device": "",
  "vkCreateBuffer.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateBuffer.pBuffer": "",
  "vkCreateBuffer.pCreateInfo": "",
  "vkCreateBufferView": "Create a new buffer view object.",
  "vkCreateBufferView.device": "",
  "vkCreateBufferView.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateBufferView.pCreateInfo": "",
  "vkCreateBufferView.pView": "",
  "vkCreateCommandPool": "Create a new command pool object.",
  "vkCreateCommandPool.device": "",
  "vkCreateCommandPool.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateCommandPool.pCommandPool": "",
  "vkCreateCommandPool.pCreateInfo": "",
  "vkCreateComputePipelines": "Creates a new compute pipeline object.",
  "vkCreateComputePipelines.createInfoCount": "",
  "vkCreateComputePipelines.device": "",
  "vkCreateComputePipelines.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateComputePipelines.pCreateInfos": "",
  "vkCreateComputePipelines.pipelineCache": "",
  "vkCreateComputePipelines.pPipelines": "",
  "vkCreateDebugReportCallbackEXT": "Create a debug report callback object.",
  "vkCreateDebugReportCallbackEXT.instance": "",
  "vkCreateDebugReportCallbackEXT.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateDebugReportCallbackEXT.pCallback": "",
  "vkCreateDebugReportCallbackEXT.pCreateInfo": "",
  "vkCreateDescriptorPool": "Creates a descriptor pool object.",
  "vkCreateDescriptorPool.device": "",
  "vkCreateDescriptorPool.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateDescriptorPool.pCreateInfo": "",
  "vkCreateDescriptorPool.pDescriptorPool": "",
  "vkCreateDescriptorSetLayout": "Create a new descriptor set layout.",
  "vkCreateDescriptorSetLayout.device": "",
  "vkCreateDescriptorSetLayout.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateDescriptorSetLayout.pCreateInfo": "",
  "vkCreateDescriptorSetLayout.pSetLayout": "",
  "vkCreateDescriptorUpdateTemplateKHR": "Create a new descriptor update template.",
  "vkCreateDescriptorUpdateTemplateKHR.device": "",
  "vkCreateDescriptorUpdateTemplateKHR.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateDescriptorUpdateTemplateKHR.pCreateInfo": "",
  "vkCreateDescriptorUpdateTemplateKHR.pDescriptorUpdateTemplate": "",
  "vkCreateDevice": "Create a new device instance.",
  "vkCreateDevice.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateDevice.pCreateInfo": "",
  "vkCreateDevice.pDevice": "",
  "vkCreateDevice.physicalDevice": "",
  "vkCreateDisplayModeKHR": "Create a display mode.",
  "vkCreateDisplayModeKHR.display": "",
  "vkCreateDisplayModeKHR.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateDisplayModeKHR.pCreateInfo": "",
  "vkCreateDisplayModeKHR.physicalDevice": "",
  "vkCreateDisplayModeKHR.pMode": "",
  "vkCreateDisplayPlaneSurfaceKHR": "Create a SurfaceKHR structure representing a display plane and mode.",
  "vkCreateDisplayPlaneSurfaceKHR.instance": "",
  "vkCreateDisplayPlaneSurfaceKHR.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateDisplayPlaneSurfaceKHR.pCreateInfo": "",
  "vkCreateDisplayPlaneSurfaceKHR.pSurface": "",
  "vkCreateEvent": "Create a new event object.",
  "vkCreateEvent.device": "",
  "vkCreateEvent.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateEvent.pCreateInfo": "",
  "vkCreateEvent.pEvent": "",
  "vkCreateFence": "Create a new fence object.",
  "vkCreateFence.device": "",
  "vkCreateFence.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateFence.pCreateInfo": "",
  "vkCreateFence.pFence": "",
  "vkCreateFramebuffer": "Create a new framebuffer object.",
  "vkCreateFramebuffer.device": "",
  "vkCreateFramebuffer.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateFramebuffer.pCreateInfo": "",
  "vkCreateFramebuffer.pFramebuffer": "",
  "vkCreateGraphicsPipelines": "Create graphics pipelines.",
  "vkCreateGraphicsPipelines.createInfoCount": "",
  "vkCreateGraphicsPipelines.device": "",
  "vkCreateGraphicsPipelines.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateGraphicsPipelines.pCreateInfos": "",
  "vkCreateGraphicsPipelines.pipelineCache": "",
  "vkCreateGraphicsPipelines.pPipelines": "",
  "vkCreateImage": "Create a new image object.",
  "vkCreateImage.device": "",
  "vkCreateImage.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateImage.pCreateInfo": "",
  "vkCreateImage.pImage": "",
  "vkCreateImageView": "Create an image view from an existing image.",
  "vkCreateImageView.device": "",
  "vkCreateImageView.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateImageView.pCreateInfo": "",
  "vkCreateImageView.pView": "",
  "vkCreateIndirectCommandsLayoutNVX": "",
  "vkCreateIndirectCommandsLayoutNVX.device": "",
  "vkCreateIndirectCommandsLayoutNVX.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateIndirectCommandsLayoutNVX.pCreateInfo": "",
  "vkCreateIndirectCommandsLayoutNVX.pIndirectCommandsLayout": "",
  "vkCreateInstance": "Create a new Vulkan instance.",
  "vkCreateInstance.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateInstance.pCreateInfo": "",
  "vkCreateInstance.pInstance": "",
  "vkCreateIOSSurfaceMVK": "Create a SurfaceKHR object for an iOS UIView.",
  "vkCreateIOSSurfaceMVK.instance": "",
  "vkCreateIOSSurfaceMVK.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateIOSSurfaceMVK.pCreateInfo": "",
  "vkCreateIOSSurfaceMVK.pSurface": "",
  "vkCreateMacOSSurfaceMVK": "Create a SurfaceKHR object for a macOS NSView.",
  "vkCreateMacOSSurfaceMVK.instance": "",
  "vkCreateMacOSSurfaceMVK.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateMacOSSurfaceMVK.pCreateInfo": "",
  "vkCreateMacOSSurfaceMVK.pSurface": "",
  "vkCreateMirSurfaceKHR": "Create a SurfaceKHR object for a Mir window.",
  "vkCreateMirSurfaceKHR.instance": "",
  "vkCreateMirSurfaceKHR.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateMirSurfaceKHR.pCreateInfo": "",
  "vkCreateMirSurfaceKHR.pSurface": "",
  "vkCreateObjectTableNVX": "",
  "vkCreateObjectTableNVX.device": "",
  "vkCreateObjectTableNVX.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateObjectTableNVX.pCreateInfo": "",
  "vkCreateObjectTableNVX.pObjectTable": "",
  "vkCreatePipelineCache": "Creates a new pipeline cache.",
  "vkCreatePipelineCache.device": "",
  "vkCreatePipelineCache.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreatePipelineCache.pCreateInfo": "",
  "vkCreatePipelineCache.pPipelineCache": "",
  "vkCreatePipelineLayout": "Creates a new pipeline layout object.",
  "vkCreatePipelineLayout.device": "",
  "vkCreatePipelineLayout.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreatePipelineLayout.pCreateInfo": "",
  "vkCreatePipelineLayout.pPipelineLayout": "",
  "vkCreateQueryPool": "Create a new query pool object.",
  "vkCreateQueryPool.device": "",
  "vkCreateQueryPool.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateQueryPool.pCreateInfo": "",
  "vkCreateQueryPool.pQueryPool": "",
  "vkCreateRenderPass": "Create a new render pass object.",
  "vkCreateRenderPass.device": "",
  "vkCreateRenderPass.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateRenderPass.pCreateInfo": "",
  "vkCreateRenderPass.pRenderPass": "",
  "vkCreateSampler": "Create a new sampler object.",
  "vkCreateSampler.device": "",
  "vkCreateSampler.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateSampler.pCreateInfo": "",
  "vkCreateSampler.pSampler": "",
  "vkCreateSamplerYcbcrConversionKHR": "",
  "vkCreateSamplerYcbcrConversionKHR.device": "",
  "vkCreateSamplerYcbcrConversionKHR.pAllocator": "",
  "vkCreateSamplerYcbcrConversionKHR.pCreateInfo": "",
  "vkCreateSamplerYcbcrConversionKHR.pYcbcrConversion": "",
  "vkCreateSemaphore": "Create a new queue semaphore object.",
  "vkCreateSemaphore.device": "",
  "vkCreateSemaphore.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateSemaphore.pCreateInfo": "",
  "vkCreateSemaphore.pSemaphore": "",
  "vkCreateShaderModule": "Creates a new shader module object.",
  "vkCreateShaderModule.device": "",
  "vkCreateShaderModule.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateShaderModule.pCreateInfo": "",
  "vkCreateShaderModule.pShaderModule": "",
  "vkCreateSharedSwapchainsKHR": "Create multiple swapchains that share presentable images.",
  "vkCreateSharedSwapchainsKHR.device": "",
  "vkCreateSharedSwapchainsKHR.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateSharedSwapchainsKHR.pCreateInfos": "",
  "vkCreateSharedSwapchainsKHR.pSwapchains": "",
  "vkCreateSharedSwapchainsKHR.swapchainCount": "",
  "vkCreateSwapchainKHR": "Create a swapchain.",
  "vkCreateSwapchainKHR.device": "",
  "vkCreateSwapchainKHR.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateSwapchainKHR.pCreateInfo": "",
  "vkCreateSwapchainKHR.pSwapchain": "",
  "vkCreateValidationCacheEXT": "",
  "vkCreateValidationCacheEXT.device": "",
  "vkCreateValidationCacheEXT.pAllocator": "",
  "vkCreateValidationCacheEXT.pCreateInfo": "",
  "vkCreateValidationCacheEXT.pValidationCache": "",
  "vkCreateViSurfaceNN": "Create a SurfaceKHR object for a VI layer.",
  "vkCreateViSurfaceNN.instance": "",
  "vkCreateViSurfaceNN.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateViSurfaceNN.pCreateInfo": "",
  "vkCreateViSurfaceNN.pSurface": "",
  "vkCreateWaylandSurfaceKHR": "Create a SurfaceKHR object for a Wayland window.",
  "vkCreateWaylandSurfaceKHR.instance": "",
  "vkCreateWaylandSurfaceKHR.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateWaylandSurfaceKHR.pCreateInfo": "",
  "vkCreateWaylandSurfaceKHR.pSurface": "",
  "vkCreateWin32SurfaceKHR": "Create a SurfaceKHR object for an Win32 native window.",
  "vkCreateWin32SurfaceKHR.instance": "",
  "vkCreateWin32SurfaceKHR.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateWin32SurfaceKHR.pCreateInfo": "",
  "vkCreateWin32SurfaceKHR.pSurface": "",
  "vkCreateXcbSurfaceKHR": "Create a SurfaceKHR object for a X11 window, using the XCB client-side library.",
  "vkCreateXcbSurfaceKHR.instance": "",
  "vkCreateXcbSurfaceKHR.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateXcbSurfaceKHR.pCreateInfo": "",
  "vkCreateXcbSurfaceKHR.pSurface": "",
  "vkCreateXlibSurfaceKHR": "Create a SurfaceKHR object for an X11 window, using the Xlib client-side library.",
  "vkCreateXlibSurfaceKHR.instance": "",
  "vkCreateXlibSurfaceKHR.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkCreateXlibSurfaceKHR.pCreateInfo": "",
  "vkCreateXlibSurfaceKHR.pSurface": "",
  "VkCullModeFlagBits": "Bitmask controlling triangle culling.",
  "VkCullModeFlagBits.VK_CULL_MODE_BACK_BIT": "",
  "VkCullModeFlagBits.VK_CULL_MODE_FRONT_AND_BACK": "",
  "VkCullModeFlagBits.VK_CULL_MODE_FRONT_BIT": "",
  "VkCullModeFlagBits.VK_CULL_MODE_NONE": "",
  "VkCullModeFlags": "",
  "VkD3D12FenceSubmitInfoKHR": "",
  "VkD3D12FenceSubmitInfoKHR.pNext": "",
  "VkD3D12FenceSubmitInfoKHR.pSignalSemaphoreValues": "",
  "VkD3D12FenceSubmitInfoKHR.pWaitSemaphoreValues": "",
  "VkD3D12FenceSubmitInfoKHR.signalSemaphoreValuesCount": "",
  "VkD3D12FenceSubmitInfoKHR.sType": "",
  "VkD3D12FenceSubmitInfoKHR.waitSemaphoreValuesCount": "",
  "VkDebugMarkerMarkerInfoEXT": "Specify parameters of a command buffer marker region.",
  "VkDebugMarkerMarkerInfoEXT.color": "An optional RGBA color value that can be associated with the marker. A particular implementation may choose to ignore this color value. The values contain RGBA values in order, in the range 0.0 to 1.0. If all elements in color are set to 0.0 then it is ignored.",
  "VkDebugMarkerMarkerInfoEXT.pMarkerName": "A string that contains the name of the marker.",
  "VkDebugMarkerMarkerInfoEXT.pNext": "Null or an extension-specific structure.",
  "VkDebugMarkerMarkerInfoEXT.sType": "The type of this structure.",
  "VkDebugMarkerObjectNameInfoEXT": "Specify parameters of a name to give to an object.",
  "VkDebugMarkerObjectNameInfoEXT.object": "The object to be named.",
  "VkDebugMarkerObjectNameInfoEXT.objectType": "A DebugReportObjectTypeEXT specifying the type of the object to be named.",
  "VkDebugMarkerObjectNameInfoEXT.pNext": "Null or an extension-specific structure.",
  "VkDebugMarkerObjectNameInfoEXT.pObjectName": "A string specifying the name to apply to object.",
  "VkDebugMarkerObjectNameInfoEXT.sType": "The type of this structure.",
  "VkDebugMarkerObjectTagInfoEXT": "Specify parameters of a tag to attach to an object.",
  "VkDebugMarkerObjectTagInfoEXT.object": "The object to be tagged.",
  "VkDebugMarkerObjectTagInfoEXT.objectType": "A DebugReportObjectTypeEXT specifying the type of the object to be named.",
  "VkDebugMarkerObjectTagInfoEXT.pNext": "Null or an extension-specific structure.",
  "VkDebugMarkerObjectTagInfoEXT.pTag": "An array of tagSize bytes containing the data to be associated with the object.",
  "VkDebugMarkerObjectTagInfoEXT.sType": "The type of this structure.",
  "VkDebugMarkerObjectTagInfoEXT.tagName": "A numerical identifier of the tag.",
  "VkDebugMarkerObjectTagInfoEXT.tagSize": "The number of bytes of data to attach to the object.",
  "vkDebugMarkerSetObjectNameEXT": "Give a user-friendly name to an object.",
  "vkDebugMarkerSetObjectNameEXT.device": "",
  "vkDebugMarkerSetObjectNameEXT.pNameInfo": "",
  "vkDebugMarkerSetObjectTagEXT": "Attach arbitrary data to an object.",
  "vkDebugMarkerSetObjectTagEXT.device": "",
  "vkDebugMarkerSetObjectTagEXT.pTagInfo": "",
  "VkDebugReportCallbackCreateInfoEXT": "Structure specifying parameters of a newly created debug report callback.",
  "VkDebugReportCallbackCreateInfoEXT.flags": "flags indicate which event(s) will cause this callback to be called. Flags are interpreted as bitmasks and multiple may be set. Bits which can be set include: + --",
  "VkDebugReportCallbackCreateInfoEXT.pfnCallback": "",
  "VkDebugReportCallbackCreateInfoEXT.pNext": "Null or an extension-specific structure.",
  "VkDebugReportCallbackCreateInfoEXT.pUserData": "",
  "VkDebugReportCallbackCreateInfoEXT.sType": "The type of this structure.",
  "VkDebugReportCallbackEXT": "",
  "VkDebugReportFlagBitsEXT": "Bitmask specifying events which cause a debug report callback.",
  "VkDebugReportFlagBitsEXT.__none": "",
  "VkDebugReportFlagBitsEXT.VK_DEBUG_REPORT_DEBUG_BIT_EXT": "Indicates diagnostic information from the loader and layers. -- +",
  "VkDebugReportFlagBitsEXT.VK_DEBUG_REPORT_ERROR_BIT_EXT": "Indicates an error that may cause undefined results, including an application crash.",
  "VkDebugReportFlagBitsEXT.VK_DEBUG_REPORT_INFORMATION_BIT_EXT": "Indicates an informational message such as resource details that may be handy when debugging an application.",
  "VkDebugReportFlagBitsEXT.VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT": "Indicates a potentially non-optimal use of Vulkan. E.g. using flink:vkCmdClearColorImage when a RenderPass load_op would have worked.",
  "VkDebugReportFlagBitsEXT.VK_DEBUG_REPORT_WARNING_BIT_EXT": "Indicates use of Vulkan that may expose an app bug. Such cases may not be immediately harmful, such as a fragment shader outputting to a location with no attachment. Other cases may point to behavior that is almost certainly bad when unintended such as using an image whose memory has not been filled. In general if you see a warning but you know that the behavior is intended/desired, then simply ignore the warning.",
  "VkDebugReportFlagsEXT": "",
  "vkDebugReportMessageEXT": "",
  "vkDebugReportMessageEXT.flags": "",
  "vkDebugReportMessageEXT.instance": "",
  "vkDebugReportMessageEXT.location": "",
  "vkDebugReportMessageEXT.messageCode": "",
  "vkDebugReportMessageEXT.object": "",
  "vkDebugReportMessageEXT.objectType": "",
  "vkDebugReportMessageEXT.pLayerPrefix": "",
  "vkDebugReportMessageEXT.pMessage": "",
  "VkDebugReportObjectTypeEXT": "Specify the type of an object handle.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT": "A Buffer.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT": "A BufferView.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT": "A CommandBuffer.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT": "A CommandPool.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT": "",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT": "A DescriptorPool.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT": "A DescriptorSet.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT": "A DescriptorSetLayout.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT": "",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT": "A Device.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT": "A DeviceMemory.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT": "A DisplayKHR.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT": "A DisplayModeKHR.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT": "A Event.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT": "A Fence.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT": "A Framebuffer.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT": "A Image.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT": "A ImageView.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT": "A IndirectCommandsLayoutNVX.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT": "A Instance.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT": "A ObjectTableNVX.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT": "A PhysicalDevice.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT": "A PipelineCache.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT": "A Pipeline.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT": "A PipelineLayout.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT": "A QueryPool.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT": "A Queue.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT": "A RenderPass.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT": "A Sampler.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT": "",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT": "A Semaphore.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT": "A ShaderModule.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT": "A SurfaceKHR.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT": "A SwapchainKHR.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT": "An unknown object.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT": "",
  "VkDedicatedAllocationBufferCreateInfoNV": "Specify that a buffer is bound to a dedicated memory resource.",
  "VkDedicatedAllocationBufferCreateInfoNV.dedicatedAllocation": "Indicates whether the buffer will have a dedicated allocation bound to it.",
  "VkDedicatedAllocationBufferCreateInfoNV.pNext": "Null or an extension-specific structure.",
  "VkDedicatedAllocationBufferCreateInfoNV.sType": "The type of this structure.",
  "VkDedicatedAllocationImageCreateInfoNV": "Specify that an image is bound to a dedicated memory resource.",
  "VkDedicatedAllocationImageCreateInfoNV.dedicatedAllocation": "Indicates whether the image will have a dedicated allocation bound to it.",
  "VkDedicatedAllocationImageCreateInfoNV.pNext": "Null or an extension-specific structure.",
  "VkDedicatedAllocationImageCreateInfoNV.sType": "The type of this structure.",
  "VkDedicatedAllocationMemoryAllocateInfoNV": "Specify a dedicated memory allocation resource.",
  "VkDedicatedAllocationMemoryAllocateInfoNV.buffer": "buffer is null or a handle of a buffer which this memory will be bound to.",
  "VkDedicatedAllocationMemoryAllocateInfoNV.image": "image is null or a handle of an image which this memory will be bound to.",
  "VkDedicatedAllocationMemoryAllocateInfoNV.pNext": "Null or an extension-specific structure.",
  "VkDedicatedAllocationMemoryAllocateInfoNV.sType": "The type of this structure.",
  "VkDependencyFlagBits": "Bitmask specifying how execution and memory dependencies are formed.",
  "VkDependencyFlagBits.__none": "",
  "VkDependencyFlagBits.VK_DEPENDENCY_BY_REGION_BIT": "Dependency is per pixel region ",
  "VkDependencyFlagBits.VK_DEPENDENCY_DEVICE_GROUP_BIT_KHX": "",
  "VkDependencyFlagBits.VK_DEPENDENCY_VIEW_LOCAL_BIT_KHX": "",
  "VkDependencyFlags": "",
  "VkDescriptorBufferInfo": "Structure specifying descriptor buffer info.",
  "VkDescriptorBufferInfo.buffer": "The buffer resource.",
  "VkDescriptorBufferInfo.offset": "The offset in bytes from the start of buffer. Access to buffer memory via this descriptor uses addressing that is relative to this starting offset.",
  "VkDescriptorBufferInfo.range": "The size in bytes that is used for this descriptor update, or VK_WHOLE_SIZE to use the range from offset to the end of the buffer. + -- [NOTE] .Note ==== When using VK_WHOLE_SIZE, the effective range must not be larger than the maximum range for the descriptor type (maxUniformBufferRange or maxStorageBufferRange). This means that VK_WHOLE_SIZE is not typically useful in the common case where uniform buffer descriptors are suballocated from a buffer that is much larger than maxUniformBufferRange. ==== -- + For VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC and VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC descriptor types, offset is the base offset from which the dynamic offset is applied and range is the static size used for all dynamic offsets.",
  "VkDescriptorImageInfo": "Structure specifying descriptor image info.",
  "VkDescriptorImageInfo.imageLayout": "The layout that the image will be in at the time this descriptor is accessed. imageLayout is used in descriptor updates for types VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT.",
  "VkDescriptorImageInfo.imageView": "An image view handle, and is used in descriptor updates for types VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT.",
  "VkDescriptorImageInfo.sampler": "A sampler handle, and is used in descriptor updates for types VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER if the binding being updated does not use immutable samplers.",
  "VkDescriptorPool": "Opaque handle to a descriptor pool object.",
  "VkDescriptorPoolCreateFlagBits": "Bitmask specifying certain supported operations on a descriptor pool.",
  "VkDescriptorPoolCreateFlagBits.__none": "",
  "VkDescriptorPoolCreateFlagBits.VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT": "",
  "VkDescriptorPoolCreateFlags": "",
  "VkDescriptorPoolCreateInfo": "Structure specifying parameters of a newly created descriptor pool.",
  "VkDescriptorPoolCreateInfo.flags": "Specifies certain supported operations on the pool. Bits which can be set include: + --",
  "VkDescriptorPoolCreateInfo.maxSets": "",
  "VkDescriptorPoolCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkDescriptorPoolCreateInfo.poolSizeCount": "",
  "VkDescriptorPoolCreateInfo.pPoolSizes": "",
  "VkDescriptorPoolCreateInfo.sType": "The type of this structure.",
  "VkDescriptorPoolResetFlags": "",
  "VkDescriptorPoolResetFlags.__none": "",
  "VkDescriptorPoolSize": "Structure specifying descriptor pool size.",
  "VkDescriptorPoolSize.descriptorCount": "The number of descriptors of that type to allocate.",
  "VkDescriptorPoolSize.type": "The type of descriptor.",
  "VkDescriptorSet": "Opaque handle to a descriptor set object.",
  "VkDescriptorSetAllocateInfo": "Structure specifying the allocation parameters for descriptor sets.",
  "VkDescriptorSetAllocateInfo.descriptorPool": "The pool which the sets will be allocated from.",
  "VkDescriptorSetAllocateInfo.descriptorSetCount": "descriptorSetCount determines the number of descriptor sets to be allocated from the pool.",
  "VkDescriptorSetAllocateInfo.pNext": "Null or an extension-specific structure.",
  "VkDescriptorSetAllocateInfo.pSetLayouts": "An array of descriptor set layouts, with each member specifying how the corresponding descriptor set is allocated.",
  "VkDescriptorSetAllocateInfo.sType": "The type of this structure.",
  "VkDescriptorSetLayout": "Opaque handle to a descriptor set layout object.",
  "VkDescriptorSetLayoutBinding": "Structure specifying a descriptor set layout binding.",
  "VkDescriptorSetLayoutBinding.binding": "The binding number of this entry and corresponds to a resource of the same binding number in the shader stages.",
  "VkDescriptorSetLayoutBinding.descriptorCount": "The number of descriptors contained in the binding, accessed in a shader as an array. If descriptorCount is zero this binding entry is reserved and the resource must not be accessed from any stage via this binding within any pipeline using the set layout.",
  "VkDescriptorSetLayoutBinding.descriptorType": "A DescriptorType specifying which type of resource descriptors are used for this binding.",
  "VkDescriptorSetLayoutBinding.pImmutableSamplers": "pImmutableSamplers affects initialization of samplers. If descriptorType specifies a VK_DESCRIPTOR_TYPE_SAMPLER or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER type descriptor, then pImmutableSamplers can be used to initialize a set of _immutable samplers_. Immutable samplers are permanently bound into the set layout; later binding a sampler into an immutable sampler slot in a descriptor set is not allowed. If pImmutableSamplers is not Null, then it is considered to be an array of sampler handles that will be consumed by the set layout and used for the corresponding binding. If pImmutableSamplers is Null, then the sampler slots are dynamic and sampler handles must be bound into descriptor sets using this layout. If descriptorType is not one of these descriptor types, then pImmutableSamplers is ignored.",
  "VkDescriptorSetLayoutBinding.stageFlags": "stageFlags member is a bitmask of ShaderStageFlagBits specifying which pipeline shader stages can access a resource for this binding. VK_SHADER_STAGE_ALL is a shorthand specifying that all defined shader stages, including any additional stages defined by extensions, can access the resource. + -- If a shader stage is not included in stageFlags, then a resource must not be accessed from that stage via this binding within any pipeline using the set layout. There are no limitations on what combinations of stages can be used by a descriptor binding, and in particular a binding can be used by both graphics stages and the compute stage. --",
  "VkDescriptorSetLayoutCreateFlagBits": "Bitmask specifying descriptor set layout properties.",
  "VkDescriptorSetLayoutCreateFlagBits.__none": "",
  "VkDescriptorSetLayoutCreateFlagBits.VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR": "",
  "VkDescriptorSetLayoutCreateFlags": "",
  "VkDescriptorSetLayoutCreateInfo": "Structure specifying parameters of a newly created descriptor set layout.",
  "VkDescriptorSetLayoutCreateInfo.bindingCount": "",
  "VkDescriptorSetLayoutCreateInfo.flags": "flags provides options for descriptor set layout creation, and is of type DescriptorSetLayoutCreateFlags. Bits which can be set include: + --",
  "VkDescriptorSetLayoutCreateInfo.pBindings": "",
  "VkDescriptorSetLayoutCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkDescriptorSetLayoutCreateInfo.sType": "The type of this structure.",
  "VkDescriptorType": "Specifies the type of a descriptor in a descriptor set.",
  "VkDescriptorType.VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER": "",
  "VkDescriptorType.VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT": "",
  "VkDescriptorType.VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE": "",
  "VkDescriptorType.VK_DESCRIPTOR_TYPE_SAMPLER": "",
  "VkDescriptorType.VK_DESCRIPTOR_TYPE_STORAGE_BUFFER": "",
  "VkDescriptorType.VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC": "",
  "VkDescriptorType.VK_DESCRIPTOR_TYPE_STORAGE_IMAGE": "",
  "VkDescriptorType.VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER": "",
  "VkDescriptorType.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER": "",
  "VkDescriptorType.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC": "",
  "VkDescriptorType.VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER": "",
  "VkDescriptorUpdateTemplateCreateFlagsKHR": "",
  "VkDescriptorUpdateTemplateCreateFlagsKHR.__none": "",
  "VkDescriptorUpdateTemplateCreateInfoKHR": "Structure specifying parameters of a newly created descriptor update template.",
  "VkDescriptorUpdateTemplateCreateInfoKHR.descriptorSetLayout": "The descriptor set layout the parameter update template will be used with. All descriptor sets which are going to be updated through the newly created descriptor update template must be created with this layout. descriptorSetLayout is the descriptor set layout used to build the descriptor update template. All descriptor sets which are going to be updated through the newly created descriptor update template must be created with a layout that matches (is the same as, or defined identically to) this layout. This parameter is ignored if templateType is not VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR.",
  "VkDescriptorUpdateTemplateCreateInfoKHR.descriptorUpdateEntryCount": "The number of elements in the pDescriptorUpdateEntries array.",
  "VkDescriptorUpdateTemplateCreateInfoKHR.flags": "Reserved for future use.",
  "VkDescriptorUpdateTemplateCreateInfoKHR.pDescriptorUpdateEntries": "An array of DescriptorUpdateTemplateEntryKHR structures describing the descriptors to be updated by the descriptor update template.",
  "VkDescriptorUpdateTemplateCreateInfoKHR.pipelineBindPoint": "A PipelineBindPoint indicating whether the descriptors will be used by graphics pipelines or compute pipelines. This parameter is ignored if templateType is not VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR",
  "VkDescriptorUpdateTemplateCreateInfoKHR.pipelineLayout": "A PipelineLayout object used to program the bindings. This parameter is ignored if templateType is not VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR",
  "VkDescriptorUpdateTemplateCreateInfoKHR.pNext": "Null or an extension-specific structure.",
  "VkDescriptorUpdateTemplateCreateInfoKHR.set": "The set number of the descriptor set in the pipeline layout that will be updated. This parameter is ignored if templateType is not VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR ifndef::VK_KHR_push_descriptor[]",
  "VkDescriptorUpdateTemplateCreateInfoKHR.sType": "The type of this structure.",
  "VkDescriptorUpdateTemplateCreateInfoKHR.templateType": "Specifies the type of the descriptor update template. If set to VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR it can only be used to update descriptor sets with a fixed descriptorSetLayout. If set to VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR it can only be used to push descriptor sets using the provided pipelineBindPoint, pipelineLayout, and set number.",
  "VkDescriptorUpdateTemplateEntryKHR": "Describes a single descriptor update of the descriptor update template.",
  "VkDescriptorUpdateTemplateEntryKHR.descriptorCount": "The number of descriptors to update. If descriptorCount is greater than the number of remaining array elements in the destination binding, those affect consecutive bindings in a manner similar to WriteDescriptorSet above.",
  "VkDescriptorUpdateTemplateEntryKHR.descriptorType": "A DescriptorType specifying the type of the descriptor.",
  "VkDescriptorUpdateTemplateEntryKHR.dstArrayElement": "The starting element in the array belonging to dstBinding.",
  "VkDescriptorUpdateTemplateEntryKHR.dstBinding": "The descriptor binding to update when using this descriptor update template.",
  "VkDescriptorUpdateTemplateEntryKHR.offset": "The offset in bytes of the first binding in the raw data structure.",
  "VkDescriptorUpdateTemplateEntryKHR.stride": "The stride in bytes between two consecutive array elements of the descriptor update informations in the raw data structure. The actual pointer ptr for each array element j of update entry i is computed using the following formula: [source,c++] --------------------------------------------------- const char *ptr = (const char *)pData + pDescriptorUpdateEntries[i].offset + j * pDescriptorUpdateEntries[i].stride --------------------------------------------------- The stride is useful in case the bindings are stored in structs along with other data.",
  "VkDescriptorUpdateTemplateKHR": "A descriptor update template specifies a mapping from descriptor update information in host memory to descriptors in a descriptor set. It is designed to avoid passing redundant information to the driver when frequently updating the same set of descriptors in descriptor sets.",
  "VkDescriptorUpdateTemplateTypeKHR": "Indicates the valid usage of the descriptor update template.",
  "VkDescriptorUpdateTemplateTypeKHR.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR": "Indicates that the descriptor update template will be used for descriptor set updates only.",
  "VkDescriptorUpdateTemplateTypeKHR.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR": "Indicates that the descriptor update template will be used for push descriptor updates only.",
  "vkDestroyBuffer": "Destroy a buffer object.",
  "vkDestroyBuffer.buffer": "",
  "vkDestroyBuffer.device": "",
  "vkDestroyBuffer.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroyBufferView": "Destroy a buffer view object.",
  "vkDestroyBufferView.bufferView": "",
  "vkDestroyBufferView.device": "",
  "vkDestroyBufferView.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroyCommandPool": "Destroy a command pool object.",
  "vkDestroyCommandPool.commandPool": "",
  "vkDestroyCommandPool.device": "",
  "vkDestroyCommandPool.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroyDebugReportCallbackEXT": "Destroy a debug report callback object.",
  "vkDestroyDebugReportCallbackEXT.callback": "",
  "vkDestroyDebugReportCallbackEXT.instance": "",
  "vkDestroyDebugReportCallbackEXT.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroyDescriptorPool": "Destroy a descriptor pool object.",
  "vkDestroyDescriptorPool.descriptorPool": "",
  "vkDestroyDescriptorPool.device": "",
  "vkDestroyDescriptorPool.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroyDescriptorSetLayout": "Destroy a descriptor set layout object.",
  "vkDestroyDescriptorSetLayout.descriptorSetLayout": "",
  "vkDestroyDescriptorSetLayout.device": "",
  "vkDestroyDescriptorSetLayout.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroyDescriptorUpdateTemplateKHR": "Destroy a descriptor update template object.",
  "vkDestroyDescriptorUpdateTemplateKHR.descriptorUpdateTemplate": "",
  "vkDestroyDescriptorUpdateTemplateKHR.device": "",
  "vkDestroyDescriptorUpdateTemplateKHR.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroyDevice": "Destroy a logical device.",
  "vkDestroyDevice.device": "",
  "vkDestroyDevice.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroyEvent": "Destroy an event object.",
  "vkDestroyEvent.device": "",
  "vkDestroyEvent.event": "",
  "vkDestroyEvent.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroyFence": "Destroy a fence object.",
  "vkDestroyFence.device": "",
  "vkDestroyFence.fence": "",
  "vkDestroyFence.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroyFramebuffer": "Destroy a framebuffer object.",
  "vkDestroyFramebuffer.device": "",
  "vkDestroyFramebuffer.framebuffer": "",
  "vkDestroyFramebuffer.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroyImage": "Destroy an image object.",
  "vkDestroyImage.device": "",
  "vkDestroyImage.image": "",
  "vkDestroyImage.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroyImageView": "Destroy an image view object.",
  "vkDestroyImageView.device": "",
  "vkDestroyImageView.imageView": "",
  "vkDestroyImageView.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroyIndirectCommandsLayoutNVX": "Destroy a object table.",
  "vkDestroyIndirectCommandsLayoutNVX.device": "",
  "vkDestroyIndirectCommandsLayoutNVX.indirectCommandsLayout": "",
  "vkDestroyIndirectCommandsLayoutNVX.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroyInstance": "Destroy an instance of Vulkan.",
  "vkDestroyInstance.instance": "",
  "vkDestroyInstance.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroyObjectTableNVX": "Destroy a object table.",
  "vkDestroyObjectTableNVX.device": "",
  "vkDestroyObjectTableNVX.objectTable": "",
  "vkDestroyObjectTableNVX.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroyPipeline": "Destroy a pipeline object.",
  "vkDestroyPipeline.device": "",
  "vkDestroyPipeline.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroyPipeline.pipeline": "",
  "vkDestroyPipelineCache": "Destroy a pipeline cache object.",
  "vkDestroyPipelineCache.device": "",
  "vkDestroyPipelineCache.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroyPipelineCache.pipelineCache": "",
  "vkDestroyPipelineLayout": "Destroy a pipeline layout object.",
  "vkDestroyPipelineLayout.device": "",
  "vkDestroyPipelineLayout.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroyPipelineLayout.pipelineLayout": "",
  "vkDestroyQueryPool": "Destroy a query pool object.",
  "vkDestroyQueryPool.device": "",
  "vkDestroyQueryPool.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroyQueryPool.queryPool": "",
  "vkDestroyRenderPass": "Destroy a render pass object.",
  "vkDestroyRenderPass.device": "",
  "vkDestroyRenderPass.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroyRenderPass.renderPass": "",
  "vkDestroySampler": "Destroy a sampler object.",
  "vkDestroySampler.device": "",
  "vkDestroySampler.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroySampler.sampler": "",
  "vkDestroySamplerYcbcrConversionKHR": "",
  "vkDestroySamplerYcbcrConversionKHR.device": "",
  "vkDestroySamplerYcbcrConversionKHR.pAllocator": "",
  "vkDestroySamplerYcbcrConversionKHR.ycbcrConversion": "",
  "vkDestroySemaphore": "Destroy a semaphore object.",
  "vkDestroySemaphore.device": "",
  "vkDestroySemaphore.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroySemaphore.semaphore": "",
  "vkDestroyShaderModule": "Destroy a shader module module.",
  "vkDestroyShaderModule.device": "",
  "vkDestroyShaderModule.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroyShaderModule.shaderModule": "",
  "vkDestroySurfaceKHR": "Destroy a SurfaceKHR object.",
  "vkDestroySurfaceKHR.instance": "",
  "vkDestroySurfaceKHR.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroySurfaceKHR.surface": "",
  "vkDestroySwapchainKHR": "Destroy a swapchain object.",
  "vkDestroySwapchainKHR.device": "",
  "vkDestroySwapchainKHR.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkDestroySwapchainKHR.swapchain": "",
  "vkDestroyValidationCacheEXT": "",
  "vkDestroyValidationCacheEXT.device": "",
  "vkDestroyValidationCacheEXT.pAllocator": "",
  "vkDestroyValidationCacheEXT.validationCache": "",
  "VkDevice": "Opaque handle to a device object.",
  "VkDeviceCreateFlagBits": "",
  "VkDeviceCreateFlags": "",
  "VkDeviceCreateFlags.__none": "",
  "VkDeviceCreateInfo": "Structure specifying parameters of a newly created device.",
  "VkDeviceCreateInfo.enabledExtensionCount": "The number of device extensions to enable.",
  "VkDeviceCreateInfo.enabledLayerCount": "enabledLayerCount is deprecated and ignored.",
  "VkDeviceCreateInfo.flags": "Reserved for future use.",
  "VkDeviceCreateInfo.pEnabledFeatures": "Null or a PhysicalDeviceFeatures structure that contains boolean indicators of all the features to be enabled. Refer to the Features section for further details.",
  "VkDeviceCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkDeviceCreateInfo.ppEnabledExtensionNames": "An array of enabledExtensionCount strings containing the names of extensions to enable for the created device. See the Extensions section for further details.",
  "VkDeviceCreateInfo.ppEnabledLayerNames": "ppEnabledLayerNames is deprecated and ignored. See Device Layer Deprecation.",
  "VkDeviceCreateInfo.pQueueCreateInfos": "An array of DeviceQueueCreateInfo structures describing the queues that are requested to be created along with the logical device. Refer to the Queue Creation section below for further details.",
  "VkDeviceCreateInfo.queueCreateInfoCount": "The unsigned integer size of the pQueueCreateInfos array. Refer to the Queue Creation section below for further details.",
  "VkDeviceCreateInfo.sType": "The type of this structure.",
  "VkDeviceEventInfoEXT": "Describe a device event to create.",
  "VkDeviceEventInfoEXT.deviceEvent": "",
  "VkDeviceEventInfoEXT.pNext": "Null or an extension-specific structure.",
  "VkDeviceEventInfoEXT.sType": "The type of this structure.",
  "VkDeviceEventTypeEXT": "Events that can occur on a device object.",
  "VkDeviceEventTypeEXT.VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT": "",
  "VkDeviceGeneratedCommandsFeaturesNVX": "Structure specifying physical device support.",
  "VkDeviceGeneratedCommandsFeaturesNVX.computeBindingPointSupport": "Indicates whether the ObjectTableNVX supports entries with VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX bit set and IndirectCommandsLayoutNVX supports VK_PIPELINE_BIND_POINT_COMPUTE.",
  "VkDeviceGeneratedCommandsFeaturesNVX.pNext": "Null or an extension-specific structure.",
  "VkDeviceGeneratedCommandsFeaturesNVX.sType": "The type of this structure.",
  "VkDeviceGeneratedCommandsLimitsNVX": "Structure specifying physical device limits.",
  "VkDeviceGeneratedCommandsLimitsNVX.maxIndirectCommandsLayoutTokenCount": "maxIndirectCommandsLayoutTokenCount the maximum number of tokens in IndirectCommandsLayoutNVX.",
  "VkDeviceGeneratedCommandsLimitsNVX.maxObjectEntryCounts": "maxObjectEntryCounts the maximum number of entries per resource type in ObjectTableNVX.",
  "VkDeviceGeneratedCommandsLimitsNVX.minCommandsTokenBufferOffsetAlignment": "The minimum alignment for memory addresses optionally used in CommandBuffer.ProcessCommands().",
  "VkDeviceGeneratedCommandsLimitsNVX.minSequenceCountBufferOffsetAlignment": "The minimum alignment for memory addresses optionally used in CommandBuffer.ProcessCommands().",
  "VkDeviceGeneratedCommandsLimitsNVX.minSequenceIndexBufferOffsetAlignment": "The minimum alignment for memory addresses optionally used in CommandBuffer.ProcessCommands().",
  "VkDeviceGeneratedCommandsLimitsNVX.pNext": "Null or an extension-specific structure.",
  "VkDeviceGeneratedCommandsLimitsNVX.sType": "The type of this structure.",
  "VkDeviceGroupBindSparseInfoKHX": "Structure indicating which instances are bound.",
  "VkDeviceGroupBindSparseInfoKHX.memoryDeviceIndex": "A device index indicating which instance of the memory the resource instance is bound to.",
  "VkDeviceGroupBindSparseInfoKHX.pNext": "Null or an extension-specific structure.",
  "VkDeviceGroupBindSparseInfoKHX.resourceDeviceIndex": "A device index indicating which instance of the resource is bound.",
  "VkDeviceGroupBindSparseInfoKHX.sType": "The type of this structure.",
  "VkDeviceGroupCommandBufferBeginInfoKHX": "Set the initial device mask for a command buffer.",
  "VkDeviceGroupCommandBufferBeginInfoKHX.deviceMask": "The initial value of the command buffer's device mask.",
  "VkDeviceGroupCommandBufferBeginInfoKHX.pNext": "Null or an extension-specific structure.",
  "VkDeviceGroupCommandBufferBeginInfoKHX.sType": "The type of this structure.",
  "VkDeviceGroupDeviceCreateInfoKHX": "Create a logical device from multiple physical devices.",
  "VkDeviceGroupDeviceCreateInfoKHX.physicalDeviceCount": "The number of elements in the pPhysicalDevices array.",
  "VkDeviceGroupDeviceCreateInfoKHX.pNext": "Null or an extension-specific structure.",
  "VkDeviceGroupDeviceCreateInfoKHX.pPhysicalDevices": "An array of physical device handles belonging to the same device group.",
  "VkDeviceGroupDeviceCreateInfoKHX.sType": "The type of this structure.",
  "VkDeviceGroupPresentCapabilitiesKHX": "Present capabilities from other physical devices.",
  "VkDeviceGroupPresentCapabilitiesKHX.modes": "A bitmask indicating which device group presentation modes are supported. The bits returned in modes are: + --",
  "VkDeviceGroupPresentCapabilitiesKHX.pNext": "Null or an extension-specific structure.",
  "VkDeviceGroupPresentCapabilitiesKHX.presentMask": "An array of masks, where the mask at element [eq]#i# is non-zero if physical device [eq]#i# has a presentation engine, and where bit [eq]#j# is set in element [eq]#i# if physical device [eq]#i# can present swapchain images from physical device [eq]#j#. If element [eq]#i# is non-zero, then bit [eq]#i# must be set.",
  "VkDeviceGroupPresentCapabilitiesKHX.sType": "The type of this structure.",
  "VkDeviceGroupPresentInfoKHX": "Mode and mask controlling which physical devices' images are presented.",
  "VkDeviceGroupPresentInfoKHX.mode": "The device group present mode that will be used for this present.",
  "VkDeviceGroupPresentInfoKHX.pDeviceMasks": "An array of device masks, one for each element of PresentInfoKHR::pSwapchains.",
  "VkDeviceGroupPresentInfoKHX.pNext": "Null or an extension-specific structure.",
  "VkDeviceGroupPresentInfoKHX.sType": "The type of this structure.",
  "VkDeviceGroupPresentInfoKHX.swapchainCount": "swapchainCount is zero or the number of elements in pDeviceMasks.",
  "VkDeviceGroupPresentModeFlagBitsKHX": "Bitmask specifying supported device group present modes.",
  "VkDeviceGroupPresentModeFlagBitsKHX.__none": "",
  "VkDeviceGroupPresentModeFlagBitsKHX.VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHX": "",
  "VkDeviceGroupPresentModeFlagBitsKHX.VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHX": "",
  "VkDeviceGroupPresentModeFlagBitsKHX.VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHX": "",
  "VkDeviceGroupPresentModeFlagBitsKHX.VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHX": "",
  "VkDeviceGroupPresentModeFlagsKHX": "",
  "VkDeviceGroupRenderPassBeginInfoKHX": "Set the initial device mask and render areas for a render pass instance.",
  "VkDeviceGroupRenderPassBeginInfoKHX.deviceMask": "The device mask for the render pass instance.",
  "VkDeviceGroupRenderPassBeginInfoKHX.deviceRenderAreaCount": "The number of elements in the pDeviceRenderAreas array.",
  "VkDeviceGroupRenderPassBeginInfoKHX.pDeviceRenderAreas": "An array of structures of type Rect2D defining the render area for each physical device.",
  "VkDeviceGroupRenderPassBeginInfoKHX.pNext": "Null or an extension-specific structure.",
  "VkDeviceGroupRenderPassBeginInfoKHX.sType": "The type of this structure.",
  "VkDeviceGroupSubmitInfoKHX": "Structure indicating which physical devices execute semaphore operations and command buffers.",
  "VkDeviceGroupSubmitInfoKHX.commandBufferCount": "The number of elements in the pCommandBufferDeviceMasks array.",
  "VkDeviceGroupSubmitInfoKHX.pCommandBufferDeviceMasks": "An array of device masks indicating which physical devices execute the command buffer in the corresponding element of SubmitInfo::pCommandBuffers. A physical device executes the command buffer if the corresponding bit is set in the mask.",
  "VkDeviceGroupSubmitInfoKHX.pNext": "Null or an extension-specific structure.",
  "VkDeviceGroupSubmitInfoKHX.pSignalSemaphoreDeviceIndices": "An array of device indices indicating which physical device executes the semaphore signal operation in the corresponding element of SubmitInfo::pSignalSemaphores.",
  "VkDeviceGroupSubmitInfoKHX.pWaitSemaphoreDeviceIndices": "An array of device indices indicating which physical device executes the semaphore wait operation in the corresponding element of SubmitInfo::pWaitSemaphores.",
  "VkDeviceGroupSubmitInfoKHX.signalSemaphoreCount": "The number of elements in the pSignalSemaphoreDeviceIndices array.",
  "VkDeviceGroupSubmitInfoKHX.sType": "The type of this structure.",
  "VkDeviceGroupSubmitInfoKHX.waitSemaphoreCount": "The number of elements in the pWaitSemaphoreDeviceIndices array.",
  "VkDeviceGroupSwapchainCreateInfoKHX": "Structure specifying parameters of a newly created swapchain object.",
  "VkDeviceGroupSwapchainCreateInfoKHX.modes": "A bitfield of modes that the swapchain can be used with.",
  "VkDeviceGroupSwapchainCreateInfoKHX.pNext": "Null or an extension-specific structure.",
  "VkDeviceGroupSwapchainCreateInfoKHX.sType": "The type of this structure.",
  "VkDeviceMemory": "Opaque handle to a device memory object.",
  "VkDeviceQueueCreateFlagBits": "",
  "VkDeviceQueueCreateFlags": "",
  "VkDeviceQueueCreateFlags.__none": "",
  "VkDeviceQueueCreateInfo": "Structure specifying parameters of a newly created device queue.",
  "VkDeviceQueueCreateInfo.flags": "Reserved for future use.",
  "VkDeviceQueueCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkDeviceQueueCreateInfo.pQueuePriorities": "An array of queueCount normalized floating point values, specifying priorities of work that will be submitted to each created queue. See Queue Priority for more information.",
  "VkDeviceQueueCreateInfo.queueCount": "An unsigned integer specifying the number of queues to create in the queue family indicated by queueFamilyIndex.",
  "VkDeviceQueueCreateInfo.queueFamilyIndex": "An unsigned integer indicating the index of the queue family to create on this device. This index corresponds to the index of an element of the pQueueFamilyProperties array that was returned by fname:vkGetPhysicalDeviceQueueFamilyProperties.",
  "VkDeviceQueueCreateInfo.sType": "The type of this structure.",
  "VkDeviceQueueGlobalPriorityCreateInfoEXT": "",
  "VkDeviceQueueGlobalPriorityCreateInfoEXT.globalPriority": "",
  "VkDeviceQueueGlobalPriorityCreateInfoEXT.pNext": "",
  "VkDeviceQueueGlobalPriorityCreateInfoEXT.sType": "",
  "vkDeviceWaitIdle": "Wait for a device to become idle.",
  "vkDeviceWaitIdle.device": "",
  "VkDiscardRectangleModeEXT": "",
  "VkDiscardRectangleModeEXT.VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT": "",
  "VkDiscardRectangleModeEXT.VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT": "",
  "VkDispatchIndirectCommand": "Structure specifying a dispatch indirect command.",
  "VkDispatchIndirectCommand.x": "The number of local workgroups to dispatch in the X dimension.",
  "VkDispatchIndirectCommand.y": "The number of local workgroups to dispatch in the Y dimension.",
  "VkDispatchIndirectCommand.z": "The number of local workgroups to dispatch in the Z dimension.",
  "VkDisplayEventInfoEXT": "Describe a display event to create.",
  "VkDisplayEventInfoEXT.displayEvent": "Specifies when the fence will be signaled. Possible values are: + --",
  "VkDisplayEventInfoEXT.pNext": "Null or an extension-specific structure.",
  "VkDisplayEventInfoEXT.sType": "The type of this structure.",
  "VkDisplayEventTypeEXT": "Events that can occur on a display object.",
  "VkDisplayEventTypeEXT.VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT": "",
  "VkDisplayKHR": "",
  "VkDisplayModeCreateFlagsKHR": "",
  "VkDisplayModeCreateFlagsKHR.__none": "",
  "VkDisplayModeCreateInfoKHR": "Structure specifying parameters of a newly created display mode object.",
  "VkDisplayModeCreateInfoKHR.flags": "Reserved for future use, and must be zero.",
  "VkDisplayModeCreateInfoKHR.parameters": "A DisplayModeParametersKHR structure describing the display parameters to use in creating the new mode. If the parameters are not compatible with the specified display, the implementation must return Result.ErrorINITIALIZATION_FAILED.",
  "VkDisplayModeCreateInfoKHR.pNext": "Null or an extension-specific structure.",
  "VkDisplayModeCreateInfoKHR.sType": "The type of this structure.",
  "VkDisplayModeKHR": "",
  "VkDisplayModeParametersKHR": "Structure describing display parameters associated with a display mode.",
  "VkDisplayModeParametersKHR.refreshRate": "A uint32_t that is the number of times the display is refreshed each second multiplied by 1000.",
  "VkDisplayModeParametersKHR.visibleRegion": "The 2D extents of the visible region.",
  "VkDisplayModePropertiesKHR": "Structure describing display mode properties.",
  "VkDisplayModePropertiesKHR.displayMode": "A handle to the display mode described in this structure. This handle will be valid for the lifetime of the Vulkan instance.",
  "VkDisplayModePropertiesKHR.parameters": "A DisplayModeParametersKHR structure describing the display parameters associated with displayMode.",
  "VkDisplayPlaneAlphaFlagBitsKHR": "Alpha blending type.",
  "VkDisplayPlaneAlphaFlagBitsKHR.__none": "",
  "VkDisplayPlaneAlphaFlagBitsKHR.VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR": "VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR: A global alpha value must be specified that will be applied to all pixels in the source image.",
  "VkDisplayPlaneAlphaFlagBitsKHR.VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR": "The source image will be treated as opaque.",
  "VkDisplayPlaneAlphaFlagBitsKHR.VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR": "The alpha value will be determined by the alpha channel of the source image's pixels. If the source format contains no alpha values, no blending will be applied. The source alpha values are not premultiplied into the source image's other color channels.",
  "VkDisplayPlaneAlphaFlagBitsKHR.VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR": "This is equivalent to VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR except the source alpha values are assumed to be premultiplied into the source image's other color channels.",
  "VkDisplayPlaneAlphaFlagsKHR": "",
  "VkDisplayPlaneCapabilitiesKHR": "Structure describing capabilities of a mode and plane combination.",
  "VkDisplayPlaneCapabilitiesKHR.maxDstExtent": "",
  "VkDisplayPlaneCapabilitiesKHR.maxDstPosition": "",
  "VkDisplayPlaneCapabilitiesKHR.maxSrcExtent": "The maximum source rectangle size supported by this plane using the specified mode.",
  "VkDisplayPlaneCapabilitiesKHR.maxSrcPosition": "The maximum source rectangle offset supported by this plane using the specified mode. The x and y components of maxSrcPosition must each be greater than or equal to the x and y components of minSrcPosition, respectively.",
  "VkDisplayPlaneCapabilitiesKHR.minDstExtent": "",
  "VkDisplayPlaneCapabilitiesKHR.minDstPosition": "minDstPosition, maxDstPosition, minDstExtent, maxDstExtent all have similar semantics to their corresponding \"Src\" equivalents, but apply to the output region within the mode rather than the input region within the source image. Unlike the \"Src\" offsets, minDstPosition and maxDstPosition may contain negative values.",
  "VkDisplayPlaneCapabilitiesKHR.minSrcExtent": "The minimum source rectangle size supported by this plane using the specified mode.",
  "VkDisplayPlaneCapabilitiesKHR.minSrcPosition": "The minimum source rectangle offset supported by this plane using the specified mode.",
  "VkDisplayPlaneCapabilitiesKHR.supportedAlpha": "A bitmask of DisplayPlaneAlphaFlagBitsKHR describing the supported alpha blending modes.",
  "VkDisplayPlanePropertiesKHR": "Structure describing display plane properties.",
  "VkDisplayPlanePropertiesKHR.currentDisplay": "The handle of the display the plane is currently associated with. If the plane is not currently attached to any displays, this will be null.",
  "VkDisplayPlanePropertiesKHR.currentStackIndex": "The current z-order of the plane. This will be between 0 and the value returned by fname:vkGetPhysicalDeviceDisplayPlanePropertiesKHR() in pPropertyCount.",
  "vkDisplayPowerControlEXT": "Set the power state of a display.",
  "vkDisplayPowerControlEXT.device": "",
  "vkDisplayPowerControlEXT.display": "",
  "vkDisplayPowerControlEXT.pDisplayPowerInfo": "",
  "VkDisplayPowerInfoEXT": "Describe the power state of a display.",
  "VkDisplayPowerInfoEXT.pNext": "Null or an extension-specific structure.",
  "VkDisplayPowerInfoEXT.powerState": "The new power state of the display. Possible values are: + --",
  "VkDisplayPowerInfoEXT.sType": "The type of this structure.",
  "VkDisplayPowerStateEXT": "Possible power states for a Display.",
  "VkDisplayPowerStateEXT.VK_DISPLAY_POWER_STATE_OFF_EXT": "",
  "VkDisplayPowerStateEXT.VK_DISPLAY_POWER_STATE_ON_EXT": "",
  "VkDisplayPowerStateEXT.VK_DISPLAY_POWER_STATE_SUSPEND_EXT": "",
  "VkDisplayPresentInfoKHR": "Structure describing parameters of a queue presentation to a swapchain.",
  "VkDisplayPresentInfoKHR.dstRect": "A rectangular region within the visible region of the swapchain's display mode. If DisplayPresentInfoKHR is not specified, this region will be assumed to be the entire visible region of the visible region of the swapchain's mode. If the specified rectangle is a subset of the display mode's visible region, content from display planes below the swapchain's plane will be visible outside the rectangle. If there are no planes below the swapchain's, the area outside the specified rectangle will be black. If portions of the specified rectangle are outside of the display's visible region, pixels mapping only to those portions of the rectangle will be discarded.",
  "VkDisplayPresentInfoKHR.persistent": "persistent: If this is VK_TRUE, the display engine will enable buffered mode on displays that support it. This allows the display engine to stop sending content to the display until a new image is presented. The display will instead maintain a copy of the last presented image. This allows less power to be used, but may increase presentation latency. If DisplayPresentInfoKHR is not specified, persistent mode will not be used.",
  "VkDisplayPresentInfoKHR.pNext": "Null or an extension-specific structure.",
  "VkDisplayPresentInfoKHR.srcRect": "A rectangular region of pixels to present. It must be a subset of the image being presented. If DisplayPresentInfoKHR is not specified, this region will be assumed to be the entire presentable image.",
  "VkDisplayPresentInfoKHR.sType": "The type of this structure.",
  "VkDisplayPropertiesKHR": "Structure describing an available display device.",
  "VkDisplayPropertiesKHR.display": "A handle that is used to refer to the display described here. This handle will be valid for the lifetime of the Vulkan instance.",
  "VkDisplayPropertiesKHR.displayName": "A NULL-terminated string containing the name of the display. Generally, this will be the name provided by the display's EDID. It can be Null if no suitable name is available.",
  "VkDisplayPropertiesKHR.persistentContent": "",
  "VkDisplayPropertiesKHR.physicalDimensions": "physicalDimensions describes the physical width and height of the visible portion of the display, in millimeters.",
  "VkDisplayPropertiesKHR.physicalResolution": "physicalResolution describes the physical, native, or preferred resolution of the display.",
  "VkDisplayPropertiesKHR.planeReorderPossible": "",
  "VkDisplayPropertiesKHR.supportedTransforms": "",
  "VkDisplaySurfaceCreateFlagsKHR": "",
  "VkDisplaySurfaceCreateFlagsKHR.__none": "",
  "VkDisplaySurfaceCreateInfoKHR": "Structure specifying parameters of a newly created display plane surface object.",
  "VkDisplaySurfaceCreateInfoKHR.alphaMode": "The type of alpha blending to use.",
  "VkDisplaySurfaceCreateInfoKHR.displayMode": "The mode to use when displaying this surface.",
  "VkDisplaySurfaceCreateInfoKHR.flags": "Reserved for future use, and must be zero.",
  "VkDisplaySurfaceCreateInfoKHR.globalAlpha": "The global alpha value. This value is ignored if alphaMode is not VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR.",
  "VkDisplaySurfaceCreateInfoKHR.imageExtent": "",
  "VkDisplaySurfaceCreateInfoKHR.planeIndex": "The plane on which this surface appears.",
  "VkDisplaySurfaceCreateInfoKHR.planeStackIndex": "The z-order of the plane.",
  "VkDisplaySurfaceCreateInfoKHR.pNext": "Null or an extension-specific structure.",
  "VkDisplaySurfaceCreateInfoKHR.sType": "The type of this structure.",
  "VkDisplaySurfaceCreateInfoKHR.transform": "The transform to apply to the images as part of the scanout operation.",
  "VkDrawIndexedIndirectCommand": "Structure specifying a draw indexed indirect command.",
  "VkDrawIndexedIndirectCommand.firstIndex": "The base index within the index buffer.",
  "VkDrawIndexedIndirectCommand.firstInstance": "The instance ID of the first instance to draw.",
  "VkDrawIndexedIndirectCommand.indexCount": "The number of vertices to draw.",
  "VkDrawIndexedIndirectCommand.instanceCount": "The number of instances to draw.",
  "VkDrawIndexedIndirectCommand.vertexOffset": "The value added to the vertex index before indexing into the vertex buffer.",
  "VkDrawIndirectCommand": "Structure specifying a draw indirect command.",
  "VkDrawIndirectCommand.firstInstance": "The instance ID of the first instance to draw.",
  "VkDrawIndirectCommand.firstVertex": "The index of the first vertex to draw.",
  "VkDrawIndirectCommand.instanceCount": "The number of instances to draw.",
  "VkDrawIndirectCommand.vertexCount": "The number of vertices to draw.",
  "VkDynamicState": "Indicate which dynamic state is taken from dynamic state commands.",
  "VkDynamicState.VK_DYNAMIC_STATE_BLEND_CONSTANTS": "Indicates that the blendConstants state in PipelineColorBlendStateCreateInfo will be ignored and must be set dynamically with flink:vkCmdSetBlendConstants before any draws are performed with a pipeline state with PipelineColorBlendAttachmentState member blendEnable set to VK_TRUE and any of the blend functions using a constant blend color.",
  "VkDynamicState.VK_DYNAMIC_STATE_DEPTH_BIAS": "Indicates that the depthBiasConstantFactor, depthBiasClamp and depthBiasSlopeFactor states in PipelineRasterizationStateCreateInfo will be ignored and must be set dynamically with flink:vkCmdSetDepthBias before any draws are performed with depthBiasEnable in PipelineRasterizationStateCreateInfo set to VK_TRUE.",
  "VkDynamicState.VK_DYNAMIC_STATE_DEPTH_BOUNDS": "Indicates that the minDepthBounds and maxDepthBounds states of PipelineDepthStencilStateCreateInfo will be ignored and must be set dynamically with flink:vkCmdSetDepthBounds before any draws are performed with a pipeline state with PipelineDepthStencilStateCreateInfo member depthBoundsTestEnable set to VK_TRUE.",
  "VkDynamicState.VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT": "",
  "VkDynamicState.VK_DYNAMIC_STATE_LINE_WIDTH": "Indicates that the lineWidth state in PipelineRasterizationStateCreateInfo will be ignored and must be set dynamically with flink:vkCmdSetLineWidth before any draw commands that generate line primitives for the rasterizer.",
  "VkDynamicState.VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT": "",
  "VkDynamicState.VK_DYNAMIC_STATE_SCISSOR": "Indicates that the pScissors state in PipelineViewportStateCreateInfo will be ignored and must be set dynamically with flink:vkCmdSetScissor before any draw commands. The number of scissor rectangles used by a pipeline is still specified by the scissorCount member of PipelineViewportStateCreateInfo.",
  "VkDynamicState.VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK": "Indicates that the compareMask state in PipelineDepthStencilStateCreateInfo for both front and back will be ignored and must be set dynamically with flink:vkCmdSetStencilCompareMask before any draws are performed with a pipeline state with PipelineDepthStencilStateCreateInfo member stencilTestEnable set to VK_TRUE",
  "VkDynamicState.VK_DYNAMIC_STATE_STENCIL_REFERENCE": "Indicates that the reference state in PipelineDepthStencilStateCreateInfo for both front and back will be ignored and must be set dynamically with flink:vkCmdSetStencilReference before any draws are performed with a pipeline state with PipelineDepthStencilStateCreateInfo member stencilTestEnable set to VK_TRUE",
  "VkDynamicState.VK_DYNAMIC_STATE_STENCIL_WRITE_MASK": "Indicates that the writeMask state in PipelineDepthStencilStateCreateInfo for both front and back will be ignored and must be set dynamically with flink:vkCmdSetStencilWriteMask before any draws are performed with a pipeline state with PipelineDepthStencilStateCreateInfo member stencilTestEnable set to VK_TRUE",
  "VkDynamicState.VK_DYNAMIC_STATE_VIEWPORT": "Indicates that the pViewports state in PipelineViewportStateCreateInfo will be ignored and must be set dynamically with flink:vkCmdSetViewport before any draw commands. The number of viewports used by a pipeline is still specified by the viewportCount member of PipelineViewportStateCreateInfo.",
  "VkDynamicState.VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV": "",
  "vkEndCommandBuffer": "Finish recording a command buffer.",
  "vkEndCommandBuffer.commandBuffer": "",
  "vkEnumerateDeviceExtensionProperties": "Returns properties of available physical device extensions.",
  "vkEnumerateDeviceExtensionProperties.physicalDevice": "",
  "vkEnumerateDeviceExtensionProperties.pLayerName": "",
  "vkEnumerateDeviceExtensionProperties.pProperties": "",
  "vkEnumerateDeviceExtensionProperties.pPropertyCount": "",
  "vkEnumerateDeviceLayerProperties": "Returns properties of available physical device layers.",
  "vkEnumerateDeviceLayerProperties.physicalDevice": "",
  "vkEnumerateDeviceLayerProperties.pProperties": "",
  "vkEnumerateDeviceLayerProperties.pPropertyCount": "",
  "vkEnumerateInstanceExtensionProperties": "Returns up to requested number of global extension properties.",
  "vkEnumerateInstanceExtensionProperties.pLayerName": "",
  "vkEnumerateInstanceExtensionProperties.pProperties": "",
  "vkEnumerateInstanceExtensionProperties.pPropertyCount": "",
  "vkEnumerateInstanceLayerProperties": "Returns up to requested number of global layer properties.",
  "vkEnumerateInstanceLayerProperties.pProperties": "",
  "vkEnumerateInstanceLayerProperties.pPropertyCount": "",
  "vkEnumeratePhysicalDeviceGroupsKHX": "Enumerates groups of physical devices that can be used to create a single logical device.",
  "vkEnumeratePhysicalDeviceGroupsKHX.instance": "",
  "vkEnumeratePhysicalDeviceGroupsKHX.pPhysicalDeviceGroupCount": "",
  "vkEnumeratePhysicalDeviceGroupsKHX.pPhysicalDeviceGroupProperties": "",
  "vkEnumeratePhysicalDevices": "Enumerates the physical devices accessible to a Vulkan instance.",
  "vkEnumeratePhysicalDevices.instance": "",
  "vkEnumeratePhysicalDevices.pPhysicalDeviceCount": "",
  "vkEnumeratePhysicalDevices.pPhysicalDevices": "",
  "VkEvent": "Opaque handle to a event object.",
  "VkEventCreateFlags": "",
  "VkEventCreateFlags.__none": "",
  "VkEventCreateInfo": "Structure specifying parameters of a newly created event.",
  "VkEventCreateInfo.flags": "Reserved for future use.",
  "VkEventCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkEventCreateInfo.sType": "The type of this structure.",
  "VkExportFenceCreateInfoKHR": "",
  "VkExportFenceCreateInfoKHR.handleTypes": "",
  "VkExportFenceCreateInfoKHR.pNext": "",
  "VkExportFenceCreateInfoKHR.sType": "",
  "VkExportFenceWin32HandleInfoKHR": "",
  "VkExportFenceWin32HandleInfoKHR.dwAccess": "",
  "VkExportFenceWin32HandleInfoKHR.name": "",
  "VkExportFenceWin32HandleInfoKHR.pAttributes": "",
  "VkExportFenceWin32HandleInfoKHR.pNext": "",
  "VkExportFenceWin32HandleInfoKHR.sType": "",
  "VkExportMemoryAllocateInfoKHR": "",
  "VkExportMemoryAllocateInfoKHR.handleTypes": "",
  "VkExportMemoryAllocateInfoKHR.pNext": "",
  "VkExportMemoryAllocateInfoKHR.sType": "",
  "VkExportMemoryAllocateInfoNV": "",
  "VkExportMemoryAllocateInfoNV.handleTypes": "",
  "VkExportMemoryAllocateInfoNV.pNext": "",
  "VkExportMemoryAllocateInfoNV.sType": "",
  "VkExportMemoryWin32HandleInfoKHR": "",
  "VkExportMemoryWin32HandleInfoKHR.dwAccess": "",
  "VkExportMemoryWin32HandleInfoKHR.name": "",
  "VkExportMemoryWin32HandleInfoKHR.pAttributes": "",
  "VkExportMemoryWin32HandleInfoKHR.pNext": "",
  "VkExportMemoryWin32HandleInfoKHR.sType": "",
  "VkExportMemoryWin32HandleInfoNV": "Specify security attributes and access rights for Win32 memory handles.",
  "VkExportMemoryWin32HandleInfoNV.dwAccess": "A DWORD specifying access rights of the handle.",
  "VkExportMemoryWin32HandleInfoNV.pAttributes": "A Windows SECURITY_ATTRIBUTES structure specifying security attributes of the handle.",
  "VkExportMemoryWin32HandleInfoNV.pNext": "Null or an extension-specific structure.",
  "VkExportMemoryWin32HandleInfoNV.sType": "The type of this structure.",
  "VkExportSemaphoreCreateInfoKHR": "",
  "VkExportSemaphoreCreateInfoKHR.handleTypes": "",
  "VkExportSemaphoreCreateInfoKHR.pNext": "",
  "VkExportSemaphoreCreateInfoKHR.sType": "",
  "VkExportSemaphoreWin32HandleInfoKHR": "",
  "VkExportSemaphoreWin32HandleInfoKHR.dwAccess": "",
  "VkExportSemaphoreWin32HandleInfoKHR.name": "",
  "VkExportSemaphoreWin32HandleInfoKHR.pAttributes": "",
  "VkExportSemaphoreWin32HandleInfoKHR.pNext": "",
  "VkExportSemaphoreWin32HandleInfoKHR.sType": "",
  "VkExtensionProperties": "Structure specifying a extension properties.",
  "VkExtensionProperties.extensionName": "A null-terminated string specifying the name of the extension.",
  "VkExtensionProperties.specVersion": "The version of this extension. It is an integer, incremented with backward compatible changes.",
  "VkExtent2D": "Structure specifying a two-dimensional extent.",
  "VkExtent2D.height": "",
  "VkExtent2D.width": "",
  "VkExtent3D": "Structure specifying a three-dimensional extent.",
  "VkExtent3D.depth": "",
  "VkExtent3D.height": "",
  "VkExtent3D.width": "",
  "VkExternalBufferPropertiesKHR": "",
  "VkExternalBufferPropertiesKHR.externalMemoryProperties": "",
  "VkExternalBufferPropertiesKHR.pNext": "",
  "VkExternalBufferPropertiesKHR.sType": "",
  "VkExternalFenceFeatureFlagBitsKHR": "",
  "VkExternalFenceFeatureFlagBitsKHR.__none": "",
  "VkExternalFenceFeatureFlagBitsKHR.VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR": "",
  "VkExternalFenceFeatureFlagBitsKHR.VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR": "",
  "VkExternalFenceFeatureFlagsKHR": "",
  "VkExternalFenceHandleTypeFlagBitsKHR": "",
  "VkExternalFenceHandleTypeFlagBitsKHR.__none": "",
  "VkExternalFenceHandleTypeFlagBitsKHR.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR": "",
  "VkExternalFenceHandleTypeFlagBitsKHR.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR": "",
  "VkExternalFenceHandleTypeFlagBitsKHR.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR": "",
  "VkExternalFenceHandleTypeFlagBitsKHR.VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR": "",
  "VkExternalFenceHandleTypeFlagsKHR": "",
  "VkExternalFencePropertiesKHR": "",
  "VkExternalFencePropertiesKHR.compatibleHandleTypes": "",
  "VkExternalFencePropertiesKHR.exportFromImportedHandleTypes": "",
  "VkExternalFencePropertiesKHR.externalFenceFeatures": "",
  "VkExternalFencePropertiesKHR.pNext": "",
  "VkExternalFencePropertiesKHR.sType": "",
  "VkExternalImageFormatPropertiesKHR": "",
  "VkExternalImageFormatPropertiesKHR.externalMemoryProperties": "",
  "VkExternalImageFormatPropertiesKHR.pNext": "",
  "VkExternalImageFormatPropertiesKHR.sType": "",
  "VkExternalImageFormatPropertiesNV": "Structure specifying external image format properties.",
  "VkExternalImageFormatPropertiesNV.compatibleHandleTypes": "A bitmask of ExternalMemoryHandleTypeFlagBitsNV containing a bit set for every external handle type that may be specified simultaneously with the handle type specified by flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV::externalHandleType when calling flink:vkAllocateMemory, or 0 if the external memory handle type is 0. compatibleHandleTypes will always contain flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV::externalHandleType",
  "VkExternalImageFormatPropertiesNV.exportFromImportedHandleTypes": "A bitmask of ExternalMemoryHandleTypeFlagBitsNV containing a bit set for every external handle type that may be used to create memory from which the handles of the type specified in flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV::externalHandleType can be exported, or 0 if the external memory handle type is 0.",
  "VkExternalImageFormatPropertiesNV.externalMemoryFeatures": "A bitmask of ExternalMemoryFeatureFlagBitsNV indicating properties of the external memory handle type (flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV::externalHandleType) being queried, or 0 if the external memory handle type is 0.",
  "VkExternalImageFormatPropertiesNV.imageFormatProperties": "imageFormatProperties will be filled in as when calling flink:vkGetPhysicalDeviceImageFormatProperties, but the values returned may vary depending on the external handle type requested.",
  "VkExternalMemoryBufferCreateInfoKHR": "",
  "VkExternalMemoryBufferCreateInfoKHR.handleTypes": "",
  "VkExternalMemoryBufferCreateInfoKHR.pNext": "",
  "VkExternalMemoryBufferCreateInfoKHR.sType": "",
  "VkExternalMemoryFeatureFlagBitsKHR": "",
  "VkExternalMemoryFeatureFlagBitsKHR.__none": "",
  "VkExternalMemoryFeatureFlagBitsKHR.VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR": "",
  "VkExternalMemoryFeatureFlagBitsKHR.VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR": "",
  "VkExternalMemoryFeatureFlagBitsKHR.VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR": "",
  "VkExternalMemoryFeatureFlagBitsNV": "Bitmask specifying external memory features.",
  "VkExternalMemoryFeatureFlagBitsNV.__none": "",
  "VkExternalMemoryFeatureFlagBitsNV.VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV": "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV: External memory of the specified type must be created as a dedicated allocation when used in the manner specified.",
  "VkExternalMemoryFeatureFlagBitsNV.VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV": "The implementation supports exporting handles of the specified type.",
  "VkExternalMemoryFeatureFlagBitsNV.VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV": "The implementation supports importing handles of the specified type.",
  "VkExternalMemoryFeatureFlagsKHR": "",
  "VkExternalMemoryFeatureFlagsNV": "",
  "VkExternalMemoryHandleTypeFlagBitsKHR": "",
  "VkExternalMemoryHandleTypeFlagBitsKHR.__none": "",
  "VkExternalMemoryHandleTypeFlagBitsKHR.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR": "",
  "VkExternalMemoryHandleTypeFlagBitsKHR.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR": "",
  "VkExternalMemoryHandleTypeFlagBitsKHR.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR": "",
  "VkExternalMemoryHandleTypeFlagBitsKHR.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR": "",
  "VkExternalMemoryHandleTypeFlagBitsKHR.VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT": "",
  "VkExternalMemoryHandleTypeFlagBitsKHR.VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT": "",
  "VkExternalMemoryHandleTypeFlagBitsKHR.VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT": "",
  "VkExternalMemoryHandleTypeFlagBitsKHR.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR": "",
  "VkExternalMemoryHandleTypeFlagBitsKHR.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR": "",
  "VkExternalMemoryHandleTypeFlagBitsKHR.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR": "",
  "VkExternalMemoryHandleTypeFlagBitsNV": "Bitmask specifying memory handle types.",
  "VkExternalMemoryHandleTypeFlagBitsNV.__none": "",
  "VkExternalMemoryHandleTypeFlagBitsNV.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV": "",
  "VkExternalMemoryHandleTypeFlagBitsNV.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV": "",
  "VkExternalMemoryHandleTypeFlagBitsNV.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV": "",
  "VkExternalMemoryHandleTypeFlagBitsNV.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV": "",
  "VkExternalMemoryHandleTypeFlagsKHR": "",
  "VkExternalMemoryHandleTypeFlagsNV": "",
  "VkExternalMemoryImageCreateInfoKHR": "",
  "VkExternalMemoryImageCreateInfoKHR.handleTypes": "",
  "VkExternalMemoryImageCreateInfoKHR.pNext": "",
  "VkExternalMemoryImageCreateInfoKHR.sType": "",
  "VkExternalMemoryImageCreateInfoNV": "Specify that an image may be backed by external memory.",
  "VkExternalMemoryImageCreateInfoNV.handleTypes": "A bitmask of ExternalMemoryHandleTypeFlagBitsNV specifying one or more external memory handle types. The types must all be compatible with each other and the other image creation parameters, as reported by flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV.",
  "VkExternalMemoryImageCreateInfoNV.pNext": "Null or an extension-specific structure.",
  "VkExternalMemoryImageCreateInfoNV.sType": "The type of this structure.",
  "VkExternalMemoryPropertiesKHR": "",
  "VkExternalMemoryPropertiesKHR.compatibleHandleTypes": "",
  "VkExternalMemoryPropertiesKHR.exportFromImportedHandleTypes": "",
  "VkExternalMemoryPropertiesKHR.externalMemoryFeatures": "",
  "VkExternalSemaphoreFeatureFlagBitsKHR": "",
  "VkExternalSemaphoreFeatureFlagBitsKHR.__none": "",
  "VkExternalSemaphoreFeatureFlagBitsKHR.VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR": "",
  "VkExternalSemaphoreFeatureFlagBitsKHR.VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR": "",
  "VkExternalSemaphoreFeatureFlagsKHR": "",
  "VkExternalSemaphoreHandleTypeFlagBitsKHR": "",
  "VkExternalSemaphoreHandleTypeFlagBitsKHR.__none": "",
  "VkExternalSemaphoreHandleTypeFlagBitsKHR.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR": "",
  "VkExternalSemaphoreHandleTypeFlagBitsKHR.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR": "",
  "VkExternalSemaphoreHandleTypeFlagBitsKHR.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR": "",
  "VkExternalSemaphoreHandleTypeFlagBitsKHR.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR": "",
  "VkExternalSemaphoreHandleTypeFlagBitsKHR.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR": "",
  "VkExternalSemaphoreHandleTypeFlagsKHR": "",
  "VkExternalSemaphorePropertiesKHR": "",
  "VkExternalSemaphorePropertiesKHR.compatibleHandleTypes": "",
  "VkExternalSemaphorePropertiesKHR.exportFromImportedHandleTypes": "",
  "VkExternalSemaphorePropertiesKHR.externalSemaphoreFeatures": "",
  "VkExternalSemaphorePropertiesKHR.pNext": "",
  "VkExternalSemaphorePropertiesKHR.sType": "",
  "VkFence": "Opaque handle to a fence object.",
  "VkFenceCreateFlagBits": "Bitmask specifying initial state and behavior of a fence.",
  "VkFenceCreateFlagBits.__none": "",
  "VkFenceCreateFlagBits.VK_FENCE_CREATE_SIGNALED_BIT": "",
  "VkFenceCreateFlags": "",
  "VkFenceCreateInfo": "Structure specifying parameters of a newly created fence.",
  "VkFenceCreateInfo.flags": "flags defines the initial state and behavior of the fence. Bits which can be set include: + --",
  "VkFenceCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkFenceCreateInfo.sType": "The type of this structure.",
  "VkFenceGetFdInfoKHR": "",
  "VkFenceGetFdInfoKHR.fence": "",
  "VkFenceGetFdInfoKHR.handleType": "",
  "VkFenceGetFdInfoKHR.pNext": "",
  "VkFenceGetFdInfoKHR.sType": "",
  "VkFenceGetWin32HandleInfoKHR": "",
  "VkFenceGetWin32HandleInfoKHR.fence": "",
  "VkFenceGetWin32HandleInfoKHR.handleType": "",
  "VkFenceGetWin32HandleInfoKHR.pNext": "",
  "VkFenceGetWin32HandleInfoKHR.sType": "",
  "VkFenceImportFlagBitsKHR": "",
  "VkFenceImportFlagBitsKHR.__none": "",
  "VkFenceImportFlagBitsKHR.VK_FENCE_IMPORT_TEMPORARY_BIT_KHR": "",
  "VkFenceImportFlagsKHR": "",
  "VkFilter": "Specify filters used for texture lookups.",
  "VkFilter.VK_FILTER_CUBIC_IMG": "",
  "VkFilter.VK_FILTER_LINEAR": "",
  "VkFilter.VK_FILTER_NEAREST": "",
  "vkFlushMappedMemoryRanges": "Flush mapped memory ranges.",
  "vkFlushMappedMemoryRanges.device": "",
  "vkFlushMappedMemoryRanges.memoryRangeCount": "",
  "vkFlushMappedMemoryRanges.pMemoryRanges": "",
  "VkFormat": "Available image formats.",
  "VkFormat.VK_FORMAT_A1R5G5B5_UNORM_PACK16": "VK_FORMAT_A1R5G5B5_UNORM_PACK16:: A four-component, 16-bit packed unsigned normalized format that has a 1-bit A component in bit 15, a 5-bit R component in bits 10..14, a 5-bit G component in bits 5..9, and a 5-bit B component in bits 0..4.",
  "VkFormat.VK_FORMAT_A2B10G10R10_SINT_PACK32": "VK_FORMAT_A2B10G10R10_SINT_PACK32:: A four-component, 32-bit packed signed integer format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.",
  "VkFormat.VK_FORMAT_A2B10G10R10_SNORM_PACK32": "VK_FORMAT_A2B10G10R10_SNORM_PACK32:: A four-component, 32-bit packed signed normalized format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.",
  "VkFormat.VK_FORMAT_A2B10G10R10_SSCALED_PACK32": "VK_FORMAT_A2B10G10R10_SSCALED_PACK32:: A four-component, 32-bit packed signed scaled integer format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.",
  "VkFormat.VK_FORMAT_A2B10G10R10_UINT_PACK32": "VK_FORMAT_A2B10G10R10_UINT_PACK32:: A four-component, 32-bit packed unsigned integer format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.",
  "VkFormat.VK_FORMAT_A2B10G10R10_UNORM_PACK32": "VK_FORMAT_A2B10G10R10_UNORM_PACK32:: A four-component, 32-bit packed unsigned normalized format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.",
  "VkFormat.VK_FORMAT_A2B10G10R10_USCALED_PACK32": "VK_FORMAT_A2B10G10R10_USCALED_PACK32:: A four-component, 32-bit packed unsigned scaled integer format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.",
  "VkFormat.VK_FORMAT_A2R10G10B10_SINT_PACK32": "VK_FORMAT_A2R10G10B10_SINT_PACK32:: A four-component, 32-bit packed signed integer format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.",
  "VkFormat.VK_FORMAT_A2R10G10B10_SNORM_PACK32": "VK_FORMAT_A2R10G10B10_SNORM_PACK32:: A four-component, 32-bit packed signed normalized format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.",
  "VkFormat.VK_FORMAT_A2R10G10B10_SSCALED_PACK32": "VK_FORMAT_A2R10G10B10_SSCALED_PACK32:: A four-component, 32-bit packed signed scaled integer format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.",
  "VkFormat.VK_FORMAT_A2R10G10B10_UINT_PACK32": "VK_FORMAT_A2R10G10B10_UINT_PACK32:: A four-component, 32-bit packed unsigned integer format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.",
  "VkFormat.VK_FORMAT_A2R10G10B10_UNORM_PACK32": "VK_FORMAT_A2R10G10B10_UNORM_PACK32:: A four-component, 32-bit packed unsigned normalized format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.",
  "VkFormat.VK_FORMAT_A2R10G10B10_USCALED_PACK32": "VK_FORMAT_A2R10G10B10_USCALED_PACK32:: A four-component, 32-bit packed unsigned scaled integer format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.",
  "VkFormat.VK_FORMAT_A8B8G8R8_SINT_PACK32": "VK_FORMAT_A8B8G8R8_SINT_PACK32:: A four-component, 32-bit packed signed integer format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.",
  "VkFormat.VK_FORMAT_A8B8G8R8_SNORM_PACK32": "VK_FORMAT_A8B8G8R8_SNORM_PACK32:: A four-component, 32-bit packed signed normalized format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.",
  "VkFormat.VK_FORMAT_A8B8G8R8_SRGB_PACK32": "VK_FORMAT_A8B8G8R8_SRGB_PACK32:: A four-component, 32-bit packed unsigned normalized format that has an 8-bit A component in bits 24..31, an 8-bit B component stored with sRGB nonlinear encoding in bits 16..23, an 8-bit G component stored with sRGB nonlinear encoding in bits 8..15, and an 8-bit R component stored with sRGB nonlinear encoding in bits 0..7.",
  "VkFormat.VK_FORMAT_A8B8G8R8_SSCALED_PACK32": "VK_FORMAT_A8B8G8R8_SSCALED_PACK32:: A four-component, 32-bit packed signed scaled integer format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.",
  "VkFormat.VK_FORMAT_A8B8G8R8_UINT_PACK32": "VK_FORMAT_A8B8G8R8_UINT_PACK32:: A four-component, 32-bit packed unsigned integer format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.",
  "VkFormat.VK_FORMAT_A8B8G8R8_UNORM_PACK32": "VK_FORMAT_A8B8G8R8_UNORM_PACK32:: A four-component, 32-bit packed unsigned normalized format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.",
  "VkFormat.VK_FORMAT_A8B8G8R8_USCALED_PACK32": "VK_FORMAT_A8B8G8R8_USCALED_PACK32:: A four-component, 32-bit packed unsigned scaled integer format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.",
  "VkFormat.VK_FORMAT_ASTC_10x10_SRGB_BLOCK": "VK_FORMAT_ASTC_10x10_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x10 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_10x10_UNORM_BLOCK": "VK_FORMAT_ASTC_10x10_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x10 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_10x5_SRGB_BLOCK": "VK_FORMAT_ASTC_10x5_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x5 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_10x5_UNORM_BLOCK": "VK_FORMAT_ASTC_10x5_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x5 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_10x6_SRGB_BLOCK": "VK_FORMAT_ASTC_10x6_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x6 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_10x6_UNORM_BLOCK": "VK_FORMAT_ASTC_10x6_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x6 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_10x8_SRGB_BLOCK": "VK_FORMAT_ASTC_10x8_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x8 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_10x8_UNORM_BLOCK": "VK_FORMAT_ASTC_10x8_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x8 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_12x10_SRGB_BLOCK": "VK_FORMAT_ASTC_12x10_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 12x10 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_12x10_UNORM_BLOCK": "VK_FORMAT_ASTC_12x10_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 12x10 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_12x12_SRGB_BLOCK": "VK_FORMAT_ASTC_12x12_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 12x12 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_12x12_UNORM_BLOCK": "VK_FORMAT_ASTC_12x12_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 12x12 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_4x4_SRGB_BLOCK": "VK_FORMAT_ASTC_4x4_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_4x4_UNORM_BLOCK": "VK_FORMAT_ASTC_4x4_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_5x4_SRGB_BLOCK": "VK_FORMAT_ASTC_5x4_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 5x4 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_5x4_UNORM_BLOCK": "VK_FORMAT_ASTC_5x4_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 5x4 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_5x5_SRGB_BLOCK": "VK_FORMAT_ASTC_5x5_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 5x5 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_5x5_UNORM_BLOCK": "VK_FORMAT_ASTC_5x5_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 5x5 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_6x5_SRGB_BLOCK": "VK_FORMAT_ASTC_6x5_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 6x5 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_6x5_UNORM_BLOCK": "VK_FORMAT_ASTC_6x5_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 6x5 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_6x6_SRGB_BLOCK": "VK_FORMAT_ASTC_6x6_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 6x6 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_6x6_UNORM_BLOCK": "VK_FORMAT_ASTC_6x6_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 6x6 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_8x5_SRGB_BLOCK": "VK_FORMAT_ASTC_8x5_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8x5 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_8x5_UNORM_BLOCK": "VK_FORMAT_ASTC_8x5_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8x5 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_8x6_SRGB_BLOCK": "VK_FORMAT_ASTC_8x6_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8x6 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_8x6_UNORM_BLOCK": "VK_FORMAT_ASTC_8x6_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8x6 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_8x8_SRGB_BLOCK": "VK_FORMAT_ASTC_8x8_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8x8 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_8x8_UNORM_BLOCK": "VK_FORMAT_ASTC_8x8_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8x8 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_B10G11R11_UFLOAT_PACK32": "VK_FORMAT_B10G11R11_UFLOAT_PACK32:: A three-component, 32-bit packed unsigned floating-point format that has a 10-bit B component in bits 22..31, an 11-bit G component in bits 11..21, an 11-bit R component in bits 0..10. See <<fundamentals-fp10 and <<fundamentals-fp11.",
  "VkFormat.VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR": "",
  "VkFormat.VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR": "",
  "VkFormat.VK_FORMAT_B16G16R16G16_422_UNORM_KHR": "",
  "VkFormat.VK_FORMAT_B4G4R4A4_UNORM_PACK16": "VK_FORMAT_B4G4R4A4_UNORM_PACK16:: A four-component, 16-bit packed unsigned normalized format that has a 4-bit B component in bits 12..15, a 4-bit G component in bits 8..11, a 4-bit R component in bits 4..7, and a 4-bit A component in bits 0..3.",
  "VkFormat.VK_FORMAT_B5G5R5A1_UNORM_PACK16": "VK_FORMAT_B5G5R5A1_UNORM_PACK16:: A four-component, 16-bit packed unsigned normalized format that has a 5-bit B component in bits 11..15, a 5-bit G component in bits 6..10, a 5-bit R component in bits 1..5, and a 1-bit A component in bit 0.",
  "VkFormat.VK_FORMAT_B5G6R5_UNORM_PACK16": "VK_FORMAT_B5G6R5_UNORM_PACK16:: A three-component, 16-bit packed unsigned normalized format that has a 5-bit B component in bits 11..15, a 6-bit G component in bits 5..10, and a 5-bit R component in bits 0..4.",
  "VkFormat.VK_FORMAT_B8G8R8_SINT": "VK_FORMAT_B8G8R8_SINT:: A three-component, 24-bit signed integer format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.",
  "VkFormat.VK_FORMAT_B8G8R8_SNORM": "VK_FORMAT_B8G8R8_SNORM:: A three-component, 24-bit signed normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.",
  "VkFormat.VK_FORMAT_B8G8R8_SRGB": "VK_FORMAT_B8G8R8_SRGB:: A three-component, 24-bit unsigned normalized format that has an 8-bit B component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, and an 8-bit R component stored with sRGB nonlinear encoding in byte 2.",
  "VkFormat.VK_FORMAT_B8G8R8_SSCALED": "VK_FORMAT_B8G8R8_SSCALED:: A three-component, 24-bit signed scaled format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.",
  "VkFormat.VK_FORMAT_B8G8R8_UINT": "VK_FORMAT_B8G8R8_UINT:: A three-component, 24-bit unsigned integer format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.",
  "VkFormat.VK_FORMAT_B8G8R8_UNORM": "VK_FORMAT_B8G8R8_UNORM:: A three-component, 24-bit unsigned normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.",
  "VkFormat.VK_FORMAT_B8G8R8_USCALED": "VK_FORMAT_B8G8R8_USCALED:: A three-component, 24-bit unsigned scaled format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.",
  "VkFormat.VK_FORMAT_B8G8R8A8_SINT": "VK_FORMAT_B8G8R8A8_SINT:: A four-component, 32-bit signed integer format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_B8G8R8A8_SNORM": "VK_FORMAT_B8G8R8A8_SNORM:: A four-component, 32-bit signed normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_B8G8R8A8_SRGB": "VK_FORMAT_B8G8R8A8_SRGB:: A four-component, 32-bit unsigned normalized format that has an 8-bit B component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, an 8-bit R component stored with sRGB nonlinear encoding in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_B8G8R8A8_SSCALED": "VK_FORMAT_B8G8R8A8_SSCALED:: A four-component, 32-bit signed scaled format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_B8G8R8A8_UINT": "VK_FORMAT_B8G8R8A8_UINT:: A four-component, 32-bit unsigned integer format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_B8G8R8A8_UNORM": "VK_FORMAT_B8G8R8A8_UNORM:: A four-component, 32-bit unsigned normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_B8G8R8A8_USCALED": "VK_FORMAT_B8G8R8A8_USCALED:: A four-component, 32-bit unsigned scaled format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_B8G8R8G8_422_UNORM_KHR": "",
  "VkFormat.VK_FORMAT_BC1_RGB_SRGB_BLOCK": "VK_FORMAT_BC1_RGB_SRGB_BLOCK:: A three-component, block-compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data with sRGB nonlinear encoding. This format has no alpha and is considered opaque.",
  "VkFormat.VK_FORMAT_BC1_RGB_UNORM_BLOCK": "VK_FORMAT_BC1_RGB_UNORM_BLOCK:: A three-component, block-compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data. This format has no alpha and is considered opaque.",
  "VkFormat.VK_FORMAT_BC1_RGBA_SRGB_BLOCK": "VK_FORMAT_BC1_RGBA_SRGB_BLOCK:: A four-component, block-compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data with sRGB nonlinear encoding, and provides 1 bit of alpha.",
  "VkFormat.VK_FORMAT_BC1_RGBA_UNORM_BLOCK": "VK_FORMAT_BC1_RGBA_UNORM_BLOCK:: A four-component, block-compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data, and provides 1 bit of alpha.",
  "VkFormat.VK_FORMAT_BC2_SRGB_BLOCK": "VK_FORMAT_BC2_SRGB_BLOCK:: A four-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values with sRGB nonlinear encoding.",
  "VkFormat.VK_FORMAT_BC2_UNORM_BLOCK": "VK_FORMAT_BC2_UNORM_BLOCK:: A four-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values.",
  "VkFormat.VK_FORMAT_BC3_SRGB_BLOCK": "VK_FORMAT_BC3_SRGB_BLOCK:: A four-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values with sRGB nonlinear encoding.",
  "VkFormat.VK_FORMAT_BC3_UNORM_BLOCK": "VK_FORMAT_BC3_UNORM_BLOCK:: A four-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values.",
  "VkFormat.VK_FORMAT_BC4_SNORM_BLOCK": "VK_FORMAT_BC4_SNORM_BLOCK:: A one-component, block-compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of signed normalized red texel data.",
  "VkFormat.VK_FORMAT_BC4_UNORM_BLOCK": "VK_FORMAT_BC4_UNORM_BLOCK:: A one-component, block-compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized red texel data.",
  "VkFormat.VK_FORMAT_BC5_SNORM_BLOCK": "VK_FORMAT_BC5_SNORM_BLOCK:: A two-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of signed normalized RG texel data with the first 64 bits encoding red values followed by 64 bits encoding green values.",
  "VkFormat.VK_FORMAT_BC5_UNORM_BLOCK": "VK_FORMAT_BC5_UNORM_BLOCK:: A two-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RG texel data with the first 64 bits encoding red values followed by 64 bits encoding green values.",
  "VkFormat.VK_FORMAT_BC6H_SFLOAT_BLOCK": "VK_FORMAT_BC6H_SFLOAT_BLOCK:: A three-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of signed floating-point RGB texel data.",
  "VkFormat.VK_FORMAT_BC6H_UFLOAT_BLOCK": "VK_FORMAT_BC6H_UFLOAT_BLOCK:: A three-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned floating-point RGB texel data.",
  "VkFormat.VK_FORMAT_BC7_SRGB_BLOCK": "VK_FORMAT_BC7_SRGB_BLOCK:: A four-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_BC7_UNORM_BLOCK": "VK_FORMAT_BC7_UNORM_BLOCK:: A four-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_D16_UNORM": "VK_FORMAT_D16_UNORM:: A one-component, 16-bit unsigned normalized format that has a single 16-bit depth component.",
  "VkFormat.VK_FORMAT_D16_UNORM_S8_UINT": "VK_FORMAT_D16_UNORM_S8_UINT:: A two-component, 24-bit format that has 16 unsigned normalized bits in the depth component and 8 unsigned integer bits in the stencil component.",
  "VkFormat.VK_FORMAT_D24_UNORM_S8_UINT": "VK_FORMAT_D24_UNORM_S8_UINT:: A two-component, 32-bit packed format that has 8 unsigned integer bits in the stencil component, and 24 unsigned normalized bits in the depth component.",
  "VkFormat.VK_FORMAT_D32_SFLOAT": "VK_FORMAT_D32_SFLOAT:: A one-component, 32-bit signed floating-point format that has 32-bits in the depth component.",
  "VkFormat.VK_FORMAT_D32_SFLOAT_S8_UINT": "VK_FORMAT_D32_SFLOAT_S8_UINT:: A two-component format that has 32 signed float bits in the depth component and 8 unsigned integer bits in the stencil component. There are optionally: 24-bits that are unused.",
  "VkFormat.VK_FORMAT_E5B9G9R9_UFLOAT_PACK32": "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32:: A three-component, 32-bit packed unsigned floating-point format that has a 5-bit shared exponent in bits 27..31, a 9-bit B component mantissa in bits 18..26, a 9-bit G component mantissa in bits 9..17, and a 9-bit R component mantissa in bits 0..8.",
  "VkFormat.VK_FORMAT_EAC_R11_SNORM_BLOCK": "VK_FORMAT_EAC_R11_SNORM_BLOCK:: A one-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of signed normalized red texel data.",
  "VkFormat.VK_FORMAT_EAC_R11_UNORM_BLOCK": "VK_FORMAT_EAC_R11_UNORM_BLOCK:: A one-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized red texel data.",
  "VkFormat.VK_FORMAT_EAC_R11G11_SNORM_BLOCK": "VK_FORMAT_EAC_R11G11_SNORM_BLOCK:: A two-component, ETC2 compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of signed normalized RG texel data with the first 64 bits encoding red values followed by 64 bits encoding green values.",
  "VkFormat.VK_FORMAT_EAC_R11G11_UNORM_BLOCK": "VK_FORMAT_EAC_R11G11_UNORM_BLOCK:: A two-component, ETC2 compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RG texel data with the first 64 bits encoding red values followed by 64 bits encoding green values.",
  "VkFormat.VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK": "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK:: A three-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data with sRGB nonlinear encoding. This format has no alpha and is considered opaque.",
  "VkFormat.VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK": "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK:: A three-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data. This format has no alpha and is considered opaque.",
  "VkFormat.VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK": "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK:: A four-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data with sRGB nonlinear encoding, and provides 1 bit of alpha.",
  "VkFormat.VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK": "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK:: A four-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data, and provides 1 bit of alpha.",
  "VkFormat.VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK": "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK:: A four-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values with sRGB nonlinear encoding applied.",
  "VkFormat.VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK": "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK:: A four-component, ETC2 compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values.",
  "VkFormat.VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR": "",
  "VkFormat.VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR": "",
  "VkFormat.VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR": "",
  "VkFormat.VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR": "",
  "VkFormat.VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR": "",
  "VkFormat.VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR": "",
  "VkFormat.VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR": "",
  "VkFormat.VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR": "",
  "VkFormat.VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR": "",
  "VkFormat.VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR": "",
  "VkFormat.VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR": "",
  "VkFormat.VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR": "",
  "VkFormat.VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR": "",
  "VkFormat.VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR": "",
  "VkFormat.VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR": "",
  "VkFormat.VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR": "",
  "VkFormat.VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR": "",
  "VkFormat.VK_FORMAT_G16B16G16R16_422_UNORM_KHR": "",
  "VkFormat.VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR": "",
  "VkFormat.VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR": "",
  "VkFormat.VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR": "",
  "VkFormat.VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR": "",
  "VkFormat.VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR": "",
  "VkFormat.VK_FORMAT_G8B8G8R8_422_UNORM_KHR": "",
  "VkFormat.VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG": "",
  "VkFormat.VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG": "",
  "VkFormat.VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG": "",
  "VkFormat.VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG": "",
  "VkFormat.VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG": "",
  "VkFormat.VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG": "",
  "VkFormat.VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG": "",
  "VkFormat.VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG": "",
  "VkFormat.VK_FORMAT_R10X6_UNORM_PACK16_KHR": "",
  "VkFormat.VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR": "",
  "VkFormat.VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR": "",
  "VkFormat.VK_FORMAT_R12X4_UNORM_PACK16_KHR": "",
  "VkFormat.VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR": "",
  "VkFormat.VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR": "",
  "VkFormat.VK_FORMAT_R16_SFLOAT": "VK_FORMAT_R16_SFLOAT:: A one-component, 16-bit signed floating-point format that has a single 16-bit R component.",
  "VkFormat.VK_FORMAT_R16_SINT": "VK_FORMAT_R16_SINT:: A one-component, 16-bit signed integer format that has a single 16-bit R component.",
  "VkFormat.VK_FORMAT_R16_SNORM": "VK_FORMAT_R16_SNORM:: A one-component, 16-bit signed normalized format that has a single 16-bit R component.",
  "VkFormat.VK_FORMAT_R16_SSCALED": "VK_FORMAT_R16_SSCALED:: A one-component, 16-bit signed scaled integer format that has a single 16-bit R component.",
  "VkFormat.VK_FORMAT_R16_UINT": "VK_FORMAT_R16_UINT:: A one-component, 16-bit unsigned integer format that has a single 16-bit R component.",
  "VkFormat.VK_FORMAT_R16_UNORM": "VK_FORMAT_R16_UNORM:: A one-component, 16-bit unsigned normalized format that has a single 16-bit R component.",
  "VkFormat.VK_FORMAT_R16_USCALED": "VK_FORMAT_R16_USCALED:: A one-component, 16-bit unsigned scaled integer format that has a single 16-bit R component.",
  "VkFormat.VK_FORMAT_R16G16_SFLOAT": "VK_FORMAT_R16G16_SFLOAT:: A two-component, 32-bit signed floating-point format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.",
  "VkFormat.VK_FORMAT_R16G16_SINT": "VK_FORMAT_R16G16_SINT:: A two-component, 32-bit signed integer format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.",
  "VkFormat.VK_FORMAT_R16G16_SNORM": "VK_FORMAT_R16G16_SNORM:: A two-component, 32-bit signed normalized format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.",
  "VkFormat.VK_FORMAT_R16G16_SSCALED": "VK_FORMAT_R16G16_SSCALED:: A two-component, 32-bit signed scaled integer format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.",
  "VkFormat.VK_FORMAT_R16G16_UINT": "VK_FORMAT_R16G16_UINT:: A two-component, 32-bit unsigned integer format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.",
  "VkFormat.VK_FORMAT_R16G16_UNORM": "VK_FORMAT_R16G16_UNORM:: A two-component, 32-bit unsigned normalized format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.",
  "VkFormat.VK_FORMAT_R16G16_USCALED": "VK_FORMAT_R16G16_USCALED:: A two-component, 32-bit unsigned scaled integer format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.",
  "VkFormat.VK_FORMAT_R16G16B16_SFLOAT": "VK_FORMAT_R16G16B16_SFLOAT:: A three-component, 48-bit signed floating-point format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.",
  "VkFormat.VK_FORMAT_R16G16B16_SINT": "VK_FORMAT_R16G16B16_SINT:: A three-component, 48-bit signed integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.",
  "VkFormat.VK_FORMAT_R16G16B16_SNORM": "VK_FORMAT_R16G16B16_SNORM:: A three-component, 48-bit signed normalized format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.",
  "VkFormat.VK_FORMAT_R16G16B16_SSCALED": "VK_FORMAT_R16G16B16_SSCALED:: A three-component, 48-bit signed scaled integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.",
  "VkFormat.VK_FORMAT_R16G16B16_UINT": "VK_FORMAT_R16G16B16_UINT:: A three-component, 48-bit unsigned integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.",
  "VkFormat.VK_FORMAT_R16G16B16_UNORM": "VK_FORMAT_R16G16B16_UNORM:: A three-component, 48-bit unsigned normalized format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.",
  "VkFormat.VK_FORMAT_R16G16B16_USCALED": "VK_FORMAT_R16G16B16_USCALED:: A three-component, 48-bit unsigned scaled integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.",
  "VkFormat.VK_FORMAT_R16G16B16A16_SFLOAT": "VK_FORMAT_R16G16B16A16_SFLOAT:: A four-component, 64-bit signed floating-point format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.",
  "VkFormat.VK_FORMAT_R16G16B16A16_SINT": "VK_FORMAT_R16G16B16A16_SINT:: A four-component, 64-bit signed integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.",
  "VkFormat.VK_FORMAT_R16G16B16A16_SNORM": "VK_FORMAT_R16G16B16A16_SNORM:: A four-component, 64-bit signed normalized format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.",
  "VkFormat.VK_FORMAT_R16G16B16A16_SSCALED": "VK_FORMAT_R16G16B16A16_SSCALED:: A four-component, 64-bit signed scaled integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.",
  "VkFormat.VK_FORMAT_R16G16B16A16_UINT": "VK_FORMAT_R16G16B16A16_UINT:: A four-component, 64-bit unsigned integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.",
  "VkFormat.VK_FORMAT_R16G16B16A16_UNORM": "VK_FORMAT_R16G16B16A16_UNORM:: A four-component, 64-bit unsigned normalized format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.",
  "VkFormat.VK_FORMAT_R16G16B16A16_USCALED": "VK_FORMAT_R16G16B16A16_USCALED:: A four-component, 64-bit unsigned scaled integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.",
  "VkFormat.VK_FORMAT_R32_SFLOAT": "VK_FORMAT_R32_SFLOAT:: A one-component, 32-bit signed floating-point format that has a single 32-bit R component.",
  "VkFormat.VK_FORMAT_R32_SINT": "VK_FORMAT_R32_SINT:: A one-component, 32-bit signed integer format that has a single 32-bit R component.",
  "VkFormat.VK_FORMAT_R32_UINT": "VK_FORMAT_R32_UINT:: A one-component, 32-bit unsigned integer format that has a single 32-bit R component.",
  "VkFormat.VK_FORMAT_R32G32_SFLOAT": "VK_FORMAT_R32G32_SFLOAT:: A two-component, 64-bit signed floating-point format that has a 32-bit R component in bytes 0..3, and a 32-bit G component in bytes 4..7.",
  "VkFormat.VK_FORMAT_R32G32_SINT": "VK_FORMAT_R32G32_SINT:: A two-component, 64-bit signed integer format that has a 32-bit R component in bytes 0..3, and a 32-bit G component in bytes 4..7.",
  "VkFormat.VK_FORMAT_R32G32_UINT": "VK_FORMAT_R32G32_UINT:: A two-component, 64-bit unsigned integer format that has a 32-bit R component in bytes 0..3, and a 32-bit G component in bytes 4..7.",
  "VkFormat.VK_FORMAT_R32G32B32_SFLOAT": "VK_FORMAT_R32G32B32_SFLOAT:: A three-component, 96-bit signed floating-point format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, and a 32-bit B component in bytes 8..11.",
  "VkFormat.VK_FORMAT_R32G32B32_SINT": "VK_FORMAT_R32G32B32_SINT:: A three-component, 96-bit signed integer format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, and a 32-bit B component in bytes 8..11.",
  "VkFormat.VK_FORMAT_R32G32B32_UINT": "VK_FORMAT_R32G32B32_UINT:: A three-component, 96-bit unsigned integer format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, and a 32-bit B component in bytes 8..11.",
  "VkFormat.VK_FORMAT_R32G32B32A32_SFLOAT": "VK_FORMAT_R32G32B32A32_SFLOAT:: A four-component, 128-bit signed floating-point format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in bytes 8..11, and a 32-bit A component in bytes 12..15.",
  "VkFormat.VK_FORMAT_R32G32B32A32_SINT": "VK_FORMAT_R32G32B32A32_SINT:: A four-component, 128-bit signed integer format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in bytes 8..11, and a 32-bit A component in bytes 12..15.",
  "VkFormat.VK_FORMAT_R32G32B32A32_UINT": "VK_FORMAT_R32G32B32A32_UINT:: A four-component, 128-bit unsigned integer format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in bytes 8..11, and a 32-bit A component in bytes 12..15.",
  "VkFormat.VK_FORMAT_R4G4_UNORM_PACK8": "VK_FORMAT_R4G4_UNORM_PACK8:: A two-component, 8-bit packed unsigned normalized format that has a 4-bit R component in bits 4..7, and a 4-bit G component in bits 0..3.",
  "VkFormat.VK_FORMAT_R4G4B4A4_UNORM_PACK16": "VK_FORMAT_R4G4B4A4_UNORM_PACK16:: A four-component, 16-bit packed unsigned normalized format that has a 4-bit R component in bits 12..15, a 4-bit G component in bits 8..11, a 4-bit B component in bits 4..7, and a 4-bit A component in bits 0..3.",
  "VkFormat.VK_FORMAT_R5G5B5A1_UNORM_PACK16": "VK_FORMAT_R5G5B5A1_UNORM_PACK16:: A four-component, 16-bit packed unsigned normalized format that has a 5-bit R component in bits 11..15, a 5-bit G component in bits 6..10, a 5-bit B component in bits 1..5, and a 1-bit A component in bit 0.",
  "VkFormat.VK_FORMAT_R5G6B5_UNORM_PACK16": "VK_FORMAT_R5G6B5_UNORM_PACK16:: A three-component, 16-bit packed unsigned normalized format that has a 5-bit R component in bits 11..15, a 6-bit G component in bits 5..10, and a 5-bit B component in bits 0..4.",
  "VkFormat.VK_FORMAT_R64_SFLOAT": "VK_FORMAT_R64_SFLOAT:: A one-component, 64-bit signed floating-point format that has a single 64-bit R component.",
  "VkFormat.VK_FORMAT_R64_SINT": "VK_FORMAT_R64_SINT:: A one-component, 64-bit signed integer format that has a single 64-bit R component.",
  "VkFormat.VK_FORMAT_R64_UINT": "VK_FORMAT_R64_UINT:: A one-component, 64-bit unsigned integer format that has a single 64-bit R component.",
  "VkFormat.VK_FORMAT_R64G64_SFLOAT": "VK_FORMAT_R64G64_SFLOAT:: A two-component, 128-bit signed floating-point format that has a 64-bit R component in bytes 0..7, and a 64-bit G component in bytes 8..15.",
  "VkFormat.VK_FORMAT_R64G64_SINT": "VK_FORMAT_R64G64_SINT:: A two-component, 128-bit signed integer format that has a 64-bit R component in bytes 0..7, and a 64-bit G component in bytes 8..15.",
  "VkFormat.VK_FORMAT_R64G64_UINT": "VK_FORMAT_R64G64_UINT:: A two-component, 128-bit unsigned integer format that has a 64-bit R component in bytes 0..7, and a 64-bit G component in bytes 8..15.",
  "VkFormat.VK_FORMAT_R64G64B64_SFLOAT": "VK_FORMAT_R64G64B64_SFLOAT:: A three-component, 192-bit signed floating-point format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, and a 64-bit B component in bytes 16..23.",
  "VkFormat.VK_FORMAT_R64G64B64_SINT": "VK_FORMAT_R64G64B64_SINT:: A three-component, 192-bit signed integer format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, and a 64-bit B component in bytes 16..23.",
  "VkFormat.VK_FORMAT_R64G64B64_UINT": "VK_FORMAT_R64G64B64_UINT:: A three-component, 192-bit unsigned integer format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, and a 64-bit B component in bytes 16..23.",
  "VkFormat.VK_FORMAT_R64G64B64A64_SFLOAT": "VK_FORMAT_R64G64B64A64_SFLOAT:: A four-component, 256-bit signed floating-point format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in bytes 16..23, and a 64-bit A component in bytes 24..31.",
  "VkFormat.VK_FORMAT_R64G64B64A64_SINT": "VK_FORMAT_R64G64B64A64_SINT:: A four-component, 256-bit signed integer format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in bytes 16..23, and a 64-bit A component in bytes 24..31.",
  "VkFormat.VK_FORMAT_R64G64B64A64_UINT": "VK_FORMAT_R64G64B64A64_UINT:: A four-component, 256-bit unsigned integer format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in bytes 16..23, and a 64-bit A component in bytes 24..31.",
  "VkFormat.VK_FORMAT_R8_SINT": "VK_FORMAT_R8_SINT:: A one-component, 8-bit signed integer format that has a single 8-bit R component.",
  "VkFormat.VK_FORMAT_R8_SNORM": "VK_FORMAT_R8_SNORM:: A one-component, 8-bit signed normalized format that has a single 8-bit R component.",
  "VkFormat.VK_FORMAT_R8_SRGB": "VK_FORMAT_R8_SRGB:: A one-component, 8-bit unsigned normalized format that has a single 8-bit R component stored with sRGB nonlinear encoding.",
  "VkFormat.VK_FORMAT_R8_SSCALED": "VK_FORMAT_R8_SSCALED:: A one-component, 8-bit signed scaled integer format that has a single 8-bit R component.",
  "VkFormat.VK_FORMAT_R8_UINT": "VK_FORMAT_R8_UINT:: A one-component, 8-bit unsigned integer format that has a single 8-bit R component.",
  "VkFormat.VK_FORMAT_R8_UNORM": "VK_FORMAT_R8_UNORM:: A one-component, 8-bit unsigned normalized format that has a single 8-bit R component.",
  "VkFormat.VK_FORMAT_R8_USCALED": "VK_FORMAT_R8_USCALED:: A one-component, 8-bit unsigned scaled integer format that has a single 8-bit R component.",
  "VkFormat.VK_FORMAT_R8G8_SINT": "VK_FORMAT_R8G8_SINT:: A two-component, 16-bit signed integer format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.",
  "VkFormat.VK_FORMAT_R8G8_SNORM": "VK_FORMAT_R8G8_SNORM:: A two-component, 16-bit signed normalized format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.",
  "VkFormat.VK_FORMAT_R8G8_SRGB": "VK_FORMAT_R8G8_SRGB:: A two-component, 16-bit unsigned normalized format that has an 8-bit R component stored with sRGB nonlinear encoding in byte 0, and an 8-bit G component stored with sRGB nonlinear encoding in byte 1.",
  "VkFormat.VK_FORMAT_R8G8_SSCALED": "VK_FORMAT_R8G8_SSCALED:: A two-component, 16-bit signed scaled integer format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.",
  "VkFormat.VK_FORMAT_R8G8_UINT": "VK_FORMAT_R8G8_UINT:: A two-component, 16-bit unsigned integer format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.",
  "VkFormat.VK_FORMAT_R8G8_UNORM": "VK_FORMAT_R8G8_UNORM:: A two-component, 16-bit unsigned normalized format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.",
  "VkFormat.VK_FORMAT_R8G8_USCALED": "VK_FORMAT_R8G8_USCALED:: A two-component, 16-bit unsigned scaled integer format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.",
  "VkFormat.VK_FORMAT_R8G8B8_SINT": "VK_FORMAT_R8G8B8_SINT:: A three-component, 24-bit signed integer format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.",
  "VkFormat.VK_FORMAT_R8G8B8_SNORM": "VK_FORMAT_R8G8B8_SNORM:: A three-component, 24-bit signed normalized format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.",
  "VkFormat.VK_FORMAT_R8G8B8_SRGB": "VK_FORMAT_R8G8B8_SRGB:: A three-component, 24-bit unsigned normalized format that has an 8-bit R component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, and an 8-bit B component stored with sRGB nonlinear encoding in byte 2.",
  "VkFormat.VK_FORMAT_R8G8B8_SSCALED": "VK_FORMAT_R8G8B8_SSCALED:: A three-component, 24-bit signed scaled format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.",
  "VkFormat.VK_FORMAT_R8G8B8_UINT": "VK_FORMAT_R8G8B8_UINT:: A three-component, 24-bit unsigned integer format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.",
  "VkFormat.VK_FORMAT_R8G8B8_UNORM": "VK_FORMAT_R8G8B8_UNORM:: A three-component, 24-bit unsigned normalized format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.",
  "VkFormat.VK_FORMAT_R8G8B8_USCALED": "VK_FORMAT_R8G8B8_USCALED:: A three-component, 24-bit unsigned scaled format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.",
  "VkFormat.VK_FORMAT_R8G8B8A8_SINT": "VK_FORMAT_R8G8B8A8_SINT:: A four-component, 32-bit signed integer format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_R8G8B8A8_SNORM": "VK_FORMAT_R8G8B8A8_SNORM:: A four-component, 32-bit signed normalized format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_R8G8B8A8_SRGB": "VK_FORMAT_R8G8B8A8_SRGB:: A four-component, 32-bit unsigned normalized format that has an 8-bit R component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, an 8-bit B component stored with sRGB nonlinear encoding in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_R8G8B8A8_SSCALED": "VK_FORMAT_R8G8B8A8_SSCALED:: A four-component, 32-bit signed scaled format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_R8G8B8A8_UINT": "VK_FORMAT_R8G8B8A8_UINT:: A four-component, 32-bit unsigned integer format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_R8G8B8A8_UNORM": "VK_FORMAT_R8G8B8A8_UNORM:: A four-component, 32-bit unsigned normalized format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_R8G8B8A8_USCALED": "VK_FORMAT_R8G8B8A8_USCALED:: A four-component, 32-bit unsigned scaled format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_S8_UINT": "VK_FORMAT_S8_UINT:: A one-component, 8-bit unsigned integer format that has 8-bits in the stencil component.",
  "VkFormat.VK_FORMAT_UNDEFINED": "VK_FORMAT_UNDEFINED:: The format is not specified.",
  "VkFormat.VK_FORMAT_X8_D24_UNORM_PACK32": "VK_FORMAT_X8_D24_UNORM_PACK32:: A two-component, 32-bit format that has 24 unsigned normalized bits in the depth component and, optionally:, 8 bits that are unused.",
  "VkFormatFeatureFlagBits": "Bitmask specifying features supported by a buffer.",
  "VkFormatFeatureFlagBits.__none": "",
  "VkFormatFeatureFlagBits.VK_FORMAT_FEATURE_BLIT_DST_BIT": "",
  "VkFormatFeatureFlagBits.VK_FORMAT_FEATURE_BLIT_SRC_BIT": "",
  "VkFormatFeatureFlagBits.VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT": "",
  "VkFormatFeatureFlagBits.VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT": "",
  "VkFormatFeatureFlagBits.VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR": "",
  "VkFormatFeatureFlagBits.VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT": "",
  "VkFormatFeatureFlagBits.VK_FORMAT_FEATURE_DISJOINT_BIT_KHR": "",
  "VkFormatFeatureFlagBits.VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR": "",
  "VkFormatFeatureFlagBits.VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT": "",
  "VkFormatFeatureFlagBits.VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG": "",
  "VkFormatFeatureFlagBits.VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT": "",
  "VkFormatFeatureFlagBits.VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT": "",
  "VkFormatFeatureFlagBits.VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR": "",
  "VkFormatFeatureFlagBits.VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR": "",
  "VkFormatFeatureFlagBits.VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR": "",
  "VkFormatFeatureFlagBits.VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR": "",
  "VkFormatFeatureFlagBits.VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT": "",
  "VkFormatFeatureFlagBits.VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT": "",
  "VkFormatFeatureFlagBits.VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT": "",
  "VkFormatFeatureFlagBits.VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT": "",
  "VkFormatFeatureFlagBits.VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR": "",
  "VkFormatFeatureFlagBits.VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR": "",
  "VkFormatFeatureFlagBits.VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT": "",
  "VkFormatFeatureFlagBits.VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT": "",
  "VkFormatFeatureFlags": "",
  "VkFormatProperties": "Structure specifying image format properties.",
  "VkFormatProperties.bufferFeatures": "bufferFeatures describes the features supported by buffers.",
  "VkFormatProperties.linearTilingFeatures": "linearTilingFeatures describes the features supported by VK_IMAGE_TILING_LINEAR.",
  "VkFormatProperties.optimalTilingFeatures": "optimalTilingFeatures describes the features supported by VK_IMAGE_TILING_OPTIMAL.",
  "VkFormatProperties2KHR": "Structure specifying image format properties.",
  "VkFormatProperties2KHR.formatProperties": "A structure of type FormatProperties describing features supported by the requested format.",
  "VkFormatProperties2KHR.pNext": "Null or an extension-specific structure.",
  "VkFormatProperties2KHR.sType": "The type of this structure.",
  "VkFramebuffer": "Opaque handle to a framebuffer object.",
  "VkFramebufferCreateFlagBits": "",
  "VkFramebufferCreateFlags": "",
  "VkFramebufferCreateFlags.__none": "",
  "VkFramebufferCreateInfo": "Structure specifying parameters of a newly created framebuffer.",
  "VkFramebufferCreateInfo.attachmentCount": "The number of attachments.",
  "VkFramebufferCreateInfo.flags": "Reserved for future use.",
  "VkFramebufferCreateInfo.height": "",
  "VkFramebufferCreateInfo.layers": "",
  "VkFramebufferCreateInfo.pAttachments": "An array of ImageView handles, each of which will be used as the corresponding attachment in a render pass instance.",
  "VkFramebufferCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkFramebufferCreateInfo.renderPass": "A render pass that defines what render passes the framebuffer will be compatible with. See Render Pass Compatibility for details.",
  "VkFramebufferCreateInfo.sType": "The type of this structure.",
  "VkFramebufferCreateInfo.width": "width, height and layers define the dimensions of the framebuffer. If the render pass uses multiview, then layers must be one and each attachment requires a number of layers that is greater than the maximum bit index set in the view mask in the subpasses in which it is used.",
  "vkFreeCommandBuffers": "Free command buffers.",
  "vkFreeCommandBuffers.commandBufferCount": "",
  "vkFreeCommandBuffers.commandPool": "",
  "vkFreeCommandBuffers.device": "",
  "vkFreeCommandBuffers.pCommandBuffers": "",
  "vkFreeDescriptorSets": "Free one or more descriptor sets.",
  "vkFreeDescriptorSets.descriptorPool": "",
  "vkFreeDescriptorSets.descriptorSetCount": "",
  "vkFreeDescriptorSets.device": "",
  "vkFreeDescriptorSets.pDescriptorSets": "",
  "vkFreeMemory": "Free GPU memory.",
  "vkFreeMemory.device": "",
  "vkFreeMemory.memory": "",
  "vkFreeMemory.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "VkFrontFace": "Interpret polygon front-facing orientation.",
  "VkFrontFace.VK_FRONT_FACE_CLOCKWISE": "",
  "VkFrontFace.VK_FRONT_FACE_COUNTER_CLOCKWISE": "",
  "vkGetBufferMemoryRequirements": "Returns the memory requirements for specified Vulkan object.",
  "vkGetBufferMemoryRequirements.buffer": "",
  "vkGetBufferMemoryRequirements.device": "",
  "vkGetBufferMemoryRequirements.pMemoryRequirements": "",
  "vkGetBufferMemoryRequirements2KHR": "",
  "vkGetBufferMemoryRequirements2KHR.device": "",
  "vkGetBufferMemoryRequirements2KHR.pInfo": "",
  "vkGetBufferMemoryRequirements2KHR.pMemoryRequirements": "",
  "vkGetDeviceGroupPeerMemoryFeaturesKHX": "Query supported peer memory features of a device.",
  "vkGetDeviceGroupPeerMemoryFeaturesKHX.device": "",
  "vkGetDeviceGroupPeerMemoryFeaturesKHX.heapIndex": "",
  "vkGetDeviceGroupPeerMemoryFeaturesKHX.localDeviceIndex": "",
  "vkGetDeviceGroupPeerMemoryFeaturesKHX.pPeerMemoryFeatures": "",
  "vkGetDeviceGroupPeerMemoryFeaturesKHX.remoteDeviceIndex": "",
  "vkGetDeviceGroupPresentCapabilitiesKHX": "Query present capabilities from other physical devices.",
  "vkGetDeviceGroupPresentCapabilitiesKHX.device": "",
  "vkGetDeviceGroupPresentCapabilitiesKHX.pDeviceGroupPresentCapabilities": "",
  "vkGetDeviceGroupSurfacePresentModesKHX": "Query present capabilities for a surface.",
  "vkGetDeviceGroupSurfacePresentModesKHX.device": "",
  "vkGetDeviceGroupSurfacePresentModesKHX.pModes": "",
  "vkGetDeviceGroupSurfacePresentModesKHX.surface": "",
  "vkGetDeviceMemoryCommitment": "Query the current commitment for a DeviceMemory.",
  "vkGetDeviceMemoryCommitment.device": "",
  "vkGetDeviceMemoryCommitment.memory": "",
  "vkGetDeviceMemoryCommitment.pCommittedMemoryInBytes": "",
  "vkGetDeviceProcAddr": "Return a function pointer for a command.",
  "vkGetDeviceProcAddr.device": "",
  "vkGetDeviceProcAddr.pName": "",
  "vkGetDeviceQueue": "Get a queue handle from a device.",
  "vkGetDeviceQueue.device": "",
  "vkGetDeviceQueue.pQueue": "",
  "vkGetDeviceQueue.queueFamilyIndex": "",
  "vkGetDeviceQueue.queueIndex": "",
  "vkGetDisplayModePropertiesKHR": "Query the set of mode properties supported by the display.",
  "vkGetDisplayModePropertiesKHR.display": "",
  "vkGetDisplayModePropertiesKHR.physicalDevice": "",
  "vkGetDisplayModePropertiesKHR.pProperties": "",
  "vkGetDisplayModePropertiesKHR.pPropertyCount": "",
  "vkGetDisplayPlaneCapabilitiesKHR": "Query capabilities of a mode and plane combination.",
  "vkGetDisplayPlaneCapabilitiesKHR.mode": "",
  "vkGetDisplayPlaneCapabilitiesKHR.pCapabilities": "",
  "vkGetDisplayPlaneCapabilitiesKHR.physicalDevice": "",
  "vkGetDisplayPlaneCapabilitiesKHR.planeIndex": "",
  "vkGetDisplayPlaneSupportedDisplaysKHR": "Query the list of displays a plane supports.",
  "vkGetDisplayPlaneSupportedDisplaysKHR.pDisplayCount": "",
  "vkGetDisplayPlaneSupportedDisplaysKHR.pDisplays": "",
  "vkGetDisplayPlaneSupportedDisplaysKHR.physicalDevice": "",
  "vkGetDisplayPlaneSupportedDisplaysKHR.planeIndex": "",
  "vkGetEventStatus": "Retrieve the status of an event object.",
  "vkGetEventStatus.device": "",
  "vkGetEventStatus.event": "",
  "vkGetFenceFdKHR": "",
  "vkGetFenceFdKHR.device": "",
  "vkGetFenceFdKHR.pFd": "",
  "vkGetFenceFdKHR.pGetFdInfo": "",
  "vkGetFenceStatus": "Return the status of a fence.",
  "vkGetFenceStatus.device": "",
  "vkGetFenceStatus.fence": "",
  "vkGetFenceWin32HandleKHR": "",
  "vkGetFenceWin32HandleKHR.device": "",
  "vkGetFenceWin32HandleKHR.pGetWin32HandleInfo": "",
  "vkGetFenceWin32HandleKHR.pHandle": "",
  "vkGetImageMemoryRequirements": "Returns the memory requirements for specified Vulkan object.",
  "vkGetImageMemoryRequirements.device": "",
  "vkGetImageMemoryRequirements.image": "",
  "vkGetImageMemoryRequirements.pMemoryRequirements": "",
  "vkGetImageMemoryRequirements2KHR": "",
  "vkGetImageMemoryRequirements2KHR.device": "",
  "vkGetImageMemoryRequirements2KHR.pInfo": "",
  "vkGetImageMemoryRequirements2KHR.pMemoryRequirements": "",
  "vkGetImageSparseMemoryRequirements": "Query the memory requirements for a sparse image.",
  "vkGetImageSparseMemoryRequirements.device": "",
  "vkGetImageSparseMemoryRequirements.image": "",
  "vkGetImageSparseMemoryRequirements.pSparseMemoryRequirementCount": "",
  "vkGetImageSparseMemoryRequirements.pSparseMemoryRequirements": "",
  "vkGetImageSparseMemoryRequirements2KHR": "",
  "vkGetImageSparseMemoryRequirements2KHR.device": "",
  "vkGetImageSparseMemoryRequirements2KHR.pInfo": "",
  "vkGetImageSparseMemoryRequirements2KHR.pSparseMemoryRequirementCount": "",
  "vkGetImageSparseMemoryRequirements2KHR.pSparseMemoryRequirements": "",
  "vkGetImageSubresourceLayout": "Retrieve information about an image subresource.",
  "vkGetImageSubresourceLayout.device": "",
  "vkGetImageSubresourceLayout.image": "",
  "vkGetImageSubresourceLayout.pLayout": "",
  "vkGetImageSubresourceLayout.pSubresource": "",
  "vkGetInstanceProcAddr": "Return a function pointer for a command.",
  "vkGetInstanceProcAddr.instance": "",
  "vkGetInstanceProcAddr.pName": "",
  "vkGetMemoryFdKHR": "",
  "vkGetMemoryFdKHR.device": "",
  "vkGetMemoryFdKHR.pFd": "",
  "vkGetMemoryFdKHR.pGetFdInfo": "",
  "vkGetMemoryFdPropertiesKHR": "",
  "vkGetMemoryFdPropertiesKHR.device": "",
  "vkGetMemoryFdPropertiesKHR.fd": "",
  "vkGetMemoryFdPropertiesKHR.handleType": "",
  "vkGetMemoryFdPropertiesKHR.pMemoryFdProperties": "",
  "vkGetMemoryHostPointerPropertiesEXT": "",
  "vkGetMemoryHostPointerPropertiesEXT.device": "",
  "vkGetMemoryHostPointerPropertiesEXT.handleType": "",
  "vkGetMemoryHostPointerPropertiesEXT.pHostPointer": "",
  "vkGetMemoryHostPointerPropertiesEXT.pMemoryHostPointerProperties": "",
  "vkGetMemoryWin32HandleKHR": "",
  "vkGetMemoryWin32HandleKHR.device": "",
  "vkGetMemoryWin32HandleKHR.pGetWin32HandleInfo": "",
  "vkGetMemoryWin32HandleKHR.pHandle": "",
  "vkGetMemoryWin32HandleNV": "Retrieve Win32 handle to a device memory object.",
  "vkGetMemoryWin32HandleNV.device": "",
  "vkGetMemoryWin32HandleNV.handleType": "",
  "vkGetMemoryWin32HandleNV.memory": "",
  "vkGetMemoryWin32HandleNV.pHandle": "",
  "vkGetMemoryWin32HandlePropertiesKHR": "",
  "vkGetMemoryWin32HandlePropertiesKHR.device": "",
  "vkGetMemoryWin32HandlePropertiesKHR.handle": "",
  "vkGetMemoryWin32HandlePropertiesKHR.handleType": "",
  "vkGetMemoryWin32HandlePropertiesKHR.pMemoryWin32HandleProperties": "",
  "vkGetPastPresentationTimingGOOGLE": "",
  "vkGetPastPresentationTimingGOOGLE.device": "",
  "vkGetPastPresentationTimingGOOGLE.pPresentationTimingCount": "",
  "vkGetPastPresentationTimingGOOGLE.pPresentationTimings": "",
  "vkGetPastPresentationTimingGOOGLE.swapchain": "",
  "vkGetPhysicalDeviceDisplayPlanePropertiesKHR": "Query the plane properties.",
  "vkGetPhysicalDeviceDisplayPlanePropertiesKHR.physicalDevice": "",
  "vkGetPhysicalDeviceDisplayPlanePropertiesKHR.pProperties": "",
  "vkGetPhysicalDeviceDisplayPlanePropertiesKHR.pPropertyCount": "",
  "vkGetPhysicalDeviceDisplayPropertiesKHR": "Query information about the available displays.",
  "vkGetPhysicalDeviceDisplayPropertiesKHR.physicalDevice": "",
  "vkGetPhysicalDeviceDisplayPropertiesKHR.pProperties": "",
  "vkGetPhysicalDeviceDisplayPropertiesKHR.pPropertyCount": "",
  "vkGetPhysicalDeviceExternalBufferPropertiesKHR": "",
  "vkGetPhysicalDeviceExternalBufferPropertiesKHR.pExternalBufferInfo": "",
  "vkGetPhysicalDeviceExternalBufferPropertiesKHR.pExternalBufferProperties": "",
  "vkGetPhysicalDeviceExternalBufferPropertiesKHR.physicalDevice": "",
  "vkGetPhysicalDeviceExternalFencePropertiesKHR": "",
  "vkGetPhysicalDeviceExternalFencePropertiesKHR.pExternalFenceInfo": "",
  "vkGetPhysicalDeviceExternalFencePropertiesKHR.pExternalFenceProperties": "",
  "vkGetPhysicalDeviceExternalFencePropertiesKHR.physicalDevice": "",
  "vkGetPhysicalDeviceExternalImageFormatPropertiesNV": "Determine image capabilities compatible with external memory handle types.",
  "vkGetPhysicalDeviceExternalImageFormatPropertiesNV.externalHandleType": "",
  "vkGetPhysicalDeviceExternalImageFormatPropertiesNV.flags": "",
  "vkGetPhysicalDeviceExternalImageFormatPropertiesNV.format": "",
  "vkGetPhysicalDeviceExternalImageFormatPropertiesNV.pExternalImageFormatProperties": "",
  "vkGetPhysicalDeviceExternalImageFormatPropertiesNV.physicalDevice": "",
  "vkGetPhysicalDeviceExternalImageFormatPropertiesNV.tiling": "",
  "vkGetPhysicalDeviceExternalImageFormatPropertiesNV.type": "",
  "vkGetPhysicalDeviceExternalImageFormatPropertiesNV.usage": "",
  "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR": "",
  "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR.pExternalSemaphoreInfo": "",
  "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR.pExternalSemaphoreProperties": "",
  "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR.physicalDevice": "",
  "vkGetPhysicalDeviceFeatures": "Reports capabilities of a physical device.",
  "vkGetPhysicalDeviceFeatures.pFeatures": "",
  "vkGetPhysicalDeviceFeatures.physicalDevice": "",
  "vkGetPhysicalDeviceFeatures2KHR": "Reports capabilities of a physical device.",
  "vkGetPhysicalDeviceFeatures2KHR.pFeatures": "",
  "vkGetPhysicalDeviceFeatures2KHR.physicalDevice": "",
  "vkGetPhysicalDeviceFormatProperties": "Lists physical device's format capabilities.",
  "vkGetPhysicalDeviceFormatProperties.format": "",
  "vkGetPhysicalDeviceFormatProperties.pFormatProperties": "",
  "vkGetPhysicalDeviceFormatProperties.physicalDevice": "",
  "vkGetPhysicalDeviceFormatProperties2KHR": "Lists physical device's format capabilities.",
  "vkGetPhysicalDeviceFormatProperties2KHR.format": "",
  "vkGetPhysicalDeviceFormatProperties2KHR.pFormatProperties": "",
  "vkGetPhysicalDeviceFormatProperties2KHR.physicalDevice": "",
  "vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX": "Returns device-generated commands related properties of a physical device.",
  "vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX.pFeatures": "",
  "vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX.physicalDevice": "",
  "vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX.pLimits": "",
  "vkGetPhysicalDeviceImageFormatProperties": "Lists physical device's image format capabilities.",
  "vkGetPhysicalDeviceImageFormatProperties.flags": "",
  "vkGetPhysicalDeviceImageFormatProperties.format": "",
  "vkGetPhysicalDeviceImageFormatProperties.physicalDevice": "",
  "vkGetPhysicalDeviceImageFormatProperties.pImageFormatProperties": "",
  "vkGetPhysicalDeviceImageFormatProperties.tiling": "",
  "vkGetPhysicalDeviceImageFormatProperties.type": "",
  "vkGetPhysicalDeviceImageFormatProperties.usage": "",
  "vkGetPhysicalDeviceImageFormatProperties2KHR": "Lists physical device's image format capabilities.",
  "vkGetPhysicalDeviceImageFormatProperties2KHR.physicalDevice": "",
  "vkGetPhysicalDeviceImageFormatProperties2KHR.pImageFormatInfo": "",
  "vkGetPhysicalDeviceImageFormatProperties2KHR.pImageFormatProperties": "",
  "vkGetPhysicalDeviceMemoryProperties": "Reports memory information for the specified physical device.",
  "vkGetPhysicalDeviceMemoryProperties.physicalDevice": "",
  "vkGetPhysicalDeviceMemoryProperties.pMemoryProperties": "",
  "vkGetPhysicalDeviceMemoryProperties2KHR": "Reports memory information for the specified physical device.",
  "vkGetPhysicalDeviceMemoryProperties2KHR.physicalDevice": "",
  "vkGetPhysicalDeviceMemoryProperties2KHR.pMemoryProperties": "",
  "vkGetPhysicalDeviceMirPresentationSupportKHR": "Query physical device for presentation to Mir.",
  "vkGetPhysicalDeviceMirPresentationSupportKHR.connection": "",
  "vkGetPhysicalDeviceMirPresentationSupportKHR.physicalDevice": "",
  "vkGetPhysicalDeviceMirPresentationSupportKHR.queueFamilyIndex": "",
  "vkGetPhysicalDeviceMultisamplePropertiesEXT": "",
  "vkGetPhysicalDeviceMultisamplePropertiesEXT.physicalDevice": "",
  "vkGetPhysicalDeviceMultisamplePropertiesEXT.pMultisampleProperties": "",
  "vkGetPhysicalDeviceMultisamplePropertiesEXT.samples": "",
  "vkGetPhysicalDevicePresentRectanglesKHX": "Query present rectangles for a surface on a physical device.",
  "vkGetPhysicalDevicePresentRectanglesKHX.physicalDevice": "",
  "vkGetPhysicalDevicePresentRectanglesKHX.pRectCount": "",
  "vkGetPhysicalDevicePresentRectanglesKHX.pRects": "",
  "vkGetPhysicalDevicePresentRectanglesKHX.surface": "",
  "vkGetPhysicalDeviceProperties": "Returns properties of a physical device.",
  "vkGetPhysicalDeviceProperties.physicalDevice": "",
  "vkGetPhysicalDeviceProperties.pProperties": "",
  "vkGetPhysicalDeviceProperties2KHR": "Returns properties of a physical device.",
  "vkGetPhysicalDeviceProperties2KHR.physicalDevice": "",
  "vkGetPhysicalDeviceProperties2KHR.pProperties": "",
  "vkGetPhysicalDeviceQueueFamilyProperties": "Reports properties of the queues of the specified physical device.",
  "vkGetPhysicalDeviceQueueFamilyProperties.physicalDevice": "",
  "vkGetPhysicalDeviceQueueFamilyProperties.pQueueFamilyProperties": "",
  "vkGetPhysicalDeviceQueueFamilyProperties.pQueueFamilyPropertyCount": "",
  "vkGetPhysicalDeviceQueueFamilyProperties2KHR": "Reports properties of the queues of the specified physical device.",
  "vkGetPhysicalDeviceQueueFamilyProperties2KHR.physicalDevice": "",
  "vkGetPhysicalDeviceQueueFamilyProperties2KHR.pQueueFamilyProperties": "",
  "vkGetPhysicalDeviceQueueFamilyProperties2KHR.pQueueFamilyPropertyCount": "",
  "vkGetPhysicalDeviceSparseImageFormatProperties": "Retrieve properties of an image format applied to sparse images.",
  "vkGetPhysicalDeviceSparseImageFormatProperties.format": "",
  "vkGetPhysicalDeviceSparseImageFormatProperties.physicalDevice": "",
  "vkGetPhysicalDeviceSparseImageFormatProperties.pProperties": "",
  "vkGetPhysicalDeviceSparseImageFormatProperties.pPropertyCount": "",
  "vkGetPhysicalDeviceSparseImageFormatProperties.samples": "",
  "vkGetPhysicalDeviceSparseImageFormatProperties.tiling": "",
  "vkGetPhysicalDeviceSparseImageFormatProperties.type": "",
  "vkGetPhysicalDeviceSparseImageFormatProperties.usage": "",
  "vkGetPhysicalDeviceSparseImageFormatProperties2KHR": "Retrieve properties of an image format applied to sparse images.",
  "vkGetPhysicalDeviceSparseImageFormatProperties2KHR.pFormatInfo": "",
  "vkGetPhysicalDeviceSparseImageFormatProperties2KHR.physicalDevice": "",
  "vkGetPhysicalDeviceSparseImageFormatProperties2KHR.pProperties": "",
  "vkGetPhysicalDeviceSparseImageFormatProperties2KHR.pPropertyCount": "",
  "vkGetPhysicalDeviceSurfaceCapabilities2EXT": "Query surface capabilities.",
  "vkGetPhysicalDeviceSurfaceCapabilities2EXT.physicalDevice": "",
  "vkGetPhysicalDeviceSurfaceCapabilities2EXT.pSurfaceCapabilities": "",
  "vkGetPhysicalDeviceSurfaceCapabilities2EXT.surface": "",
  "vkGetPhysicalDeviceSurfaceCapabilities2KHR": "",
  "vkGetPhysicalDeviceSurfaceCapabilities2KHR.physicalDevice": "",
  "vkGetPhysicalDeviceSurfaceCapabilities2KHR.pSurfaceCapabilities": "",
  "vkGetPhysicalDeviceSurfaceCapabilities2KHR.pSurfaceInfo": "",
  "vkGetPhysicalDeviceSurfaceCapabilitiesKHR": "Query surface capabilities.",
  "vkGetPhysicalDeviceSurfaceCapabilitiesKHR.physicalDevice": "",
  "vkGetPhysicalDeviceSurfaceCapabilitiesKHR.pSurfaceCapabilities": "",
  "vkGetPhysicalDeviceSurfaceCapabilitiesKHR.surface": "",
  "vkGetPhysicalDeviceSurfaceFormats2KHR": "",
  "vkGetPhysicalDeviceSurfaceFormats2KHR.physicalDevice": "",
  "vkGetPhysicalDeviceSurfaceFormats2KHR.pSurfaceFormatCount": "",
  "vkGetPhysicalDeviceSurfaceFormats2KHR.pSurfaceFormats": "",
  "vkGetPhysicalDeviceSurfaceFormats2KHR.pSurfaceInfo": "",
  "vkGetPhysicalDeviceSurfaceFormatsKHR": "Query color formats supported by surface.",
  "vkGetPhysicalDeviceSurfaceFormatsKHR.physicalDevice": "",
  "vkGetPhysicalDeviceSurfaceFormatsKHR.pSurfaceFormatCount": "",
  "vkGetPhysicalDeviceSurfaceFormatsKHR.pSurfaceFormats": "",
  "vkGetPhysicalDeviceSurfaceFormatsKHR.surface": "",
  "vkGetPhysicalDeviceSurfacePresentModesKHR": "Query supported presentation modes.",
  "vkGetPhysicalDeviceSurfacePresentModesKHR.physicalDevice": "",
  "vkGetPhysicalDeviceSurfacePresentModesKHR.pPresentModeCount": "",
  "vkGetPhysicalDeviceSurfacePresentModesKHR.pPresentModes": "",
  "vkGetPhysicalDeviceSurfacePresentModesKHR.surface": "",
  "vkGetPhysicalDeviceSurfaceSupportKHR": "Query if presentation is supported.",
  "vkGetPhysicalDeviceSurfaceSupportKHR.physicalDevice": "",
  "vkGetPhysicalDeviceSurfaceSupportKHR.pSupported": "",
  "vkGetPhysicalDeviceSurfaceSupportKHR.queueFamilyIndex": "",
  "vkGetPhysicalDeviceSurfaceSupportKHR.surface": "",
  "vkGetPhysicalDeviceWaylandPresentationSupportKHR": "Query physical device for presentation to Wayland.",
  "vkGetPhysicalDeviceWaylandPresentationSupportKHR.display": "",
  "vkGetPhysicalDeviceWaylandPresentationSupportKHR.physicalDevice": "",
  "vkGetPhysicalDeviceWaylandPresentationSupportKHR.queueFamilyIndex": "",
  "vkGetPhysicalDeviceWin32PresentationSupportKHR": "Query queue family support for presentation on a Win32 display.",
  "vkGetPhysicalDeviceWin32PresentationSupportKHR.physicalDevice": "",
  "vkGetPhysicalDeviceWin32PresentationSupportKHR.queueFamilyIndex": "",
  "vkGetPhysicalDeviceXcbPresentationSupportKHR": "Query physical device for presentation to X11 server using XCB.",
  "vkGetPhysicalDeviceXcbPresentationSupportKHR.connection": "",
  "vkGetPhysicalDeviceXcbPresentationSupportKHR.physicalDevice": "",
  "vkGetPhysicalDeviceXcbPresentationSupportKHR.queueFamilyIndex": "",
  "vkGetPhysicalDeviceXcbPresentationSupportKHR.visual_id": "",
  "vkGetPhysicalDeviceXlibPresentationSupportKHR": "Query physical device for presentation to X11 server using Xlib.",
  "vkGetPhysicalDeviceXlibPresentationSupportKHR.dpy": "",
  "vkGetPhysicalDeviceXlibPresentationSupportKHR.physicalDevice": "",
  "vkGetPhysicalDeviceXlibPresentationSupportKHR.queueFamilyIndex": "",
  "vkGetPhysicalDeviceXlibPresentationSupportKHR.visualID": "",
  "vkGetPipelineCacheData": "Get the data store from a pipeline cache.",
  "vkGetPipelineCacheData.device": "",
  "vkGetPipelineCacheData.pData": "",
  "vkGetPipelineCacheData.pDataSize": "",
  "vkGetPipelineCacheData.pipelineCache": "",
  "vkGetQueryPoolResults": "Copy results of queries in a query pool to a host memory region.",
  "vkGetQueryPoolResults.dataSize": "",
  "vkGetQueryPoolResults.device": "",
  "vkGetQueryPoolResults.firstQuery": "",
  "vkGetQueryPoolResults.flags": "",
  "vkGetQueryPoolResults.pData": "",
  "vkGetQueryPoolResults.queryCount": "",
  "vkGetQueryPoolResults.queryPool": "",
  "vkGetQueryPoolResults.stride": "",
  "vkGetRandROutputDisplayEXT": "Query the DisplayKHR corresponding to an X11 RandR Output.",
  "vkGetRandROutputDisplayEXT.dpy": "",
  "vkGetRandROutputDisplayEXT.pDisplay": "",
  "vkGetRandROutputDisplayEXT.physicalDevice": "",
  "vkGetRandROutputDisplayEXT.rrOutput": "",
  "vkGetRefreshCycleDurationGOOGLE": "",
  "vkGetRefreshCycleDurationGOOGLE.device": "",
  "vkGetRefreshCycleDurationGOOGLE.pDisplayTimingProperties": "",
  "vkGetRefreshCycleDurationGOOGLE.swapchain": "",
  "vkGetRenderAreaGranularity": "Returns the granularity for optimal render area.",
  "vkGetRenderAreaGranularity.device": "",
  "vkGetRenderAreaGranularity.pGranularity": "",
  "vkGetRenderAreaGranularity.renderPass": "",
  "vkGetSemaphoreFdKHR": "",
  "vkGetSemaphoreFdKHR.device": "",
  "vkGetSemaphoreFdKHR.pFd": "",
  "vkGetSemaphoreFdKHR.pGetFdInfo": "",
  "vkGetSemaphoreWin32HandleKHR": "",
  "vkGetSemaphoreWin32HandleKHR.device": "",
  "vkGetSemaphoreWin32HandleKHR.pGetWin32HandleInfo": "",
  "vkGetSemaphoreWin32HandleKHR.pHandle": "",
  "vkGetShaderInfoAMD": "",
  "vkGetShaderInfoAMD.device": "",
  "vkGetShaderInfoAMD.infoType": "",
  "vkGetShaderInfoAMD.pInfo": "",
  "vkGetShaderInfoAMD.pInfoSize": "",
  "vkGetShaderInfoAMD.pipeline": "",
  "vkGetShaderInfoAMD.shaderStage": "",
  "vkGetSwapchainCounterEXT": "Query the current value of a surface counter.",
  "vkGetSwapchainCounterEXT.counter": "",
  "vkGetSwapchainCounterEXT.device": "",
  "vkGetSwapchainCounterEXT.pCounterValue": "",
  "vkGetSwapchainCounterEXT.swapchain": "",
  "vkGetSwapchainImagesKHR": "Obtain the array of presentable images associated with a swapchain.",
  "vkGetSwapchainImagesKHR.device": "",
  "vkGetSwapchainImagesKHR.pSwapchainImageCount": "",
  "vkGetSwapchainImagesKHR.pSwapchainImages": "",
  "vkGetSwapchainImagesKHR.swapchain": "",
  "vkGetSwapchainStatusKHR": "",
  "vkGetSwapchainStatusKHR.device": "",
  "vkGetSwapchainStatusKHR.swapchain": "",
  "vkGetValidationCacheDataEXT": "",
  "vkGetValidationCacheDataEXT.device": "",
  "vkGetValidationCacheDataEXT.pData": "",
  "vkGetValidationCacheDataEXT.pDataSize": "",
  "vkGetValidationCacheDataEXT.validationCache": "",
  "VkGraphicsPipelineCreateInfo": "Structure specifying parameters of a newly created graphics pipeline.",
  "VkGraphicsPipelineCreateInfo.basePipelineHandle": "A pipeline to derive from.",
  "VkGraphicsPipelineCreateInfo.basePipelineIndex": "An index into the pCreateInfos parameter to use as a pipeline to derive from.",
  "VkGraphicsPipelineCreateInfo.flags": "A bitmask of PipelineCreateFlagBits controlling how the pipeline will be generated, as described below.",
  "VkGraphicsPipelineCreateInfo.layout": "The description of binding locations used by both the pipeline and descriptor sets used with the pipeline.",
  "VkGraphicsPipelineCreateInfo.pColorBlendState": "An instance of the PipelineColorBlendStateCreateInfo structure, or Null if the pipeline has rasterization disabled or if the subpass of the render pass the pipeline is created against does not use any color attachments.",
  "VkGraphicsPipelineCreateInfo.pDepthStencilState": "An instance of the PipelineDepthStencilStateCreateInfo structure, or Null if the pipeline has rasterization disabled or if the subpass of the render pass the pipeline is created against does not use a depth/stencil attachment.",
  "VkGraphicsPipelineCreateInfo.pDynamicState": "A pointer to PipelineDynamicStateCreateInfo and is used to indicate which properties of the pipeline state object are dynamic and can be changed independently of the pipeline state. This can be Null, which means no state in the pipeline is considered dynamic.",
  "VkGraphicsPipelineCreateInfo.pInputAssemblyState": "An instance of the PipelineInputAssemblyStateCreateInfo structure which determines input assembly behavior, as described in Drawing Commands.",
  "VkGraphicsPipelineCreateInfo.pMultisampleState": "An instance of the PipelineMultisampleStateCreateInfo, or Null if the pipeline has rasterization disabled.",
  "VkGraphicsPipelineCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkGraphicsPipelineCreateInfo.pRasterizationState": "An instance of the PipelineRasterizationStateCreateInfo structure.",
  "VkGraphicsPipelineCreateInfo.pStages": "An array of size stageCount structures of type PipelineShaderStageCreateInfo describing the set of the shader stages to be included in the graphics pipeline.",
  "VkGraphicsPipelineCreateInfo.pTessellationState": "An instance of the PipelineTessellationStateCreateInfo structure, or Null if the pipeline does not include a tessellation control shader stage and tessellation evaluation shader stage.",
  "VkGraphicsPipelineCreateInfo.pVertexInputState": "An instance of the PipelineVertexInputStateCreateInfo structure.",
  "VkGraphicsPipelineCreateInfo.pViewportState": "An instance of the PipelineViewportStateCreateInfo structure, or Null if the pipeline has rasterization disabled.",
  "VkGraphicsPipelineCreateInfo.renderPass": "A handle to a render pass object describing the environment in which the pipeline will be used; the pipeline must only be used with an instance of any render pass compatible with the one provided. See Render Pass Compatibility for more information.",
  "VkGraphicsPipelineCreateInfo.stageCount": "The number of entries in the pStages array.",
  "VkGraphicsPipelineCreateInfo.sType": "The type of this structure.",
  "VkGraphicsPipelineCreateInfo.subpass": "The index of the subpass in the render pass where this pipeline will be used.",
  "VkHdrMetadataEXT": "",
  "VkHdrMetadataEXT.displayPrimaryBlue": "",
  "VkHdrMetadataEXT.displayPrimaryGreen": "",
  "VkHdrMetadataEXT.displayPrimaryRed": "",
  "VkHdrMetadataEXT.maxContentLightLevel": "",
  "VkHdrMetadataEXT.maxFrameAverageLightLevel": "",
  "VkHdrMetadataEXT.maxLuminance": "",
  "VkHdrMetadataEXT.minLuminance": "",
  "VkHdrMetadataEXT.pNext": "",
  "VkHdrMetadataEXT.sType": "",
  "VkHdrMetadataEXT.whitePoint": "",
  "VkImage": "Opaque handle to a image object.",
  "VkImageAspectFlagBits": "Bitmask specifying which aspects of an image are included in a view.",
  "VkImageAspectFlagBits.__none": "",
  "VkImageAspectFlagBits.VK_IMAGE_ASPECT_COLOR_BIT": "",
  "VkImageAspectFlagBits.VK_IMAGE_ASPECT_DEPTH_BIT": "",
  "VkImageAspectFlagBits.VK_IMAGE_ASPECT_METADATA_BIT": "",
  "VkImageAspectFlagBits.VK_IMAGE_ASPECT_PLANE_0_BIT_KHR": "",
  "VkImageAspectFlagBits.VK_IMAGE_ASPECT_PLANE_1_BIT_KHR": "",
  "VkImageAspectFlagBits.VK_IMAGE_ASPECT_PLANE_2_BIT_KHR": "",
  "VkImageAspectFlagBits.VK_IMAGE_ASPECT_STENCIL_BIT": "",
  "VkImageAspectFlags": "",
  "VkImageBlit": "Structure specifying an image blit operation.",
  "VkImageBlit.dstOffsets": "An array of two Offset3D structures specifying the bounds of the destination region within dstSubresource.",
  "VkImageBlit.dstSubresource": "The subresource to blit into.",
  "VkImageBlit.srcOffsets": "An array of two Offset3D structures specifying the bounds of the source region within srcSubresource.",
  "VkImageBlit.srcSubresource": "The subresource to blit from.",
  "VkImageCopy": "Structure specifying an image copy operation.",
  "VkImageCopy.dstOffset": "",
  "VkImageCopy.dstSubresource": "",
  "VkImageCopy.extent": "The size in texels of the source image to copy in width, height and depth.",
  "VkImageCopy.srcOffset": "srcOffset and dstOffset select the initial x, y, and z offsets in texels of the sub-regions of the source and destination image data.",
  "VkImageCopy.srcSubresource": "srcSubresource and dstSubresource are ImageSubresourceLayers structures specifying the image subresources of the images used for the source and destination image data, respectively.",
  "VkImageCreateFlagBits": "Bitmask specifying additional parameters of an image.",
  "VkImageCreateFlagBits.__none": "",
  "VkImageCreateFlagBits.VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR": "Indicates that the image can be used to create a ImageView of type VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY.",
  "VkImageCreateFlagBits.VK_IMAGE_CREATE_ALIAS_BIT_KHR": "",
  "VkImageCreateFlagBits.VK_IMAGE_CREATE_BIND_SFR_BIT_KHX": "Indicates that the image can be used with a non-zero value of the SFRRectCount member of the BindImageMemoryInfoKHX structure passed into flink:vkBindImageMemory2KHX. This flag also has the effect of making the image use the standard sparse image block dimensions.",
  "VkImageCreateFlagBits.VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR": "",
  "VkImageCreateFlagBits.VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT": "Indicates that the image can be used to create a ImageView of type VK_IMAGE_VIEW_TYPE_CUBE or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY.",
  "VkImageCreateFlagBits.VK_IMAGE_CREATE_DISJOINT_BIT_KHR": "",
  "VkImageCreateFlagBits.VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR": "",
  "VkImageCreateFlagBits.VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT": "Indicates that the image can be used to create a ImageView with a different format from the image.",
  "VkImageCreateFlagBits.VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT": "",
  "VkImageCreateFlagBits.VK_IMAGE_CREATE_SPARSE_ALIASED_BIT": "Indicates that the image will be backed using sparse memory binding with memory ranges that might also simultaneously be backing another image (or another portion of the same image). Images created with this flag must also be created with the VK_IMAGE_CREATE_SPARSE_BINDING_BIT flag",
  "VkImageCreateFlagBits.VK_IMAGE_CREATE_SPARSE_BINDING_BIT": "Indicates that the image will be backed using sparse memory binding.",
  "VkImageCreateFlagBits.VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT": "Indicates that the image can be partially backed using sparse memory binding. Images created with this flag must also be created with the VK_IMAGE_CREATE_SPARSE_BINDING_BIT flag.",
  "VkImageCreateFlags": "",
  "VkImageCreateInfo": "Structure specifying the parameters of a newly created image object.",
  "VkImageCreateInfo.arrayLayers": "The number of layers in the image.",
  "VkImageCreateInfo.extent": "A Extent3D describing the number of data elements in each dimension of the base level.",
  "VkImageCreateInfo.flags": "A bitmask describing additional parameters of the image. See ImageCreateFlagBits below for a description of the supported bits.",
  "VkImageCreateInfo.format": "A Format describing the format and type of the data elements that will be contained in the image.",
  "VkImageCreateInfo.imageType": "A ImageType specifying the basic dimensionality of the image, as described below. Layers in array textures do not count as a dimension for the purposes of the image type.",
  "VkImageCreateInfo.initialLayout": "initialLayout selects the initial ImageLayout state of all image subresources of the image. See Image Layouts. initialLayout must be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED.",
  "VkImageCreateInfo.mipLevels": "mipLevels describes the number of levels of detail available for minified sampling of the image.",
  "VkImageCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkImageCreateInfo.pQueueFamilyIndices": "A list of queue families that will access this image (ignored if sharingMode is not VK_SHARING_MODE_CONCURRENT).",
  "VkImageCreateInfo.queueFamilyIndexCount": "The number of entries in the pQueueFamilyIndices array.",
  "VkImageCreateInfo.samples": "The number of sub-data element samples in the image as defined in SampleCountFlagBits. See Multisampling.",
  "VkImageCreateInfo.sharingMode": "The sharing mode of the image when it will be accessed by multiple queue families, and must be one of the values described for SharingMode in the Resource Sharing section below.",
  "VkImageCreateInfo.sType": "The type of this structure.",
  "VkImageCreateInfo.tiling": "A ImageTiling specifying the tiling arrangement of the data elements in memory, as described below.",
  "VkImageCreateInfo.usage": "A bitmask describing the intended usage of the image. See ImageUsageFlagBits below for a description of the supported bits.",
  "VkImageFormatListCreateInfoKHR": "",
  "VkImageFormatListCreateInfoKHR.pNext": "",
  "VkImageFormatListCreateInfoKHR.pViewFormats": "",
  "VkImageFormatListCreateInfoKHR.sType": "",
  "VkImageFormatListCreateInfoKHR.viewFormatCount": "",
  "VkImageFormatProperties": "Structure specifying a image format properties.",
  "VkImageFormatProperties.maxArrayLayers": "The maximum number of array layers. maxArrayLayers must either be equal to 1 or be greater than or equal to the maxImageArrayLayers member of PhysicalDeviceLimits. A value of 1 is valid only if tiling is VK_IMAGE_TILING_LINEAR or if type is VK_IMAGE_TYPE_3D.",
  "VkImageFormatProperties.maxExtent": "maxExtent are the maximum image dimensions. See the Allowed Extent Values section below for how these values are constrained by type.",
  "VkImageFormatProperties.maxMipLevels": "The maximum number of mipmap levels. maxMipLevels must either be equal to 1 (valid only if tiling is VK_IMAGE_TILING_LINEAR) or be equal to [eq]#{lceil}log~2~(max(width, height, depth)){rceil} {plus} 1#. [eq]#width#, [eq]#height#, and [eq]#depth# are taken from the corresponding members of maxExtent.",
  "VkImageFormatProperties.maxResourceSize": "An upper bound on the total image size in bytes, inclusive of all image subresources. Implementations may have an address space limit on total size of a resource, which is advertised by this property. maxResourceSize must be at least 2^31^.",
  "VkImageFormatProperties.sampleCounts": "A bitmask of SampleCountFlagBits specifying all the supported sample counts for this image as described below.",
  "VkImageFormatProperties2KHR": "Structure specifying a image format properties.",
  "VkImageFormatProperties2KHR.imageFormatProperties": "An instance of a ImageFormatProperties structure in which capabilities are returned.",
  "VkImageFormatProperties2KHR.pNext": "Null or an extension-specific structure.",
  "VkImageFormatProperties2KHR.sType": "The type of this structure.",
  "VkImageLayout": "Layout of image and image subresources.",
  "VkImageLayout.VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL": "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL: must only be used as a color or resolve attachment in a Framebuffer. This layout is valid only for image subresources of images created with the VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT usage bit enabled.",
  "VkImageLayout.VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR": "",
  "VkImageLayout.VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR": "",
  "VkImageLayout.VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL": "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL: must only be used as a depth/stencil attachment in a Framebuffer. This layout is valid only for image subresources of images created with the VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT usage bit enabled.",
  "VkImageLayout.VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL": "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL: must only be used as a read-only depth/stencil attachment in a Framebuffer and/or as a read-only image in a shader (which can be read as a sampled image, combined image/sampler and/or input attachment). This layout is valid only for image subresources of images created with the VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT usage bit enabled. Only image subresources of images created with VK_IMAGE_USAGE_SAMPLED_BIT can be used as sampled image or combined image/sampler in a shader. Similarly, only image subresources of images created with VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT can be used as input attachments.",
  "VkImageLayout.VK_IMAGE_LAYOUT_GENERAL": "VK_IMAGE_LAYOUT_GENERAL: Supports all types of device access.",
  "VkImageLayout.VK_IMAGE_LAYOUT_PREINITIALIZED": "VK_IMAGE_LAYOUT_PREINITIALIZED: Supports no device access. This layout must only be used as the initialLayout member of ImageCreateInfo or AttachmentDescription, or as the oldLayout in an image transition. When transitioning out of this layout, the contents of the memory are preserved. This layout is intended to be used as the initial layout for an image whose contents are written by the host, and hence the data can be written to memory immediately, without first executing a layout transition. Currently, VK_IMAGE_LAYOUT_PREINITIALIZED is only useful with VK_IMAGE_TILING_LINEAR images because there is not a standard layout defined for VK_IMAGE_TILING_OPTIMAL images.",
  "VkImageLayout.VK_IMAGE_LAYOUT_PRESENT_SRC_KHR": "VK_IMAGE_LAYOUT_PRESENT_SRC_KHR: must only be used for presenting a presentable image for display. A swapchain's image must be transitioned to this layout before calling flink:vkQueuePresentKHR, and must be transitioned away from this layout after calling flink:vkAcquireNextImageKHR.",
  "VkImageLayout.VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL": "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: must only be used as a read-only image in a shader (which can be read as a sampled image, combined image/sampler and/or input attachment). This layout is valid only for image subresources of images created with the VK_IMAGE_USAGE_SAMPLED_BIT or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT usage bit enabled.",
  "VkImageLayout.VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR": "",
  "VkImageLayout.VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL": "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: must only be used as a destination image of a transfer command. This layout is valid only for image subresources of images created with the VK_IMAGE_USAGE_TRANSFER_DST_BIT usage bit enabled.",
  "VkImageLayout.VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL": "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL: must only be used as a source image of a transfer command (see the definition of VK_PIPELINE_STAGE_TRANSFER_BIT). This layout is valid only for image subresources of images created with the VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage bit enabled.",
  "VkImageLayout.VK_IMAGE_LAYOUT_UNDEFINED": "VK_IMAGE_LAYOUT_UNDEFINED: Supports no device access. This layout must only be used as the initialLayout member of ImageCreateInfo or AttachmentDescription, or as the oldLayout in an image transition. When transitioning out of this layout, the contents of the memory are not guaranteed to be preserved.",
  "VkImageMemoryBarrier": "Structure specifying the parameters of an image memory barrier.",
  "VkImageMemoryBarrier.dstAccessMask": "dstAccessMask defines a destination access mask.",
  "VkImageMemoryBarrier.dstQueueFamilyIndex": "The destination queue family for a queue family ownership transfer.",
  "VkImageMemoryBarrier.image": "A handle to the image affected by this barrier.",
  "VkImageMemoryBarrier.newLayout": "The new layout in an image layout transition.",
  "VkImageMemoryBarrier.oldLayout": "The old layout in an image layout transition.",
  "VkImageMemoryBarrier.pNext": "Null or an extension-specific structure.",
  "VkImageMemoryBarrier.srcAccessMask": "srcAccessMask defines a source access mask.",
  "VkImageMemoryBarrier.srcQueueFamilyIndex": "The source queue family for a queue family ownership transfer.",
  "VkImageMemoryBarrier.sType": "The type of this structure.",
  "VkImageMemoryBarrier.subresourceRange": "subresourceRange describes the image subresource range within image that is affected by this barrier.",
  "VkImageMemoryRequirementsInfo2KHR": "",
  "VkImageMemoryRequirementsInfo2KHR.image": "",
  "VkImageMemoryRequirementsInfo2KHR.pNext": "",
  "VkImageMemoryRequirementsInfo2KHR.sType": "",
  "VkImagePlaneMemoryRequirementsInfoKHR": "",
  "VkImagePlaneMemoryRequirementsInfoKHR.planeAspect": "",
  "VkImagePlaneMemoryRequirementsInfoKHR.pNext": "",
  "VkImagePlaneMemoryRequirementsInfoKHR.sType": "",
  "VkImageResolve": "Structure specifying an image resolve operation.",
  "VkImageResolve.dstOffset": "",
  "VkImageResolve.dstSubresource": "",
  "VkImageResolve.extent": "The size in texels of the source image to resolve in width, height and depth.",
  "VkImageResolve.srcOffset": "srcOffset and dstOffset select the initial x, y, and z offsets in texels of the sub-regions of the source and destination image data.",
  "VkImageResolve.srcSubresource": "srcSubresource and dstSubresource are ImageSubresourceLayers structures specifying the image subresources of the images used for the source and destination image data, respectively. Resolve of depth/stencil images is not supported.",
  "VkImageSparseMemoryRequirementsInfo2KHR": "",
  "VkImageSparseMemoryRequirementsInfo2KHR.image": "",
  "VkImageSparseMemoryRequirementsInfo2KHR.pNext": "",
  "VkImageSparseMemoryRequirementsInfo2KHR.sType": "",
  "VkImageSubresource": "Structure specifying a image subresource.",
  "VkImageSubresource.arrayLayer": "arrayLayer selects the array layer.",
  "VkImageSubresource.aspectMask": "A ImageAspectFlags selecting the image _aspect_.",
  "VkImageSubresource.mipLevel": "mipLevel selects the mipmap level.",
  "VkImageSubresourceLayers": "Structure specifying a image subresource layers.",
  "VkImageSubresourceLayers.aspectMask": "A combination of ImageAspectFlagBits, selecting the color, depth and/or stencil aspects to be copied.",
  "VkImageSubresourceLayers.baseArrayLayer": "baseArrayLayer and layerCount are the starting layer and number of layers to copy.",
  "VkImageSubresourceLayers.layerCount": "",
  "VkImageSubresourceLayers.mipLevel": "The mipmap level to copy from.",
  "VkImageSubresourceRange": "Structure specifying a image subresource range.",
  "VkImageSubresourceRange.aspectMask": "A bitmask indicating which aspect(s) of the image are included in the view. See ImageAspectFlagBits.",
  "VkImageSubresourceRange.baseArrayLayer": "The first array layer accessible to the view.",
  "VkImageSubresourceRange.baseMipLevel": "The first mipmap level accessible to the view.",
  "VkImageSubresourceRange.layerCount": "The number of array layers (starting from baseArrayLayer) accessible to the view.",
  "VkImageSubresourceRange.levelCount": "The number of mipmap levels (starting from baseMipLevel) accessible to the view.",
  "VkImageSwapchainCreateInfoKHX": "Specify that an image will be bound to swapchain memory.",
  "VkImageSwapchainCreateInfoKHX.pNext": "Null or an extension-specific structure.",
  "VkImageSwapchainCreateInfoKHX.sType": "The type of this structure.",
  "VkImageSwapchainCreateInfoKHX.swapchain": "swapchain is null or a handle of a swapchain that the image will be bound to.",
  "VkImageTiling": "Specifies the tiling arrangement of data in an image.",
  "VkImageTiling.VK_IMAGE_TILING_LINEAR": "",
  "VkImageTiling.VK_IMAGE_TILING_OPTIMAL": "",
  "VkImageType": "Specifies the type of an image object.",
  "VkImageType.VK_IMAGE_TYPE_1D": "",
  "VkImageType.VK_IMAGE_TYPE_2D": "",
  "VkImageType.VK_IMAGE_TYPE_3D": "",
  "VkImageUsageFlagBits": "Bitmask specifying intended usage of an image.",
  "VkImageUsageFlagBits.__none": "",
  "VkImageUsageFlagBits.VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT": "Indicates that the image can be used to create a ImageView suitable for use as a color or resolve attachment in a Framebuffer.",
  "VkImageUsageFlagBits.VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT": "Indicates that the image can be used to create a ImageView suitable for use as a depth/stencil attachment in a Framebuffer.",
  "VkImageUsageFlagBits.VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT": "Indicates that the image can be used to create a ImageView suitable for occupying DescriptorSet slot of type VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT; be read from a shader as an input attachment; and be used as an input attachment in a framebuffer.",
  "VkImageUsageFlagBits.VK_IMAGE_USAGE_SAMPLED_BIT": "Indicates that the image can be used to create a ImageView suitable for occupying a DescriptorSet slot either of type VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and be sampled by a shader.",
  "VkImageUsageFlagBits.VK_IMAGE_USAGE_STORAGE_BIT": "Indicates that the image can be used to create a ImageView suitable for occupying a DescriptorSet slot of type VK_DESCRIPTOR_TYPE_STORAGE_IMAGE.",
  "VkImageUsageFlagBits.VK_IMAGE_USAGE_TRANSFER_DST_BIT": "Indicates that the image can be used as the destination of a transfer command.",
  "VkImageUsageFlagBits.VK_IMAGE_USAGE_TRANSFER_SRC_BIT": "Indicates that the image can be used as the source of a transfer command.",
  "VkImageUsageFlagBits.VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT": "Indicates that the memory bound to this image will have been allocated with the VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT (see <<memory for more detail). This bit can be set for any image that can be used to create a ImageView suitable for use as a color, resolve, depth/stencil, or input attachment.",
  "VkImageUsageFlags": "",
  "VkImageView": "Opaque handle to a image view object.",
  "VkImageViewCreateFlags": "",
  "VkImageViewCreateFlags.__none": "",
  "VkImageViewCreateInfo": "Structure specifying parameters of a newly created image view.",
  "VkImageViewCreateInfo.components": "Specifies a remapping of color components (or of depth or stencil components after they have been converted into color components). See ComponentMapping.",
  "VkImageViewCreateInfo.flags": "Reserved for future use.",
  "VkImageViewCreateInfo.format": "A Format describing the format and type used to interpret data elements in the image.",
  "VkImageViewCreateInfo.image": "A Image on which the view will be created.",
  "VkImageViewCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkImageViewCreateInfo.sType": "The type of this structure.",
  "VkImageViewCreateInfo.subresourceRange": "A ImageSubresourceRange selecting the set of mipmap levels and array layers to be accessible to the view.",
  "VkImageViewCreateInfo.viewType": "The type of the image view.",
  "VkImageViewType": "Image view types.",
  "VkImageViewType.VK_IMAGE_VIEW_TYPE_1D": "",
  "VkImageViewType.VK_IMAGE_VIEW_TYPE_1D_ARRAY": "",
  "VkImageViewType.VK_IMAGE_VIEW_TYPE_2D": "",
  "VkImageViewType.VK_IMAGE_VIEW_TYPE_2D_ARRAY": "",
  "VkImageViewType.VK_IMAGE_VIEW_TYPE_3D": "",
  "VkImageViewType.VK_IMAGE_VIEW_TYPE_CUBE": "",
  "VkImageViewType.VK_IMAGE_VIEW_TYPE_CUBE_ARRAY": "",
  "VkImageViewUsageCreateInfoKHR": "",
  "VkImageViewUsageCreateInfoKHR.pNext": "",
  "VkImageViewUsageCreateInfoKHR.sType": "",
  "VkImageViewUsageCreateInfoKHR.usage": "",
  "VkImportFenceFdInfoKHR": "",
  "VkImportFenceFdInfoKHR.fd": "",
  "VkImportFenceFdInfoKHR.fence": "",
  "VkImportFenceFdInfoKHR.flags": "",
  "VkImportFenceFdInfoKHR.handleType": "",
  "VkImportFenceFdInfoKHR.pNext": "",
  "VkImportFenceFdInfoKHR.sType": "",
  "vkImportFenceFdKHR": "",
  "vkImportFenceFdKHR.device": "",
  "vkImportFenceFdKHR.pImportFenceFdInfo": "",
  "VkImportFenceWin32HandleInfoKHR": "",
  "VkImportFenceWin32HandleInfoKHR.fence": "",
  "VkImportFenceWin32HandleInfoKHR.flags": "",
  "VkImportFenceWin32HandleInfoKHR.handle": "",
  "VkImportFenceWin32HandleInfoKHR.handleType": "",
  "VkImportFenceWin32HandleInfoKHR.name": "",
  "VkImportFenceWin32HandleInfoKHR.pNext": "",
  "VkImportFenceWin32HandleInfoKHR.sType": "",
  "vkImportFenceWin32HandleKHR": "",
  "vkImportFenceWin32HandleKHR.device": "",
  "vkImportFenceWin32HandleKHR.pImportFenceWin32HandleInfo": "",
  "VkImportMemoryFdInfoKHR": "",
  "VkImportMemoryFdInfoKHR.fd": "",
  "VkImportMemoryFdInfoKHR.handleType": "",
  "VkImportMemoryFdInfoKHR.pNext": "",
  "VkImportMemoryFdInfoKHR.sType": "",
  "VkImportMemoryHostPointerInfoEXT": "",
  "VkImportMemoryHostPointerInfoEXT.handleType": "",
  "VkImportMemoryHostPointerInfoEXT.pHostPointer": "",
  "VkImportMemoryHostPointerInfoEXT.pNext": "",
  "VkImportMemoryHostPointerInfoEXT.sType": "",
  "VkImportMemoryWin32HandleInfoKHR": "",
  "VkImportMemoryWin32HandleInfoKHR.handle": "",
  "VkImportMemoryWin32HandleInfoKHR.handleType": "",
  "VkImportMemoryWin32HandleInfoKHR.name": "",
  "VkImportMemoryWin32HandleInfoKHR.pNext": "",
  "VkImportMemoryWin32HandleInfoKHR.sType": "",
  "VkImportMemoryWin32HandleInfoNV": "Import Win32 memory created on the same physical device.",
  "VkImportMemoryWin32HandleInfoNV.handle": "",
  "VkImportMemoryWin32HandleInfoNV.handleType": "A flag specifying the type of memory handle in handle.",
  "VkImportMemoryWin32HandleInfoNV.pNext": "Null or an extension-specific structure.",
  "VkImportMemoryWin32HandleInfoNV.sType": "The type of this structure.",
  "VkImportSemaphoreFdInfoKHR": "",
  "VkImportSemaphoreFdInfoKHR.fd": "",
  "VkImportSemaphoreFdInfoKHR.flags": "",
  "VkImportSemaphoreFdInfoKHR.handleType": "",
  "VkImportSemaphoreFdInfoKHR.pNext": "",
  "VkImportSemaphoreFdInfoKHR.semaphore": "",
  "VkImportSemaphoreFdInfoKHR.sType": "",
  "vkImportSemaphoreFdKHR": "",
  "vkImportSemaphoreFdKHR.device": "",
  "vkImportSemaphoreFdKHR.pImportSemaphoreFdInfo": "",
  "VkImportSemaphoreWin32HandleInfoKHR": "",
  "VkImportSemaphoreWin32HandleInfoKHR.flags": "",
  "VkImportSemaphoreWin32HandleInfoKHR.handle": "",
  "VkImportSemaphoreWin32HandleInfoKHR.handleType": "",
  "VkImportSemaphoreWin32HandleInfoKHR.name": "",
  "VkImportSemaphoreWin32HandleInfoKHR.pNext": "",
  "VkImportSemaphoreWin32HandleInfoKHR.semaphore": "",
  "VkImportSemaphoreWin32HandleInfoKHR.sType": "",
  "vkImportSemaphoreWin32HandleKHR": "",
  "vkImportSemaphoreWin32HandleKHR.device": "",
  "vkImportSemaphoreWin32HandleKHR.pImportSemaphoreWin32HandleInfo": "",
  "VkIndexType": "Type of index buffer indices.",
  "VkIndexType.VK_INDEX_TYPE_UINT16": "",
  "VkIndexType.VK_INDEX_TYPE_UINT32": "",
  "VkIndirectCommandsLayoutCreateInfoNVX": "Structure specifying the parameters of a newly created indirect commands layout object.",
  "VkIndirectCommandsLayoutCreateInfoNVX.flags": "A bitmask providing usage hints of this layout. See IndirectCommandsLayoutUsageFlagBitsNVX below for a description of the supported bits.",
  "VkIndirectCommandsLayoutCreateInfoNVX.pipelineBindPoint": "The PipelineBindPoint that this layout targets.",
  "VkIndirectCommandsLayoutCreateInfoNVX.pNext": "Null or an extension-specific structure.",
  "VkIndirectCommandsLayoutCreateInfoNVX.pTokens": "An array describing each command token in detail. See IndirectCommandsTokenTypeNVX and IndirectCommandsLayoutTokenNVX below for details.",
  "VkIndirectCommandsLayoutCreateInfoNVX.sType": "The type of this structure.",
  "VkIndirectCommandsLayoutCreateInfoNVX.tokenCount": "The length of the individual command sequnce.",
  "VkIndirectCommandsLayoutNVX": "Opaque handle to an indirect commands layout object.",
  "VkIndirectCommandsLayoutTokenNVX": "Struct specifying the details of an indirect command layout token.",
  "VkIndirectCommandsLayoutTokenNVX.bindingUnit": "",
  "VkIndirectCommandsLayoutTokenNVX.divisor": "",
  "VkIndirectCommandsLayoutTokenNVX.dynamicCount": "",
  "VkIndirectCommandsLayoutTokenNVX.tokenType": "",
  "VkIndirectCommandsLayoutUsageFlagBitsNVX": "Bitmask specifying allowed usage of a indirect commands layout.",
  "VkIndirectCommandsLayoutUsageFlagBitsNVX.__none": "",
  "VkIndirectCommandsLayoutUsageFlagBitsNVX.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX": "Indicates that there is likely many draw or dispatch calls that are zero-sized (zero grid dimension, no primitives to render).",
  "VkIndirectCommandsLayoutUsageFlagBitsNVX.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX": "Indicates that the input data for the sequences is not implicitly indexed from 0..sequencesUsed but a user provided Buffer encoding the index is provided.",
  "VkIndirectCommandsLayoutUsageFlagBitsNVX.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX": "Indicates that there is likely a high difference between allocated number of sequences and actually used.",
  "VkIndirectCommandsLayoutUsageFlagBitsNVX.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX": "Indicates that the processing of sequences can happen at an implementation-dependent order, which is not guaranteed to be coherent across multiple invocations.",
  "VkIndirectCommandsLayoutUsageFlagsNVX": "",
  "VkIndirectCommandsTokenNVX": "Structure specifying parameters for the reservation of command buffer space.",
  "VkIndirectCommandsTokenNVX.buffer": "Specifies the Buffer storing the functional arguments for each squence. These argumetns can be written by the device.",
  "VkIndirectCommandsTokenNVX.offset": "offset specified an offset into buffer where the arguments start.",
  "VkIndirectCommandsTokenNVX.tokenType": "Specifies the token command type.",
  "VkIndirectCommandsTokenTypeNVX": "Enum specifying.",
  "VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX": "",
  "VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX": "",
  "VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX": "",
  "VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX": "",
  "VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX": "",
  "VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX": "",
  "VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX": "",
  "VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX": "",
  "VkInputAttachmentAspectReferenceKHR": "",
  "VkInputAttachmentAspectReferenceKHR.aspectMask": "",
  "VkInputAttachmentAspectReferenceKHR.inputAttachmentIndex": "",
  "VkInputAttachmentAspectReferenceKHR.subpass": "",
  "VkInstance": "Opaque handle to a instance object.",
  "VkInstanceCreateFlagBits": "",
  "VkInstanceCreateFlags": "",
  "VkInstanceCreateFlags.__none": "",
  "VkInstanceCreateInfo": "Structure specifying parameters of a newly created instance.",
  "VkInstanceCreateInfo.enabledExtensionCount": "The number of global extensions to enable.",
  "VkInstanceCreateInfo.enabledLayerCount": "The number of global layers to enable.",
  "VkInstanceCreateInfo.flags": "Reserved for future use.",
  "VkInstanceCreateInfo.pApplicationInfo": "Null or an instance of ApplicationInfo. If not Null, this information helps implementations recognize behavior inherent to classes of applications. ApplicationInfo is defined in detail below.",
  "VkInstanceCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkInstanceCreateInfo.ppEnabledExtensionNames": "An array of enabledExtensionCount strings containing the names of extensions to enable.",
  "VkInstanceCreateInfo.ppEnabledLayerNames": "An array of enabledLayerCount strings containing the names of layers to enable for the created instance. See the Layers section for further details.",
  "VkInstanceCreateInfo.sType": "The type of this structure.",
  "VkInternalAllocationType": "Allocation type.",
  "VkInternalAllocationType.VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE": "VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE - The allocation is intended for execution by the host.",
  "vkInvalidateMappedMemoryRanges": "Invalidate ranges of mapped memory objects.",
  "vkInvalidateMappedMemoryRanges.device": "",
  "vkInvalidateMappedMemoryRanges.memoryRangeCount": "",
  "vkInvalidateMappedMemoryRanges.pMemoryRanges": "",
  "VkIOSSurfaceCreateFlagsMVK": "",
  "VkIOSSurfaceCreateFlagsMVK.__none": "",
  "VkIOSSurfaceCreateInfoMVK": "Structure specifying parameters of a newly created iOS surface object.",
  "VkIOSSurfaceCreateInfoMVK.flags": "Reserved for future use.",
  "VkIOSSurfaceCreateInfoMVK.pNext": "Null or an extension-specific structure.",
  "VkIOSSurfaceCreateInfoMVK.pView": "A reference to a UIView object which will display this surface. This UIView must be backed by a CALayer instance of type CAMetalLayer.",
  "VkIOSSurfaceCreateInfoMVK.sType": "The type of this structure.",
  "VkLayerProperties": "Structure specifying layer properties.",
  "VkLayerProperties.description": "A string providing additional details that can be used by the application to identify the layer.",
  "VkLayerProperties.implementationVersion": "The version of this layer. It is an integer, increasing with backward compatible changes.",
  "VkLayerProperties.layerName": "A string specifying the name of the layer. Use this name in the ppEnabledLayerNames array passed in the InstanceCreateInfo structure to enable this layer for an instance.",
  "VkLayerProperties.specVersion": "The Vulkan version the layer was written to, encoded as described in the API Version Numbers and Semantics section.",
  "VkLogicOp": "Framebuffer logical operations.",
  "VkLogicOp.VK_LOGIC_OP_AND": "",
  "VkLogicOp.VK_LOGIC_OP_AND_INVERTED": "",
  "VkLogicOp.VK_LOGIC_OP_AND_REVERSE": "",
  "VkLogicOp.VK_LOGIC_OP_CLEAR": "",
  "VkLogicOp.VK_LOGIC_OP_COPY": "",
  "VkLogicOp.VK_LOGIC_OP_COPY_INVERTED": "",
  "VkLogicOp.VK_LOGIC_OP_EQUIVALENT": "",
  "VkLogicOp.VK_LOGIC_OP_INVERT": "",
  "VkLogicOp.VK_LOGIC_OP_NAND": "",
  "VkLogicOp.VK_LOGIC_OP_NO_OP": "",
  "VkLogicOp.VK_LOGIC_OP_NOR": "",
  "VkLogicOp.VK_LOGIC_OP_OR": "",
  "VkLogicOp.VK_LOGIC_OP_OR_INVERTED": "",
  "VkLogicOp.VK_LOGIC_OP_OR_REVERSE": "",
  "VkLogicOp.VK_LOGIC_OP_SET": "",
  "VkLogicOp.VK_LOGIC_OP_XOR": "",
  "VkMacOSSurfaceCreateFlagsMVK": "",
  "VkMacOSSurfaceCreateFlagsMVK.__none": "",
  "VkMacOSSurfaceCreateInfoMVK": "Structure specifying parameters of a newly created macOS surface object.",
  "VkMacOSSurfaceCreateInfoMVK.flags": "Reserved for future use.",
  "VkMacOSSurfaceCreateInfoMVK.pNext": "Null or an extension-specific structure.",
  "VkMacOSSurfaceCreateInfoMVK.pView": "A reference to a NSView object which will display this surface. This NSView must be backed by a CALayer instance of type CAMetalLayer.",
  "VkMacOSSurfaceCreateInfoMVK.sType": "The type of this structure.",
  "vkMapMemory": "Map a memory object into application address space.",
  "vkMapMemory.device": "",
  "vkMapMemory.flags": "",
  "vkMapMemory.memory": "",
  "vkMapMemory.offset": "",
  "vkMapMemory.ppData": "",
  "vkMapMemory.size": "",
  "VkMappedMemoryRange": "Structure specifying a mapped memory range.",
  "VkMappedMemoryRange.memory": "The memory object to which this range belongs.",
  "VkMappedMemoryRange.offset": "The zero-based byte offset from the beginning of the memory object.",
  "VkMappedMemoryRange.pNext": "Null or an extension-specific structure.",
  "VkMappedMemoryRange.size": "size is either the size of range, or VK_WHOLE_SIZE to affect the range from offset to the end of the current mapping of the allocation.",
  "VkMappedMemoryRange.sType": "The type of this structure.",
  "VkMemoryAllocateFlagBitsKHX": "Bitmask specifying flags for a device memory allocation.",
  "VkMemoryAllocateFlagBitsKHX.__none": "",
  "VkMemoryAllocateFlagBitsKHX.VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHX": "",
  "VkMemoryAllocateFlagsInfoKHX": "",
  "VkMemoryAllocateFlagsInfoKHX.deviceMask": "",
  "VkMemoryAllocateFlagsInfoKHX.flags": "",
  "VkMemoryAllocateFlagsInfoKHX.pNext": "",
  "VkMemoryAllocateFlagsInfoKHX.sType": "",
  "VkMemoryAllocateFlagsKHX": "",
  "VkMemoryAllocateInfo": "Structure containing parameters of a memory allocation.",
  "VkMemoryAllocateInfo.allocationSize": "The size of the allocation in bytes",
  "VkMemoryAllocateInfo.memoryTypeIndex": "The memory type index, which selects the properties of the memory to be allocated, as well as the heap the memory will come from.",
  "VkMemoryAllocateInfo.pNext": "Null or an extension-specific structure.",
  "VkMemoryAllocateInfo.sType": "The type of this structure.",
  "VkMemoryBarrier": "Structure specifying a global memory barrier.",
  "VkMemoryBarrier.dstAccessMask": "dstAccessMask defines a destination access mask.",
  "VkMemoryBarrier.pNext": "Null or an extension-specific structure.",
  "VkMemoryBarrier.srcAccessMask": "srcAccessMask defines a source access mask.",
  "VkMemoryBarrier.sType": "The type of this structure.",
  "VkMemoryDedicatedAllocateInfoKHR": "",
  "VkMemoryDedicatedAllocateInfoKHR.buffer": "",
  "VkMemoryDedicatedAllocateInfoKHR.image": "",
  "VkMemoryDedicatedAllocateInfoKHR.pNext": "",
  "VkMemoryDedicatedAllocateInfoKHR.sType": "",
  "VkMemoryDedicatedRequirementsKHR": "",
  "VkMemoryDedicatedRequirementsKHR.pNext": "",
  "VkMemoryDedicatedRequirementsKHR.prefersDedicatedAllocation": "",
  "VkMemoryDedicatedRequirementsKHR.requiresDedicatedAllocation": "",
  "VkMemoryDedicatedRequirementsKHR.sType": "",
  "VkMemoryFdPropertiesKHR": "",
  "VkMemoryFdPropertiesKHR.memoryTypeBits": "",
  "VkMemoryFdPropertiesKHR.pNext": "",
  "VkMemoryFdPropertiesKHR.sType": "",
  "VkMemoryGetFdInfoKHR": "",
  "VkMemoryGetFdInfoKHR.handleType": "",
  "VkMemoryGetFdInfoKHR.memory": "",
  "VkMemoryGetFdInfoKHR.pNext": "",
  "VkMemoryGetFdInfoKHR.sType": "",
  "VkMemoryGetWin32HandleInfoKHR": "",
  "VkMemoryGetWin32HandleInfoKHR.handleType": "",
  "VkMemoryGetWin32HandleInfoKHR.memory": "",
  "VkMemoryGetWin32HandleInfoKHR.pNext": "",
  "VkMemoryGetWin32HandleInfoKHR.sType": "",
  "VkMemoryHeap": "Structure specifying a memory heap.",
  "VkMemoryHeap.flags": "A bitmask of attribute flags for the heap. The bits specified in flags are: + --",
  "VkMemoryHeap.size": "The total memory size in bytes in the heap.",
  "VkMemoryHeapFlagBits": "Bitmask specifying attribute flags for a heap.",
  "VkMemoryHeapFlagBits.__none": "",
  "VkMemoryHeapFlagBits.VK_MEMORY_HEAP_DEVICE_LOCAL_BIT": "",
  "VkMemoryHeapFlagBits.VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHX": "",
  "VkMemoryHeapFlags": "",
  "VkMemoryHostPointerPropertiesEXT": "",
  "VkMemoryHostPointerPropertiesEXT.memoryTypeBits": "",
  "VkMemoryHostPointerPropertiesEXT.pNext": "",
  "VkMemoryHostPointerPropertiesEXT.sType": "",
  "VkMemoryMapFlags": "",
  "VkMemoryMapFlags.__none": "",
  "VkMemoryPropertyFlagBits": "Bitmask specifying properties for a memory type.",
  "VkMemoryPropertyFlagBits.__none": "",
  "VkMemoryPropertyFlagBits.VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT": "",
  "VkMemoryPropertyFlagBits.VK_MEMORY_PROPERTY_HOST_CACHED_BIT": "",
  "VkMemoryPropertyFlagBits.VK_MEMORY_PROPERTY_HOST_COHERENT_BIT": "",
  "VkMemoryPropertyFlagBits.VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT": "",
  "VkMemoryPropertyFlagBits.VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT": "",
  "VkMemoryPropertyFlags": "",
  "VkMemoryRequirements": "Structure specifying memory requirements.",
  "VkMemoryRequirements.alignment": "The alignment, in bytes, of the offset within the allocation required: for the resource.",
  "VkMemoryRequirements.memoryTypeBits": "A bitmask and contains one bit set for every supported memory type for the resource. Bit `i` is set if and only if the memory type `i` in the PhysicalDeviceMemoryProperties structure for the physical device is supported for the resource.",
  "VkMemoryRequirements.size": "The size, in bytes, of the memory allocation required: for the resource.",
  "VkMemoryRequirements2KHR": "",
  "VkMemoryRequirements2KHR.memoryRequirements": "",
  "VkMemoryRequirements2KHR.pNext": "",
  "VkMemoryRequirements2KHR.sType": "",
  "VkMemoryType": "Structure specifying memory type.",
  "VkMemoryType.heapIndex": "heapIndex describes which memory heap this memory type corresponds to, and must be less than memoryHeapCount from the PhysicalDeviceMemoryProperties structure.",
  "VkMemoryType.propertyFlags": "A bitmask of properties for this memory type. The bits specified in propertyFlags are: + --",
  "VkMemoryWin32HandlePropertiesKHR": "",
  "VkMemoryWin32HandlePropertiesKHR.memoryTypeBits": "",
  "VkMemoryWin32HandlePropertiesKHR.pNext": "",
  "VkMemoryWin32HandlePropertiesKHR.sType": "",
  "vkMergePipelineCaches": "Combine the data stores of pipeline caches.",
  "vkMergePipelineCaches.device": "",
  "vkMergePipelineCaches.dstCache": "",
  "vkMergePipelineCaches.pSrcCaches": "",
  "vkMergePipelineCaches.srcCacheCount": "",
  "vkMergeValidationCachesEXT": "",
  "vkMergeValidationCachesEXT.device": "",
  "vkMergeValidationCachesEXT.dstCache": "",
  "vkMergeValidationCachesEXT.pSrcCaches": "",
  "vkMergeValidationCachesEXT.srcCacheCount": "",
  "VkMirSurfaceCreateFlagsKHR": "",
  "VkMirSurfaceCreateFlagsKHR.__none": "",
  "VkMirSurfaceCreateInfoKHR": "Structure specifying parameters of a newly created Mir surface object.",
  "VkMirSurfaceCreateInfoKHR.connection": "connection and surface are pointers to the MirConnection and MirSurface for the window to associate the surface with.",
  "VkMirSurfaceCreateInfoKHR.flags": "Reserved for future use.",
  "VkMirSurfaceCreateInfoKHR.mirSurface": "",
  "VkMirSurfaceCreateInfoKHR.pNext": "Null or an extension-specific structure.",
  "VkMirSurfaceCreateInfoKHR.sType": "The type of this structure.",
  "VkMultisamplePropertiesEXT": "",
  "VkMultisamplePropertiesEXT.maxSampleLocationGridSize": "",
  "VkMultisamplePropertiesEXT.pNext": "",
  "VkMultisamplePropertiesEXT.sType": "",
  "VkNativeBufferANDROID": "",
  "VkNativeBufferANDROID.format": "",
  "VkNativeBufferANDROID.handle": "",
  "VkNativeBufferANDROID.pNext": "",
  "VkNativeBufferANDROID.stride": "",
  "VkNativeBufferANDROID.sType": "",
  "VkNativeBufferANDROID.usage": "",
  "VkObjectEntryTypeNVX": "Enum specifying object table entry type.",
  "VkObjectEntryTypeNVX.VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX": "",
  "VkObjectEntryTypeNVX.VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX": "",
  "VkObjectEntryTypeNVX.VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX": "",
  "VkObjectEntryTypeNVX.VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX": "",
  "VkObjectEntryTypeNVX.VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX": "",
  "VkObjectEntryUsageFlagBitsNVX": "Bitmask specifying allowed usage of an object entry.",
  "VkObjectEntryUsageFlagBitsNVX.__none": "",
  "VkObjectEntryUsageFlagBitsNVX.VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX": "Indicates that the resource is bound to VK_PIPELINE_BIND_POINT_COMPUTE",
  "VkObjectEntryUsageFlagBitsNVX.VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX": "Indicates that the resource is bound to VK_PIPELINE_BIND_POINT_GRAPHICS",
  "VkObjectEntryUsageFlagsNVX": "",
  "VkObjectTableCreateInfoNVX": "Structure specifying the parameters of a newly created object table.",
  "VkObjectTableCreateInfoNVX.maxPipelineLayouts": "The maximum number of unique PipelineLayout used by any registered DescriptorSet or Pipeline in this table.",
  "VkObjectTableCreateInfoNVX.maxSampledImagesPerDescriptor": "The maximum number of VK_DESCRIPTOR_TYPE_SAMPLER, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT used by any single registered DescriptorSet in this table.",
  "VkObjectTableCreateInfoNVX.maxStorageBuffersPerDescriptor": "The maximum number of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC used by any single registered DescriptorSet in this table.",
  "VkObjectTableCreateInfoNVX.maxStorageImagesPerDescriptor": "The maximum number of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE or VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER used by any single registered DescriptorSet in this table.",
  "VkObjectTableCreateInfoNVX.maxUniformBuffersPerDescriptor": "The maximum number of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC used by any single registered DescriptorSet in this table.",
  "VkObjectTableCreateInfoNVX.objectCount": "The number of entry configurations that the object table supports. The following array parameters must match the size provided here.",
  "VkObjectTableCreateInfoNVX.pNext": "Null or an extension-specific structure.",
  "VkObjectTableCreateInfoNVX.pObjectEntryCounts": "An array of counts how many objects can be registered in the table.",
  "VkObjectTableCreateInfoNVX.pObjectEntryTypes": "An array of ObjectEntryTypeNVX providing the entry type of a given configuration.",
  "VkObjectTableCreateInfoNVX.pObjectEntryUsageFlags": "An array of bitmasks describing the binding usage of the entry. See ObjectEntryUsageFlagBitsNVX below for a description of the supported bits.",
  "VkObjectTableCreateInfoNVX.sType": "The type of this structure.",
  "VkObjectTableDescriptorSetEntryNVX": "",
  "VkObjectTableDescriptorSetEntryNVX.descriptorSet": "",
  "VkObjectTableDescriptorSetEntryNVX.flags": "",
  "VkObjectTableDescriptorSetEntryNVX.pipelineLayout": "",
  "VkObjectTableDescriptorSetEntryNVX.type": "",
  "VkObjectTableEntryNVX": "",
  "VkObjectTableEntryNVX.flags": "",
  "VkObjectTableEntryNVX.type": "",
  "VkObjectTableIndexBufferEntryNVX": "",
  "VkObjectTableIndexBufferEntryNVX.buffer": "",
  "VkObjectTableIndexBufferEntryNVX.flags": "",
  "VkObjectTableIndexBufferEntryNVX.indexType": "",
  "VkObjectTableIndexBufferEntryNVX.type": "",
  "VkObjectTableNVX": "Opaque handle to an object table.",
  "VkObjectTablePipelineEntryNVX": "",
  "VkObjectTablePipelineEntryNVX.flags": "",
  "VkObjectTablePipelineEntryNVX.pipeline": "",
  "VkObjectTablePipelineEntryNVX.type": "",
  "VkObjectTablePushConstantEntryNVX": "",
  "VkObjectTablePushConstantEntryNVX.flags": "",
  "VkObjectTablePushConstantEntryNVX.pipelineLayout": "",
  "VkObjectTablePushConstantEntryNVX.stageFlags": "",
  "VkObjectTablePushConstantEntryNVX.type": "",
  "VkObjectTableVertexBufferEntryNVX": "",
  "VkObjectTableVertexBufferEntryNVX.buffer": "",
  "VkObjectTableVertexBufferEntryNVX.flags": "",
  "VkObjectTableVertexBufferEntryNVX.type": "",
  "VkObjectType": "",
  "VkObjectType.VK_OBJECT_TYPE_BUFFER": "",
  "VkObjectType.VK_OBJECT_TYPE_BUFFER_VIEW": "",
  "VkObjectType.VK_OBJECT_TYPE_COMMAND_BUFFER": "",
  "VkObjectType.VK_OBJECT_TYPE_COMMAND_POOL": "",
  "VkObjectType.VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT": "",
  "VkObjectType.VK_OBJECT_TYPE_DESCRIPTOR_POOL": "",
  "VkObjectType.VK_OBJECT_TYPE_DESCRIPTOR_SET": "",
  "VkObjectType.VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT": "",
  "VkObjectType.VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR": "",
  "VkObjectType.VK_OBJECT_TYPE_DEVICE": "",
  "VkObjectType.VK_OBJECT_TYPE_DEVICE_MEMORY": "",
  "VkObjectType.VK_OBJECT_TYPE_DISPLAY_KHR": "",
  "VkObjectType.VK_OBJECT_TYPE_DISPLAY_MODE_KHR": "",
  "VkObjectType.VK_OBJECT_TYPE_EVENT": "",
  "VkObjectType.VK_OBJECT_TYPE_FENCE": "",
  "VkObjectType.VK_OBJECT_TYPE_FRAMEBUFFER": "",
  "VkObjectType.VK_OBJECT_TYPE_IMAGE": "",
  "VkObjectType.VK_OBJECT_TYPE_IMAGE_VIEW": "",
  "VkObjectType.VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX": "",
  "VkObjectType.VK_OBJECT_TYPE_INSTANCE": "",
  "VkObjectType.VK_OBJECT_TYPE_OBJECT_TABLE_NVX": "",
  "VkObjectType.VK_OBJECT_TYPE_PHYSICAL_DEVICE": "",
  "VkObjectType.VK_OBJECT_TYPE_PIPELINE": "",
  "VkObjectType.VK_OBJECT_TYPE_PIPELINE_CACHE": "",
  "VkObjectType.VK_OBJECT_TYPE_PIPELINE_LAYOUT": "",
  "VkObjectType.VK_OBJECT_TYPE_QUERY_POOL": "",
  "VkObjectType.VK_OBJECT_TYPE_QUEUE": "",
  "VkObjectType.VK_OBJECT_TYPE_RENDER_PASS": "",
  "VkObjectType.VK_OBJECT_TYPE_SAMPLER": "",
  "VkObjectType.VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR": "",
  "VkObjectType.VK_OBJECT_TYPE_SEMAPHORE": "",
  "VkObjectType.VK_OBJECT_TYPE_SHADER_MODULE": "",
  "VkObjectType.VK_OBJECT_TYPE_SURFACE_KHR": "",
  "VkObjectType.VK_OBJECT_TYPE_SWAPCHAIN_KHR": "",
  "VkObjectType.VK_OBJECT_TYPE_UNKNOWN": "",
  "VkObjectType.VK_OBJECT_TYPE_VALIDATION_CACHE_EXT": "",
  "VkOffset2D": "Structure specifying a two-dimensional offset.",
  "VkOffset2D.x": "",
  "VkOffset2D.y": "",
  "VkOffset3D": "Structure specifying a three-dimensional offset.",
  "VkOffset3D.x": "",
  "VkOffset3D.y": "",
  "VkOffset3D.z": "",
  "VkPastPresentationTimingGOOGLE": "",
  "VkPastPresentationTimingGOOGLE.actualPresentTime": "",
  "VkPastPresentationTimingGOOGLE.desiredPresentTime": "",
  "VkPastPresentationTimingGOOGLE.earliestPresentTime": "",
  "VkPastPresentationTimingGOOGLE.presentID": "",
  "VkPastPresentationTimingGOOGLE.presentMargin": "",
  "VkPeerMemoryFeatureFlagBitsKHX": "Bitmask specifying supported peer memory features.",
  "VkPeerMemoryFeatureFlagBitsKHX.__none": "",
  "VkPeerMemoryFeatureFlagBitsKHX.VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHX": "",
  "VkPeerMemoryFeatureFlagBitsKHX.VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHX": "",
  "VkPeerMemoryFeatureFlagBitsKHX.VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHX": "",
  "VkPeerMemoryFeatureFlagBitsKHX.VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHX": "",
  "VkPeerMemoryFeatureFlagsKHX": "",
  "VkPhysicalDevice": "Opaque handle to a physical device object.",
  "VkPhysicalDevice16BitStorageFeaturesKHR": "",
  "VkPhysicalDevice16BitStorageFeaturesKHR.pNext": "",
  "VkPhysicalDevice16BitStorageFeaturesKHR.storageBuffer16BitAccess": "",
  "VkPhysicalDevice16BitStorageFeaturesKHR.storageInputOutput16": "",
  "VkPhysicalDevice16BitStorageFeaturesKHR.storagePushConstant16": "",
  "VkPhysicalDevice16BitStorageFeaturesKHR.sType": "",
  "VkPhysicalDevice16BitStorageFeaturesKHR.uniformAndStorageBuffer16BitAccess": "",
  "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT": "",
  "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.advancedBlendCoherentOperations": "",
  "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.pNext": "",
  "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.sType": "",
  "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT": "",
  "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.advancedBlendAllOperations": "",
  "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.advancedBlendCorrelatedOverlap": "",
  "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.advancedBlendIndependentBlend": "",
  "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.advancedBlendMaxColorAttachments": "",
  "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.advancedBlendNonPremultipliedDstColor": "",
  "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.advancedBlendNonPremultipliedSrcColor": "",
  "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.pNext": "",
  "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.sType": "",
  "VkPhysicalDeviceConservativeRasterizationPropertiesEXT": "",
  "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.conservativePointAndLineRasterization": "",
  "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.conservativeRasterizationPostDepthCoverage": "",
  "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.degenerateLinesRasterized": "",
  "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.degenerateTrianglesRasterized": "",
  "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.extraPrimitiveOverestimationSizeGranularity": "",
  "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.fullyCoveredFragmentShaderInputVariable": "",
  "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.maxExtraPrimitiveOverestimationSize": "",
  "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.pNext": "",
  "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.primitiveOverestimationSize": "",
  "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.primitiveUnderestimation": "",
  "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.sType": "",
  "VkPhysicalDeviceDiscardRectanglePropertiesEXT": "",
  "VkPhysicalDeviceDiscardRectanglePropertiesEXT.maxDiscardRectangles": "",
  "VkPhysicalDeviceDiscardRectanglePropertiesEXT.pNext": "",
  "VkPhysicalDeviceDiscardRectanglePropertiesEXT.sType": "",
  "VkPhysicalDeviceExternalBufferInfoKHR": "",
  "VkPhysicalDeviceExternalBufferInfoKHR.flags": "",
  "VkPhysicalDeviceExternalBufferInfoKHR.handleType": "",
  "VkPhysicalDeviceExternalBufferInfoKHR.pNext": "",
  "VkPhysicalDeviceExternalBufferInfoKHR.sType": "",
  "VkPhysicalDeviceExternalBufferInfoKHR.usage": "",
  "VkPhysicalDeviceExternalFenceInfoKHR": "",
  "VkPhysicalDeviceExternalFenceInfoKHR.handleType": "",
  "VkPhysicalDeviceExternalFenceInfoKHR.pNext": "",
  "VkPhysicalDeviceExternalFenceInfoKHR.sType": "",
  "VkPhysicalDeviceExternalImageFormatInfoKHR": "",
  "VkPhysicalDeviceExternalImageFormatInfoKHR.handleType": "",
  "VkPhysicalDeviceExternalImageFormatInfoKHR.pNext": "",
  "VkPhysicalDeviceExternalImageFormatInfoKHR.sType": "",
  "VkPhysicalDeviceExternalMemoryHostPropertiesEXT": "",
  "VkPhysicalDeviceExternalMemoryHostPropertiesEXT.minImportedHostPointerAlignment": "",
  "VkPhysicalDeviceExternalMemoryHostPropertiesEXT.pNext": "",
  "VkPhysicalDeviceExternalMemoryHostPropertiesEXT.sType": "",
  "VkPhysicalDeviceExternalSemaphoreInfoKHR": "",
  "VkPhysicalDeviceExternalSemaphoreInfoKHR.handleType": "",
  "VkPhysicalDeviceExternalSemaphoreInfoKHR.pNext": "",
  "VkPhysicalDeviceExternalSemaphoreInfoKHR.sType": "",
  "VkPhysicalDeviceFeatures": "Structure describing the fine-grained features that can be supported by an implementation.",
  "VkPhysicalDeviceFeatures.alphaToOne": "",
  "VkPhysicalDeviceFeatures.depthBiasClamp": "",
  "VkPhysicalDeviceFeatures.depthBounds": "",
  "VkPhysicalDeviceFeatures.depthClamp": "",
  "VkPhysicalDeviceFeatures.drawIndirectFirstInstance": "",
  "VkPhysicalDeviceFeatures.dualSrcBlend": "",
  "VkPhysicalDeviceFeatures.fillModeNonSolid": "",
  "VkPhysicalDeviceFeatures.fragmentStoresAndAtomics": "",
  "VkPhysicalDeviceFeatures.fullDrawIndexUint32": "",
  "VkPhysicalDeviceFeatures.geometryShader": "",
  "VkPhysicalDeviceFeatures.imageCubeArray": "",
  "VkPhysicalDeviceFeatures.independentBlend": "",
  "VkPhysicalDeviceFeatures.inheritedQueries": "",
  "VkPhysicalDeviceFeatures.largePoints": "",
  "VkPhysicalDeviceFeatures.logicOp": "",
  "VkPhysicalDeviceFeatures.multiDrawIndirect": "",
  "VkPhysicalDeviceFeatures.multiViewport": "",
  "VkPhysicalDeviceFeatures.occlusionQueryPrecise": "",
  "VkPhysicalDeviceFeatures.pipelineStatisticsQuery": "",
  "VkPhysicalDeviceFeatures.robustBufferAccess": "",
  "VkPhysicalDeviceFeatures.samplerAnisotropy": "",
  "VkPhysicalDeviceFeatures.sampleRateShading": "",
  "VkPhysicalDeviceFeatures.shaderClipDistance": "",
  "VkPhysicalDeviceFeatures.shaderCullDistance": "",
  "VkPhysicalDeviceFeatures.shaderFloat64": "",
  "VkPhysicalDeviceFeatures.shaderImageGatherExtended": "",
  "VkPhysicalDeviceFeatures.shaderInt16": "",
  "VkPhysicalDeviceFeatures.shaderInt64": "",
  "VkPhysicalDeviceFeatures.shaderResourceMinLod": "",
  "VkPhysicalDeviceFeatures.shaderResourceResidency": "",
  "VkPhysicalDeviceFeatures.shaderSampledImageArrayDynamicIndexing": "",
  "VkPhysicalDeviceFeatures.shaderStorageBufferArrayDynamicIndexing": "",
  "VkPhysicalDeviceFeatures.shaderStorageImageArrayDynamicIndexing": "",
  "VkPhysicalDeviceFeatures.shaderStorageImageExtendedFormats": "",
  "VkPhysicalDeviceFeatures.shaderStorageImageMultisample": "",
  "VkPhysicalDeviceFeatures.shaderStorageImageReadWithoutFormat": "",
  "VkPhysicalDeviceFeatures.shaderStorageImageWriteWithoutFormat": "",
  "VkPhysicalDeviceFeatures.shaderTessellationAndGeometryPointSize": "",
  "VkPhysicalDeviceFeatures.shaderUniformBufferArrayDynamicIndexing": "",
  "VkPhysicalDeviceFeatures.sparseBinding": "",
  "VkPhysicalDeviceFeatures.sparseResidency16Samples": "",
  "VkPhysicalDeviceFeatures.sparseResidency2Samples": "",
  "VkPhysicalDeviceFeatures.sparseResidency4Samples": "",
  "VkPhysicalDeviceFeatures.sparseResidency8Samples": "",
  "VkPhysicalDeviceFeatures.sparseResidencyAliased": "",
  "VkPhysicalDeviceFeatures.sparseResidencyBuffer": "",
  "VkPhysicalDeviceFeatures.sparseResidencyImage2D": "",
  "VkPhysicalDeviceFeatures.sparseResidencyImage3D": "",
  "VkPhysicalDeviceFeatures.tessellationShader": "",
  "VkPhysicalDeviceFeatures.textureCompressionASTC_LDR": "",
  "VkPhysicalDeviceFeatures.textureCompressionBC": "",
  "VkPhysicalDeviceFeatures.textureCompressionETC2": "",
  "VkPhysicalDeviceFeatures.variableMultisampleRate": "",
  "VkPhysicalDeviceFeatures.vertexPipelineStoresAndAtomics": "",
  "VkPhysicalDeviceFeatures.wideLines": "",
  "VkPhysicalDeviceFeatures2KHR": "Structure describing the fine-grained features that can be supported by an implementation.",
  "VkPhysicalDeviceFeatures2KHR.features": "A structure of type PhysicalDeviceFeatures describing the fine-grained features of the Vulkan 1.0 API.",
  "VkPhysicalDeviceFeatures2KHR.pNext": "Null or an extension-specific structure.",
  "VkPhysicalDeviceFeatures2KHR.sType": "The type of this structure.",
  "VkPhysicalDeviceGroupPropertiesKHX": "Structure specifying physical device group properties.",
  "VkPhysicalDeviceGroupPropertiesKHX.physicalDeviceCount": "The number of physical devices in the group.",
  "VkPhysicalDeviceGroupPropertiesKHX.physicalDevices": "An array of physical device handles representing all physical devices in the group. The first physicalDeviceCount elements of the array will be valid.",
  "VkPhysicalDeviceGroupPropertiesKHX.pNext": "Null or an extension-specific structure.",
  "VkPhysicalDeviceGroupPropertiesKHX.sType": "The type of this structure.",
  "VkPhysicalDeviceGroupPropertiesKHX.subsetAllocation": "Indicates whether logical devices created from the group support allocating device memory on a subset of devices, via the deviceMask member of the MemoryAllocateFlagsInfoKHX. If this is VK_FALSE, then all device memory allocations are made across all physical devices in the group. If physicalDeviceCount is `1`, then subsetAllocation must be VK_FALSE.",
  "VkPhysicalDeviceIDPropertiesKHR": "",
  "VkPhysicalDeviceIDPropertiesKHR.deviceLUID": "",
  "VkPhysicalDeviceIDPropertiesKHR.deviceLUIDValid": "",
  "VkPhysicalDeviceIDPropertiesKHR.deviceNodeMask": "",
  "VkPhysicalDeviceIDPropertiesKHR.deviceUUID": "",
  "VkPhysicalDeviceIDPropertiesKHR.driverUUID": "",
  "VkPhysicalDeviceIDPropertiesKHR.pNext": "",
  "VkPhysicalDeviceIDPropertiesKHR.sType": "",
  "VkPhysicalDeviceImageFormatInfo2KHR": "Structure specifying image creation parameters.",
  "VkPhysicalDeviceImageFormatInfo2KHR.flags": "A bitmask describing additional parameters of the image, corresponding to ImageCreateInfo::flags.",
  "VkPhysicalDeviceImageFormatInfo2KHR.format": "The image format, corresponding to ImageCreateInfo::format.",
  "VkPhysicalDeviceImageFormatInfo2KHR.pNext": "Null or an extension-specific structure.",
  "VkPhysicalDeviceImageFormatInfo2KHR.sType": "The type of this structure.",
  "VkPhysicalDeviceImageFormatInfo2KHR.tiling": "The image tiling, corresponding to ImageCreateInfo::tiling.",
  "VkPhysicalDeviceImageFormatInfo2KHR.type": "The image type, corresponding to ImageCreateInfo::imageType.",
  "VkPhysicalDeviceImageFormatInfo2KHR.usage": "The intended usage of the image, corresponding to ImageCreateInfo::usage.",
  "VkPhysicalDeviceLimits": "Structure reporting implementation-dependent physical device limits.",
  "VkPhysicalDeviceLimits.bufferImageGranularity": "The granularity, in bytes, at which buffer or linear image resources, and optimal image resources can be bound to adjacent offsets in the same DeviceMemory object without aliasing. See Buffer-Image Granularity for more details.",
  "VkPhysicalDeviceLimits.discreteQueuePriorities": " discreteQueuePriorities is the number of discrete priorities that can be assigned to a queue based on the value of each member of DeviceQueueCreateInfo::pQueuePriorities. This must be at least 2, and levels must be spread evenly over the range, with at least one level at 1.0, and another at 0.0. See <<devsandqueues-priority.",
  "VkPhysicalDeviceLimits.framebufferColorSampleCounts": " framebufferColorSampleCounts is a bitmask^1^ of SampleCountFlagBits bits indicating the color sample counts that are supported for all framebuffer color attachments.",
  "VkPhysicalDeviceLimits.framebufferDepthSampleCounts": " framebufferDepthSampleCounts is a bitmask^1^ of SampleCountFlagBits bits indicating the supported depth sample counts for all framebuffer depth/stencil attachments, when the format includes a depth component.",
  "VkPhysicalDeviceLimits.framebufferNoAttachmentsSampleCounts": "A bitmask^1^ of SampleCountFlagBits bits indicating the supported sample counts for a framebuffer with no attachments.",
  "VkPhysicalDeviceLimits.framebufferStencilSampleCounts": "A bitmask^1^ of SampleCountFlagBits bits indicating the supported stencil sample counts for all framebuffer depth/stencil attachments, when the format includes a stencil component.",
  "VkPhysicalDeviceLimits.lineWidthGranularity": "The granularity of supported line widths. Not all line widths in the range defined by lineWidthRange are supported. This limit specifies the granularity (or increment) between successive supported line widths.",
  "VkPhysicalDeviceLimits.lineWidthRange": "lineWidthRange[2] is the range [eq]#[minimum,maximum]# of supported widths for lines. Values specified by the lineWidth member of the PipelineRasterizationStateCreateInfo or the lineWidth parameter to fname:vkCmdSetLineWidth are clamped to this range.",
  "VkPhysicalDeviceLimits.maxBoundDescriptorSets": "The maximum number of descriptor sets that can be simultaneously used by a pipeline. All DescriptorSet decorations in shader modules must have a value less than maxBoundDescriptorSets. See <<descriptorsets-sets.",
  "VkPhysicalDeviceLimits.maxClipDistances": "The maximum number of clip distances that can be used in a single shader stage. The size of any array declared with the ClipDistance built-in decoration in a shader module must be less than or equal to this limit.",
  "VkPhysicalDeviceLimits.maxColorAttachments": "The maximum number of color attachments that can be used by a subpass in a render pass. The colorAttachmentCount member of the SubpassDescription structure must be less than or equal to this limit.",
  "VkPhysicalDeviceLimits.maxCombinedClipAndCullDistances": " maxCombinedClipAndCullDistances is the maximum combined number of clip and cull distances that can be used in a single shader stage. The sum of the sizes of any pair of arrays declared with the ClipDistance and CullDistance built-in decoration used by a single shader stage in a shader module must be less than or equal to this limit.",
  "VkPhysicalDeviceLimits.maxComputeSharedMemorySize": " maxComputeSharedMemorySize is the maximum total storage size, in bytes, of all variables declared with the WorkgroupLocal storage class in shader modules (or with the shared storage qualifier in GLSL) in the compute shader stage.",
  "VkPhysicalDeviceLimits.maxComputeWorkGroupCount": " maxComputeWorkGroupCount[3] is the maximum number of local workgroups that can be dispatched by a single dispatch command. These three values represent the maximum number of local workgroups for the X, Y, and Z dimensions, respectively. The workgroup count parameters to the dispatch commands must be less than or equal to the corresponding limit. See <<dispatch.",
  "VkPhysicalDeviceLimits.maxComputeWorkGroupInvocations": " maxComputeWorkGroupInvocations is the maximum total number of compute shader invocations in a single local workgroup. The product of the X, Y, and Z sizes as specified by the LocalSize execution mode in shader modules and by the object decorated by the WorkgroupSize decoration must be less than or equal to this limit.",
  "VkPhysicalDeviceLimits.maxComputeWorkGroupSize": " maxComputeWorkGroupSize[3] is the maximum size of a local compute workgroup, per dimension. These three values represent the maximum local workgroup size in the X, Y, and Z dimensions, respectively. The x, y, and z sizes specified by the LocalSize execution mode and by the object decorated by the WorkgroupSize decoration in shader modules must be less than or equal to the corresponding limit.",
  "VkPhysicalDeviceLimits.maxCullDistances": "The maximum number of cull distances that can be used in a single shader stage. The size of any array declared with the CullDistance built-in decoration in a shader module must be less than or equal to this limit.",
  "VkPhysicalDeviceLimits.maxDescriptorSetInputAttachments": " maxDescriptorSetInputAttachments is the maximum number of input attachments that can be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit. See <<descriptorsets-inputattachment.",
  "VkPhysicalDeviceLimits.maxDescriptorSetSampledImages": " maxDescriptorSetSampledImages is the maximum number of sampled images that can be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, or VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER count against this limit. See <<descriptorsets-combinedimagesampler, <<descriptorsets-sampledimage, and <<descriptorsets-uniformtexelbuffer.",
  "VkPhysicalDeviceLimits.maxDescriptorSetSamplers": " maxDescriptorSetSamplers is the maximum number of samplers that can be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of VK_DESCRIPTOR_TYPE_SAMPLER or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER count against this limit. See <<descriptorsets-sampler and <<descriptorsets-combinedimagesampler.",
  "VkPhysicalDeviceLimits.maxDescriptorSetStorageBuffers": " maxDescriptorSetStorageBuffers is the maximum number of storage buffers that can be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this limit. See <<descriptorsets-storagebuffer and <<descriptorsets-storagebufferdynamic.",
  "VkPhysicalDeviceLimits.maxDescriptorSetStorageBuffersDynamic": " maxDescriptorSetStorageBuffersDynamic is the maximum number of dynamic storage buffers that can be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this limit. See <<descriptorsets-storagebufferdynamic.",
  "VkPhysicalDeviceLimits.maxDescriptorSetStorageImages": " maxDescriptorSetStorageImages is the maximum number of storage images that can be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER count against this limit. See <<descriptorsets-storageimage, and <<descriptorsets-storagetexelbuffer.",
  "VkPhysicalDeviceLimits.maxDescriptorSetUniformBuffers": " maxDescriptorSetUniformBuffers is the maximum number of uniform buffers that can be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this limit. See <<descriptorsets-uniformbuffer and <<descriptorsets-uniformbufferdynamic.",
  "VkPhysicalDeviceLimits.maxDescriptorSetUniformBuffersDynamic": " maxDescriptorSetUniformBuffersDynamic is the maximum number of dynamic uniform buffers that can be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this limit. See <<descriptorsets-uniformbufferdynamic.",
  "VkPhysicalDeviceLimits.maxDrawIndexedIndexValue": " maxDrawIndexedIndexValue is the maximum index value that can be used for indexed draw calls when using 32-bit indices. This excludes the primitive restart index value of 0xFFFFFFFF. See fullDrawIndexUint32.",
  "VkPhysicalDeviceLimits.maxDrawIndirectCount": "The maximum draw count that is supported for indirect draw calls. See multiDrawIndirect.",
  "VkPhysicalDeviceLimits.maxFragmentCombinedOutputResources": " maxFragmentCombinedOutputResources is the total number of storage buffers, storage images, and output buffers which can be used in the fragment shader stage.",
  "VkPhysicalDeviceLimits.maxFragmentDualSrcAttachments": " maxFragmentDualSrcAttachments is the maximum number of output attachments which can be written to by the fragment shader stage when blending is enabled and one of the dual source blend modes is in use. See <<framebuffer-dsb and dualSrcBlend.",
  "VkPhysicalDeviceLimits.maxFragmentInputComponents": " maxFragmentInputComponents is the maximum number of components of input variables which can be provided as inputs to the fragment shader stage.",
  "VkPhysicalDeviceLimits.maxFragmentOutputAttachments": " maxFragmentOutputAttachments is the maximum number of output attachments which can be written to by the fragment shader stage.",
  "VkPhysicalDeviceLimits.maxFramebufferHeight": "The maximum height for a framebuffer. The height member of the FramebufferCreateInfo structure must be less than or equal to this limit.",
  "VkPhysicalDeviceLimits.maxFramebufferLayers": "The maximum layer count for a layered framebuffer. The layers member of the FramebufferCreateInfo structure must be less than or equal to this limit.",
  "VkPhysicalDeviceLimits.maxFramebufferWidth": "The maximum width for a framebuffer. The width member of the FramebufferCreateInfo structure must be less than or equal to this limit.",
  "VkPhysicalDeviceLimits.maxGeometryInputComponents": " maxGeometryInputComponents is the maximum number of components of input variables which can be provided as inputs to the geometry shader stage.",
  "VkPhysicalDeviceLimits.maxGeometryOutputComponents": " maxGeometryOutputComponents is the maximum number of components of output variables which can be output from the geometry shader stage.",
  "VkPhysicalDeviceLimits.maxGeometryOutputVertices": " maxGeometryOutputVertices is the maximum number of vertices which can be emitted by any geometry shader.",
  "VkPhysicalDeviceLimits.maxGeometryShaderInvocations": " maxGeometryShaderInvocations is the maximum invocation count supported for instanced geometry shaders. The value provided in the Invocations execution mode of shader modules must be less than or equal to this limit. See <<geometry.",
  "VkPhysicalDeviceLimits.maxGeometryTotalOutputComponents": " maxGeometryTotalOutputComponents is the maximum total number of components of output, across all emitted vertices, which can be output from the geometry shader stage.",
  "VkPhysicalDeviceLimits.maxImageArrayLayers": "The maximum number of layers (arrayLayers) for an image.",
  "VkPhysicalDeviceLimits.maxImageDimension1D": "The maximum dimension (width) of an image created with an imageType of VK_IMAGE_TYPE_1D.",
  "VkPhysicalDeviceLimits.maxImageDimension2D": "The maximum dimension (width or height) of an image created with an imageType of VK_IMAGE_TYPE_2D and without VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT set in flags.",
  "VkPhysicalDeviceLimits.maxImageDimension3D": "The maximum dimension (width, height, or depth) of an image created with an imageType of VK_IMAGE_TYPE_3D.",
  "VkPhysicalDeviceLimits.maxImageDimensionCube": "The maximum dimension (width or height) of an image created with an imageType of VK_IMAGE_TYPE_2D and with VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT set in flags.",
  "VkPhysicalDeviceLimits.maxInterpolationOffset": "The maximum positive offset value for the offset operand of the InterpolateAtOffset extended instruction.",
  "VkPhysicalDeviceLimits.maxMemoryAllocationCount": " maxMemoryAllocationCount is the maximum number of device memory allocations, as created by flink:vkAllocateMemory, which can simultaneously exist.",
  "VkPhysicalDeviceLimits.maxPerStageDescriptorInputAttachments": " maxPerStageDescriptorInputAttachments is the maximum number of input attachments that can be accessible to a single shader stage in a pipeline layout. Descriptors with a type of VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit. A descriptor is accessible to a pipeline shader stage when the stageFlags member of the DescriptorSetLayoutBinding structure has the bit for that shader stage set. These are only supported for the fragment stage. See <<descriptorsets-inputattachment.",
  "VkPhysicalDeviceLimits.maxPerStageDescriptorSampledImages": " maxPerStageDescriptorSampledImages is the maximum number of sampled images that can be accessible to a single shader stage in a pipeline layout. Descriptors with a type of VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, or VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER count against this limit. A descriptor is accessible to a pipeline shader stage when the stageFlags member of the DescriptorSetLayoutBinding structure has the bit for that shader stage set. See <<descriptorsets-combinedimagesampler, <<descriptorsets-sampledimage, and <<descriptorsets-uniformtexelbuffer.",
  "VkPhysicalDeviceLimits.maxPerStageDescriptorSamplers": " maxPerStageDescriptorSamplers is the maximum number of samplers that can be accessible to a single shader stage in a pipeline layout. Descriptors with a type of VK_DESCRIPTOR_TYPE_SAMPLER or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER count against this limit. A descriptor is accessible to a shader stage when the stageFlags member of the DescriptorSetLayoutBinding structure has the bit for that shader stage set. See <<descriptorsets-sampler and <<descriptorsets-combinedimagesampler.",
  "VkPhysicalDeviceLimits.maxPerStageDescriptorStorageBuffers": " maxPerStageDescriptorStorageBuffers is the maximum number of storage buffers that can be accessible to a single shader stage in a pipeline layout. Descriptors with a type of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this limit. A descriptor is accessible to a pipeline shader stage when the stageFlags member of the DescriptorSetLayoutBinding structure has the bit for that shader stage set. See <<descriptorsets-storagebuffer and <<descriptorsets-storagebufferdynamic.",
  "VkPhysicalDeviceLimits.maxPerStageDescriptorStorageImages": " maxPerStageDescriptorStorageImages is the maximum number of storage images that can be accessible to a single shader stage in a pipeline layout. Descriptors with a type of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER count against this limit. A descriptor is accessible to a pipeline shader stage when the stageFlags member of the DescriptorSetLayoutBinding structure has the bit for that shader stage set. See <<descriptorsets-storageimage, and <<descriptorsets-storagetexelbuffer.",
  "VkPhysicalDeviceLimits.maxPerStageDescriptorUniformBuffers": " maxPerStageDescriptorUniformBuffers is the maximum number of uniform buffers that can be accessible to a single shader stage in a pipeline layout. Descriptors with a type of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this limit. A descriptor is accessible to a shader stage when the stageFlags member of the DescriptorSetLayoutBinding structure has the bit for that shader stage set. See <<descriptorsets-uniformbuffer and <<descriptorsets-uniformbufferdynamic.",
  "VkPhysicalDeviceLimits.maxPerStageResources": "The maximum number of resources that can be accessible to a single shader stage in a pipeline layout. Descriptors with a type of VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit. For the fragment shader stage the framebuffer color attachments also count against this limit.",
  "VkPhysicalDeviceLimits.maxPushConstantsSize": "The maximum size, in bytes, of the pool of push constant memory. For each of the push constant ranges indicated by the pPushConstantRanges member of the PipelineLayoutCreateInfo structure, offset + size must be less than or equal to this limit.",
  "VkPhysicalDeviceLimits.maxSampleMaskWords": "The maximum number of array elements of a variable decorated with the SampleMask built-in decoration.",
  "VkPhysicalDeviceLimits.maxSamplerAllocationCount": " maxSamplerAllocationCount is the maximum number of sampler objects, as created by flink:vkCreateSampler, which can simultaneously exist on a device.",
  "VkPhysicalDeviceLimits.maxSamplerAnisotropy": "The maximum degree of sampler anisotropy. The maximum degree of anisotropic filtering used for an image sampling operation is the minimum of the maxAnisotropy member of the SamplerCreateInfo structure and this limit. See <<samplers-maxAnisotropy.",
  "VkPhysicalDeviceLimits.maxSamplerLodBias": "The maximum absolute sampler level of detail bias. The sum of the mipLodBias member of the SamplerCreateInfo structure and the Bias operand of image sampling operations in shader modules (or 0 if no Bias operand is provided to an image sampling operation) are clamped to the range [eq]#[-maxSamplerLodBias,+maxSamplerLodBias]#. See <<samplers-mipLodBias.",
  "VkPhysicalDeviceLimits.maxStorageBufferRange": "The maximum value that can be specified in the range member of any DescriptorBufferInfo structures passed to a call to flink:vkUpdateDescriptorSets for descriptors of type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC.",
  "VkPhysicalDeviceLimits.maxTessellationControlPerPatchOutputComponents": " maxTessellationControlPerPatchOutputComponents is the maximum number of components of per-patch output variables which can be output from the tessellation control shader stage.",
  "VkPhysicalDeviceLimits.maxTessellationControlPerVertexInputComponents": " maxTessellationControlPerVertexInputComponents is the maximum number of components of input variables which can be provided as per-vertex inputs to the tessellation control shader stage.",
  "VkPhysicalDeviceLimits.maxTessellationControlPerVertexOutputComponents": " maxTessellationControlPerVertexOutputComponents is the maximum number of components of per-vertex output variables which can be output from the tessellation control shader stage.",
  "VkPhysicalDeviceLimits.maxTessellationControlTotalOutputComponents": " maxTessellationControlTotalOutputComponents is the maximum total number of components of per-vertex and per-patch output variables which can be output from the tessellation control shader stage.",
  "VkPhysicalDeviceLimits.maxTessellationEvaluationInputComponents": " maxTessellationEvaluationInputComponents is the maximum number of components of input variables which can be provided as per-vertex inputs to the tessellation evaluation shader stage.",
  "VkPhysicalDeviceLimits.maxTessellationEvaluationOutputComponents": " maxTessellationEvaluationOutputComponents is the maximum number of components of per-vertex output variables which can be output from the tessellation evaluation shader stage.",
  "VkPhysicalDeviceLimits.maxTessellationGenerationLevel": " maxTessellationGenerationLevel is the maximum tessellation generation level supported by the fixed-function tessellation primitive generator. See <<tessellation.",
  "VkPhysicalDeviceLimits.maxTessellationPatchSize": " maxTessellationPatchSize is the maximum patch size, in vertices, of patches that can be processed by the tessellation control shader and tessellation primitive generator. The patchControlPoints member of the PipelineTessellationStateCreateInfo structure specified at pipeline creation time and the value provided in the OutputVertices execution mode of shader modules must be less than or equal to this limit. See <<tessellation.",
  "VkPhysicalDeviceLimits.maxTexelBufferElements": "The maximum number of addressable texels for a buffer view created on a buffer which was created with the VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set in the usage member of the BufferCreateInfo structure.",
  "VkPhysicalDeviceLimits.maxTexelGatherOffset": "The maximum offset value for the Offset or ConstOffsets image operands of any of the OpImage*Gather image instructions.",
  "VkPhysicalDeviceLimits.maxTexelOffset": "The maximum offset value for the ConstOffset image operand of any of the OpImageSample* or OpImageFetch* image instructions.",
  "VkPhysicalDeviceLimits.maxUniformBufferRange": "The maximum value that can be specified in the range member of any DescriptorBufferInfo structures passed to a call to flink:vkUpdateDescriptorSets for descriptors of type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC.",
  "VkPhysicalDeviceLimits.maxVertexInputAttributeOffset": " maxVertexInputAttributeOffset is the maximum vertex input attribute offset that can be added to the vertex input binding stride. The offset member of the VertexInputAttributeDescription structure must be less than or equal to this limit. See <<fxvertex-input.",
  "VkPhysicalDeviceLimits.maxVertexInputAttributes": " maxVertexInputAttributes is the maximum number of vertex input attributes that can be specified for a graphics pipeline. These are described in the array of VertexInputAttributeDescription structures that are provided at graphics pipeline creation time via the pVertexAttributeDescriptions member of the PipelineVertexInputStateCreateInfo structure. See <<fxvertex-attrib and <<fxvertex-input.",
  "VkPhysicalDeviceLimits.maxVertexInputBindings": "The maximum number of vertex buffers that can be specified for providing vertex attributes to a graphics pipeline. These are described in the array of VertexInputBindingDescription structures that are provided at graphics pipeline creation time via the pVertexBindingDescriptions member of the PipelineVertexInputStateCreateInfo structure. The binding member of VertexInputBindingDescription must be less than this limit. See <<fxvertex-input.",
  "VkPhysicalDeviceLimits.maxVertexInputBindingStride": " maxVertexInputBindingStride is the maximum vertex input binding stride that can be specified in a vertex input binding. The stride member of the VertexInputBindingDescription structure must be less than or equal to this limit. See <<fxvertex-input.",
  "VkPhysicalDeviceLimits.maxVertexOutputComponents": " maxVertexOutputComponents is the maximum number of components of output variables which can be output by a vertex shader. See <<shaders-vertex.",
  "VkPhysicalDeviceLimits.maxViewportDimensions": "maxViewportDimensions[2] are the maximum viewport dimensions in the X (width) and Y (height) dimensions, respectively. The maximum viewport dimensions must be greater than or equal to the largest image which can be created and used as a framebuffer attachment. See Controlling the Viewport.",
  "VkPhysicalDeviceLimits.maxViewports": "The maximum number of active viewports. The viewportCount member of the PipelineViewportStateCreateInfo structure that is provided at pipeline creation must be less than or equal to this limit.",
  "VkPhysicalDeviceLimits.minInterpolationOffset": "The minimum negative offset value for the offset operand of the InterpolateAtOffset extended instruction.",
  "VkPhysicalDeviceLimits.minMemoryMapAlignment": "The minimum required: alignment, in bytes, of host visible memory allocations within the host address space. When mapping a memory allocation with flink:vkMapMemory, subtracting offset bytes from the returned pointer will always produce an integer multiple of this limit. See <<memory-device-hostaccess.",
  "VkPhysicalDeviceLimits.minStorageBufferOffsetAlignment": " minStorageBufferOffsetAlignment is the minimum required: alignment, in bytes, for the offset member of the DescriptorBufferInfo structure for storage buffers. When a descriptor of type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC is updated, the offset must be an integer multiple of this limit. Similarly, dynamic offsets for storage buffers must be multiples of this limit.",
  "VkPhysicalDeviceLimits.minTexelBufferOffsetAlignment": " minTexelBufferOffsetAlignment is the minimum required: alignment, in bytes, for the offset member of the BufferViewCreateInfo structure for texel buffers. When a buffer view is created for a buffer which was created with VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set in the usage member of the BufferCreateInfo structure, the offset must be an integer multiple of this limit.",
  "VkPhysicalDeviceLimits.minTexelGatherOffset": "The minimum offset value for the Offset or ConstOffsets image operands of any of the OpImage*Gather image instructions.",
  "VkPhysicalDeviceLimits.minTexelOffset": "The minimum offset value for the ConstOffset image operand of any of the OpImageSample* or OpImageFetch* image instructions.",
  "VkPhysicalDeviceLimits.minUniformBufferOffsetAlignment": " minUniformBufferOffsetAlignment is the minimum required: alignment, in bytes, for the offset member of the DescriptorBufferInfo structure for uniform buffers. When a descriptor of type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC is updated, the offset must be an integer multiple of this limit. Similarly, dynamic offsets for uniform buffers must be multiples of this limit.",
  "VkPhysicalDeviceLimits.mipmapPrecisionBits": "The number of bits of division that the LOD calculation for mipmap fetching get snapped to when determining the contribution from each mip level to the mip filtered results. [eq]#2^mipmapPrecisionBits^# is the actual number of divisions. + -- [NOTE] .Note ==== For example, if this value is 2 bits then when linearly filtering between two levels, each level could: contribute: 0%, 33%, 66%, or 100% (this is just an example and the amount of contribution should: be covered by different equations in the spec). ==== -- +",
  "VkPhysicalDeviceLimits.nonCoherentAtomSize": "The size and alignment in bytes that bounds concurrent access to host-mapped device memory.",
  "VkPhysicalDeviceLimits.optimalBufferCopyOffsetAlignment": " optimalBufferCopyOffsetAlignment is the optimal buffer offset alignment in bytes for fname:vkCmdCopyBufferToImage and fname:vkCmdCopyImageToBuffer. The per texel alignment requirements are still enforced, this is just an additional alignment recommendation for optimal performance and power.",
  "VkPhysicalDeviceLimits.optimalBufferCopyRowPitchAlignment": " optimalBufferCopyRowPitchAlignment is the optimal buffer row pitch alignment in bytes for fname:vkCmdCopyBufferToImage and fname:vkCmdCopyImageToBuffer. Row pitch is the number of bytes between texels with the same X coordinate in adjacent rows (Y coordinates differ by one). The per texel alignment requirements are still enforced, this is just an additional alignment recommendation for optimal performance and power.",
  "VkPhysicalDeviceLimits.pointSizeGranularity": "The granularity of supported point sizes. Not all point sizes in the range defined by pointSizeRange are supported. This limit specifies the granularity (or increment) between successive supported point sizes.",
  "VkPhysicalDeviceLimits.pointSizeRange": "pointSizeRange[2] is the range [eq]#[minimum,maximum]# of supported sizes for points. Values written to variables decorated with the PointSize built-in decoration are clamped to this range.",
  "VkPhysicalDeviceLimits.sampledImageColorSampleCounts": " sampledImageColorSampleCounts is a bitmask^1^ of SampleCountFlagBits bits indicating the sample counts supported for all 2D images created with VK_IMAGE_TILING_OPTIMAL, usage containing VK_IMAGE_USAGE_SAMPLED_BIT, and a non-integer color format.",
  "VkPhysicalDeviceLimits.sampledImageDepthSampleCounts": " sampledImageDepthSampleCounts is a bitmask^1^ of SampleCountFlagBits bits indicating the sample counts supported for all 2D images created with VK_IMAGE_TILING_OPTIMAL, usage containing VK_IMAGE_USAGE_SAMPLED_BIT, and a depth format.",
  "VkPhysicalDeviceLimits.sampledImageIntegerSampleCounts": " sampledImageIntegerSampleCounts is a bitmask^1^ of SampleCountFlagBits bits indicating the sample counts supported for all 2D images created with VK_IMAGE_TILING_OPTIMAL, usage containing VK_IMAGE_USAGE_SAMPLED_BIT, and an integer color format.",
  "VkPhysicalDeviceLimits.sampledImageStencilSampleCounts": " sampledImageStencilSampleCounts is a bitmask^1^ of SampleCountFlagBits bits indicating the sample supported for all 2D images created with VK_IMAGE_TILING_OPTIMAL, usage containing VK_IMAGE_USAGE_SAMPLED_BIT, and a stencil format.",
  "VkPhysicalDeviceLimits.sparseAddressSpaceSize": "The total amount of address space available, in bytes, for sparse memory resources. This is an upper bound on the sum of the size of all sparse resources, regardless of whether any memory is bound to them.",
  "VkPhysicalDeviceLimits.standardSampleLocations": " standardSampleLocations indicates whether rasterization uses the standard sample locations as documented in Multisampling. If set to VK_TRUE, the implementation uses the documented sample locations. If set to VK_FALSE, the implementation may use different sample locations.",
  "VkPhysicalDeviceLimits.storageImageSampleCounts": " storageImageSampleCounts is a bitmask^1^ of SampleCountFlagBits bits indicating the sample counts supported for all 2D images created with VK_IMAGE_TILING_OPTIMAL, and usage containing VK_IMAGE_USAGE_STORAGE_BIT.",
  "VkPhysicalDeviceLimits.strictLines": "Indicates whether lines are rasterized according to the preferred method of rasterization. If set to VK_FALSE, lines may be rasterized under a relaxed set of rules. If set to VK_TRUE, lines are rasterized as per the strict definition. See Basic Line Segment Rasterization.",
  "VkPhysicalDeviceLimits.subPixelInterpolationOffsetBits": " subPixelInterpolationOffsetBits is the number of subpixel fractional bits that the x and y offsets to the InterpolateAtOffset extended instruction may be rounded to as fixed-point values.",
  "VkPhysicalDeviceLimits.subPixelPrecisionBits": "The number of bits of subpixel precision in framebuffer coordinates [eq]#x~f~# and [eq]#y~f~#. See <<primsrast.",
  "VkPhysicalDeviceLimits.subTexelPrecisionBits": "The number of bits of precision in the division along an axis of an image used for minification and magnification filters. [eq]#2^subTexelPrecisionBits^# is the actual number of divisions along each axis of the image represented. The filtering hardware will snap to these locations when computing the filtered results.",
  "VkPhysicalDeviceLimits.timestampComputeAndGraphics": " timestampComputeAndGraphics indicates support for timestamps on all graphics and compute queues. If this limit is set to VK_TRUE, all queues that advertise the VK_QUEUE_GRAPHICS_BIT or VK_QUEUE_COMPUTE_BIT in the QueueFamilyProperties::queueFlags support QueueFamilyProperties::timestampValidBits of at least 36. See Timestamp Queries.",
  "VkPhysicalDeviceLimits.timestampPeriod": "The number of nanoseconds required: for a timestamp query to be incremented by 1. See Timestamp Queries.",
  "VkPhysicalDeviceLimits.viewportBoundsRange": "viewportBoundsRange[2] is the [eq]#[minimum, maximum]# range that the corners of a viewport must be contained in. This range must be at least [eq]#[-2 {times} size, 2 {times} size - 1]#, where [eq]#size = max(maxViewportDimensions[0], maxViewportDimensions[1])#. See Controlling the Viewport. + -- [NOTE] .Note ==== The intent of the viewportBoundsRange limit is to allow a maximum sized viewport to be arbitrarily shifted relative to the output target as long as at least some portion intersects. This would give a bounds limit of [eq]#[-size + 1, 2 {times} size - 1]# which would allow all possible non-empty-set intersections of the output target and the viewport. Since these numbers are typically powers of two, picking the signed number range using the smallest possible number of bits ends up with the specified range. ==== --",
  "VkPhysicalDeviceLimits.viewportSubPixelBits": "The number of bits of subpixel precision for viewport bounds. The subpixel precision that floating-point viewport bounds are interpreted at is given by this limit.",
  "VkPhysicalDeviceMemoryProperties": "Structure specifying physical device memory properties.",
  "VkPhysicalDeviceMemoryProperties.memoryHeapCount": "The number of valid elements in the memoryHeaps array.",
  "VkPhysicalDeviceMemoryProperties.memoryHeaps": "An array of MemoryHeap structures describing the _memory heaps_ from which memory can be allocated.",
  "VkPhysicalDeviceMemoryProperties.memoryTypeCount": "The number of valid elements in the memoryTypes array.",
  "VkPhysicalDeviceMemoryProperties.memoryTypes": "An array of MemoryType structures describing the _memory types_ that can be used to access memory allocated from the heaps specified by memoryHeaps.",
  "VkPhysicalDeviceMemoryProperties2KHR": "Structure specifying physical device memory properties.",
  "VkPhysicalDeviceMemoryProperties2KHR.memoryProperties": "A structure of type PhysicalDeviceMemoryProperties which is populated with the same values as in flink:vkGetPhysicalDeviceMemoryProperties.",
  "VkPhysicalDeviceMemoryProperties2KHR.pNext": "Null or an extension-specific structure.",
  "VkPhysicalDeviceMemoryProperties2KHR.sType": "The type of this structure.",
  "VkPhysicalDeviceMultiviewFeaturesKHX": "Structure describing multiview features that can be supported by an implementation.",
  "VkPhysicalDeviceMultiviewFeaturesKHX.multiview": "",
  "VkPhysicalDeviceMultiviewFeaturesKHX.multiviewGeometryShader": "",
  "VkPhysicalDeviceMultiviewFeaturesKHX.multiviewTessellationShader": "",
  "VkPhysicalDeviceMultiviewFeaturesKHX.pNext": "",
  "VkPhysicalDeviceMultiviewFeaturesKHX.sType": "",
  "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX": "Structure describing multiview limits that can be supported by an implementation.",
  "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.perViewPositionAllComponents": "",
  "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.pNext": "",
  "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.sType": "",
  "VkPhysicalDeviceMultiviewPropertiesKHX": "Structure describing multiview limits that can be supported by an implementation.",
  "VkPhysicalDeviceMultiviewPropertiesKHX.maxMultiviewInstanceIndex": "",
  "VkPhysicalDeviceMultiviewPropertiesKHX.maxMultiviewViewCount": "",
  "VkPhysicalDeviceMultiviewPropertiesKHX.pNext": "",
  "VkPhysicalDeviceMultiviewPropertiesKHX.sType": "",
  "VkPhysicalDevicePointClippingPropertiesKHR": "",
  "VkPhysicalDevicePointClippingPropertiesKHR.pNext": "",
  "VkPhysicalDevicePointClippingPropertiesKHR.pointClippingBehavior": "",
  "VkPhysicalDevicePointClippingPropertiesKHR.sType": "",
  "VkPhysicalDeviceProperties": "Structure specifying physical device properties.",
  "VkPhysicalDeviceProperties.apiVersion": "The version of Vulkan supported by the device, encoded as described in the API Version Numbers and Semantics section.",
  "VkPhysicalDeviceProperties.deviceID": "A unique identifier for the physical device among devices available from the vendor.",
  "VkPhysicalDeviceProperties.deviceName": "A string containing the name of the device.",
  "VkPhysicalDeviceProperties.deviceType": "A PhysicalDeviceType specifying the type of device.",
  "VkPhysicalDeviceProperties.driverVersion": "The vendor-specified version of the driver.",
  "VkPhysicalDeviceProperties.limits": "The PhysicalDeviceLimits structure which specifies device-specific limits of the physical device. See Limits for details.",
  "VkPhysicalDeviceProperties.pipelineCacheUUID": "An array of size VK_UUID_SIZE, containing 8-bit values that represent a universally unique identifier for the device.",
  "VkPhysicalDeviceProperties.sparseProperties": "The PhysicalDeviceSparseProperties structure which specifies various sparse related properties of the physical device. See Sparse Properties for details.",
  "VkPhysicalDeviceProperties.vendorID": "A unique identifier for the _vendor_ (see below) of the physical device.",
  "VkPhysicalDeviceProperties2KHR": "Structure specifying physical device properties.",
  "VkPhysicalDeviceProperties2KHR.pNext": "Null or an extension-specific structure.",
  "VkPhysicalDeviceProperties2KHR.properties": "A structure of type PhysicalDeviceProperties describing the properties of the physical device. This structure is written with the same values as if it were written by flink:vkGetPhysicalDeviceProperties.",
  "VkPhysicalDeviceProperties2KHR.sType": "The type of this structure.",
  "VkPhysicalDevicePushDescriptorPropertiesKHR": "Structure describing push descriptor limits that can be supported by an implementation.",
  "VkPhysicalDevicePushDescriptorPropertiesKHR.maxPushDescriptors": "",
  "VkPhysicalDevicePushDescriptorPropertiesKHR.pNext": "",
  "VkPhysicalDevicePushDescriptorPropertiesKHR.sType": "",
  "VkPhysicalDeviceSampleLocationsPropertiesEXT": "",
  "VkPhysicalDeviceSampleLocationsPropertiesEXT.maxSampleLocationGridSize": "",
  "VkPhysicalDeviceSampleLocationsPropertiesEXT.pNext": "",
  "VkPhysicalDeviceSampleLocationsPropertiesEXT.sampleLocationCoordinateRange": "",
  "VkPhysicalDeviceSampleLocationsPropertiesEXT.sampleLocationSampleCounts": "",
  "VkPhysicalDeviceSampleLocationsPropertiesEXT.sampleLocationSubPixelBits": "",
  "VkPhysicalDeviceSampleLocationsPropertiesEXT.sType": "",
  "VkPhysicalDeviceSampleLocationsPropertiesEXT.variableSampleLocations": "",
  "VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT": "",
  "VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.filterMinmaxImageComponentMapping": "",
  "VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.filterMinmaxSingleComponentFormats": "",
  "VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.pNext": "",
  "VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.sType": "",
  "VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR": "",
  "VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.pNext": "",
  "VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.samplerYcbcrConversion": "",
  "VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.sType": "",
  "VkPhysicalDeviceSparseImageFormatInfo2KHR": "Structure specifying sparse image format inputs.",
  "VkPhysicalDeviceSparseImageFormatInfo2KHR.format": "The image format.",
  "VkPhysicalDeviceSparseImageFormatInfo2KHR.pNext": "Null or an extension-specific structure.",
  "VkPhysicalDeviceSparseImageFormatInfo2KHR.samples": "The number of samples per pixel as defined in SampleCountFlagBits.",
  "VkPhysicalDeviceSparseImageFormatInfo2KHR.sType": "The type of this structure.",
  "VkPhysicalDeviceSparseImageFormatInfo2KHR.tiling": "The tiling arrangement of the data elements in memory.",
  "VkPhysicalDeviceSparseImageFormatInfo2KHR.type": "The dimensionality of image.",
  "VkPhysicalDeviceSparseImageFormatInfo2KHR.usage": "A bitmask describing the intended usage of the image.",
  "VkPhysicalDeviceSparseProperties": "Structure specifying physical device sparse memory properties.",
  "VkPhysicalDeviceSparseProperties.residencyAlignedMipSize": "residencyAlignedMipSize is VK_TRUE if images with mip level dimensions that are not integer multiples of the corresponding dimensions of the sparse image block may be placed in the mip tail. If this property is not reported, only mip levels with dimensions smaller than the imageGranularity member of the SparseImageFormatProperties structure will be placed in the mip tail. If this property is reported the implementation is allowed to return VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT in the flags member of SparseImageFormatProperties, indicating that mip level dimensions that are not integer multiples of the corresponding dimensions of the sparse image block will be placed in the mip tail.",
  "VkPhysicalDeviceSparseProperties.residencyNonResidentStrict": "Specifies whether the physical device can consistently access non-resident regions of a resource. If this property is VK_TRUE, access to non-resident regions of resources will be guaranteed to return values as if the resource were populated with 0; writes to non-resident regions will be discarded.",
  "VkPhysicalDeviceSparseProperties.residencyStandard2DBlockShape": "residencyStandard2DBlockShape is VK_TRUE if the physical device will access all single-sample 2D sparse resources using the standard sparse image block shapes (based on image format), as described in the Standard Sparse Image Block Shapes (Single Sample) table. If this property is not supported the value returned in the imageGranularity member of the SparseImageFormatProperties structure for single-sample 2D images is not required: to match the standard sparse image block dimensions listed in the table.",
  "VkPhysicalDeviceSparseProperties.residencyStandard2DMultisampleBlockShape": "residencyStandard2DMultisampleBlockShape is VK_TRUE if the physical device will access all multisample 2D sparse resources using the standard sparse image block shapes (based on image format), as described in the Standard Sparse Image Block Shapes (MSAA) table. If this property is not supported, the value returned in the imageGranularity member of the SparseImageFormatProperties structure for multisample 2D images is not required: to match the standard sparse image block dimensions listed in the table.",
  "VkPhysicalDeviceSparseProperties.residencyStandard3DBlockShape": "residencyStandard3DBlockShape is VK_TRUE if the physical device will access all 3D sparse resources using the standard sparse image block shapes (based on image format), as described in the Standard Sparse Image Block Shapes (Single Sample) table. If this property is not supported, the value returned in the imageGranularity member of the SparseImageFormatProperties structure for 3D images is not required: to match the standard sparse image block dimensions listed in the table.",
  "VkPhysicalDeviceSurfaceInfo2KHR": "",
  "VkPhysicalDeviceSurfaceInfo2KHR.pNext": "",
  "VkPhysicalDeviceSurfaceInfo2KHR.sType": "",
  "VkPhysicalDeviceSurfaceInfo2KHR.surface": "",
  "VkPhysicalDeviceType": "Supported physical device types.",
  "VkPhysicalDeviceType.VK_PHYSICAL_DEVICE_TYPE_CPU": "VK_PHYSICAL_DEVICE_TYPE_CPU The device is typically running on the same processors as the host.",
  "VkPhysicalDeviceType.VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU": "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU The device is typically a separate processor connected to the host via an interlink.",
  "VkPhysicalDeviceType.VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU": "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU The device is typically one embedded in or tightly coupled with the host.",
  "VkPhysicalDeviceType.VK_PHYSICAL_DEVICE_TYPE_OTHER": "VK_PHYSICAL_DEVICE_TYPE_OTHER The device does not match any other available types.",
  "VkPhysicalDeviceType.VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU": "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU The device is typically a virtual node in a virtualization environment.",
  "VkPhysicalDeviceVariablePointerFeaturesKHR": "",
  "VkPhysicalDeviceVariablePointerFeaturesKHR.pNext": "",
  "VkPhysicalDeviceVariablePointerFeaturesKHR.sType": "",
  "VkPhysicalDeviceVariablePointerFeaturesKHR.variablePointers": "",
  "VkPhysicalDeviceVariablePointerFeaturesKHR.variablePointersStorageBuffer": "",
  "VkPipeline": "Opaque handle to a pipeline object.",
  "VkPipelineBindPoint": "Specify the bind point of a pipeline object to a command buffer.",
  "VkPipelineBindPoint.VK_PIPELINE_BIND_POINT_COMPUTE": "",
  "VkPipelineBindPoint.VK_PIPELINE_BIND_POINT_GRAPHICS": "",
  "VkPipelineCache": "Opaque handle to a pipeline cache object.",
  "VkPipelineCacheCreateFlagBits": "",
  "VkPipelineCacheCreateFlags": "",
  "VkPipelineCacheCreateFlags.__none": "",
  "VkPipelineCacheCreateInfo": "Structure specifying parameters of a newly created pipeline cache.",
  "VkPipelineCacheCreateInfo.flags": "Reserved for future use.",
  "VkPipelineCacheCreateInfo.initialDataSize": "The number of bytes in pInitialData. If initialDataSize is zero, the pipeline cache will initially be empty.",
  "VkPipelineCacheCreateInfo.pInitialData": "A pointer to previously retrieved pipeline cache data. If the pipeline cache data is incompatible (as defined below) with the device, the pipeline cache will be initially empty. If initialDataSize is zero, pInitialData is ignored.",
  "VkPipelineCacheCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkPipelineCacheCreateInfo.sType": "The type of this structure.",
  "VkPipelineCacheHeaderVersion": "Encode pipeline cache version.",
  "VkPipelineCacheHeaderVersion.VK_PIPELINE_CACHE_HEADER_VERSION_ONE": "",
  "VkPipelineColorBlendAdvancedStateCreateInfoEXT": "",
  "VkPipelineColorBlendAdvancedStateCreateInfoEXT.blendOverlap": "",
  "VkPipelineColorBlendAdvancedStateCreateInfoEXT.dstPremultiplied": "",
  "VkPipelineColorBlendAdvancedStateCreateInfoEXT.pNext": "",
  "VkPipelineColorBlendAdvancedStateCreateInfoEXT.srcPremultiplied": "",
  "VkPipelineColorBlendAdvancedStateCreateInfoEXT.sType": "",
  "VkPipelineColorBlendAttachmentState": "Structure specifying a pipeline color blend attachment state.",
  "VkPipelineColorBlendAttachmentState.alphaBlendOp": "alphaBlendOp selects which blend operation is use to calculate the alpha values to write to the color attachment.",
  "VkPipelineColorBlendAttachmentState.blendEnable": "blendEnable controls whether blending is enabled for the corresponding color attachment. If blending is not enabled, the source fragment's color for that attachment is passed through unmodified.",
  "VkPipelineColorBlendAttachmentState.colorBlendOp": "colorBlendOp selects which blend operation is used to calculate the RGB values to write to the color attachment.",
  "VkPipelineColorBlendAttachmentState.colorWriteMask": "A bitmask selecting which of the R, G, B, and/or A components are enabled for writing, as described later in this chapter.",
  "VkPipelineColorBlendAttachmentState.dstAlphaBlendFactor": "dstAlphaBlendFactor selects which blend factor is used to determine the destination factor [eq]#D~a~#.",
  "VkPipelineColorBlendAttachmentState.dstColorBlendFactor": "dstColorBlendFactor selects which blend factor is used to determine the destination factors [eq]#(D~r~,D~g~,D~b~)#.",
  "VkPipelineColorBlendAttachmentState.srcAlphaBlendFactor": "srcAlphaBlendFactor selects which blend factor is used to determine the source factor [eq]#S~a~#.",
  "VkPipelineColorBlendAttachmentState.srcColorBlendFactor": "srcColorBlendFactor selects which blend factor is used to determine the source factors [eq]#(S~r~,S~g~,S~b~)#.",
  "VkPipelineColorBlendStateCreateFlagBits": "",
  "VkPipelineColorBlendStateCreateFlags": "",
  "VkPipelineColorBlendStateCreateFlags.__none": "",
  "VkPipelineColorBlendStateCreateInfo": "Structure specifying parameters of a newly created pipeline color blend state.",
  "VkPipelineColorBlendStateCreateInfo.attachmentCount": "The number of PipelineColorBlendAttachmentState elements in pAttachments. This value must equal the colorAttachmentCount for the subpass in which this pipeline is used.",
  "VkPipelineColorBlendStateCreateInfo.blendConstants": "An array of four values used as the R, G, B, and A components of the blend constant that are used in blending, depending on the blend factor.",
  "VkPipelineColorBlendStateCreateInfo.flags": "Reserved for future use.",
  "VkPipelineColorBlendStateCreateInfo.logicOp": "logicOp selects which logical operation to apply.",
  "VkPipelineColorBlendStateCreateInfo.logicOpEnable": "logicOpEnable controls whether to apply Logical Operations.",
  "VkPipelineColorBlendStateCreateInfo.pAttachments": "pAttachments: is array of per target attachment states.",
  "VkPipelineColorBlendStateCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkPipelineColorBlendStateCreateInfo.sType": "The type of this structure.",
  "VkPipelineCoverageModulationStateCreateFlagsNV": "",
  "VkPipelineCoverageModulationStateCreateFlagsNV.__none": "",
  "VkPipelineCoverageModulationStateCreateInfoNV": "",
  "VkPipelineCoverageModulationStateCreateInfoNV.coverageModulationMode": "",
  "VkPipelineCoverageModulationStateCreateInfoNV.coverageModulationTableCount": "",
  "VkPipelineCoverageModulationStateCreateInfoNV.coverageModulationTableEnable": "",
  "VkPipelineCoverageModulationStateCreateInfoNV.flags": "",
  "VkPipelineCoverageModulationStateCreateInfoNV.pCoverageModulationTable": "",
  "VkPipelineCoverageModulationStateCreateInfoNV.pNext": "",
  "VkPipelineCoverageModulationStateCreateInfoNV.sType": "",
  "VkPipelineCoverageToColorStateCreateFlagsNV": "",
  "VkPipelineCoverageToColorStateCreateFlagsNV.__none": "",
  "VkPipelineCoverageToColorStateCreateInfoNV": "",
  "VkPipelineCoverageToColorStateCreateInfoNV.coverageToColorEnable": "",
  "VkPipelineCoverageToColorStateCreateInfoNV.coverageToColorLocation": "",
  "VkPipelineCoverageToColorStateCreateInfoNV.flags": "",
  "VkPipelineCoverageToColorStateCreateInfoNV.pNext": "",
  "VkPipelineCoverageToColorStateCreateInfoNV.sType": "",
  "VkPipelineCreateFlagBits": "Bitmask controlling how a pipeline is generated.",
  "VkPipelineCreateFlagBits.__none": "",
  "VkPipelineCreateFlagBits.VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT": "Specifies that the pipeline to be created is allowed to be the parent of a pipeline that will be created in a subsequent call to flink:vkCreateGraphicsPipelines.",
  "VkPipelineCreateFlagBits.VK_PIPELINE_CREATE_DERIVATIVE_BIT": "Specifies that the pipeline to be created will be a child of a previously created parent pipeline.",
  "VkPipelineCreateFlagBits.VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT": "Specifies that the created pipeline will not be optimized. Using this flag may reduce the time taken to create the pipeline.",
  "VkPipelineCreateFlagBits.VK_PIPELINE_CREATE_DISPATCH_BASE_KHX": "Specifies that a compute pipeline can be used with flink:vkCmdDispatchBaseKHX with a non-zero base workgroup.",
  "VkPipelineCreateFlagBits.VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHX": "Specifies that any shader input variables decorated as DeviceIndex will be assigned values as if they were decorated as ViewIndex.",
  "VkPipelineCreateFlags": "",
  "VkPipelineDepthStencilStateCreateFlagBits": "",
  "VkPipelineDepthStencilStateCreateFlags": "",
  "VkPipelineDepthStencilStateCreateFlags.__none": "",
  "VkPipelineDepthStencilStateCreateInfo": "Structure specifying parameters of a newly created pipeline depth stencil state.",
  "VkPipelineDepthStencilStateCreateInfo.back": "",
  "VkPipelineDepthStencilStateCreateInfo.depthBoundsTestEnable": "depthBoundsTestEnable controls whether depth bounds testing is enabled.",
  "VkPipelineDepthStencilStateCreateInfo.depthCompareOp": "The comparison operator used in the depth test.",
  "VkPipelineDepthStencilStateCreateInfo.depthTestEnable": "depthTestEnable controls whether depth testing is enabled.",
  "VkPipelineDepthStencilStateCreateInfo.depthWriteEnable": "depthWriteEnable controls whether depth writes are enabled.",
  "VkPipelineDepthStencilStateCreateInfo.flags": "Reserved for future use.",
  "VkPipelineDepthStencilStateCreateInfo.front": "front and back control the parameters of the stencil test.",
  "VkPipelineDepthStencilStateCreateInfo.maxDepthBounds": "",
  "VkPipelineDepthStencilStateCreateInfo.minDepthBounds": "minDepthBounds and maxDepthBounds define the range of values used in the depth bounds test.",
  "VkPipelineDepthStencilStateCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkPipelineDepthStencilStateCreateInfo.stencilTestEnable": "stencilTestEnable controls whether stencil testing is enabled.",
  "VkPipelineDepthStencilStateCreateInfo.sType": "The type of this structure.",
  "VkPipelineDiscardRectangleStateCreateFlagsEXT": "",
  "VkPipelineDiscardRectangleStateCreateFlagsEXT.__none": "",
  "VkPipelineDiscardRectangleStateCreateInfoEXT": "",
  "VkPipelineDiscardRectangleStateCreateInfoEXT.discardRectangleCount": "",
  "VkPipelineDiscardRectangleStateCreateInfoEXT.discardRectangleMode": "",
  "VkPipelineDiscardRectangleStateCreateInfoEXT.flags": "",
  "VkPipelineDiscardRectangleStateCreateInfoEXT.pDiscardRectangles": "",
  "VkPipelineDiscardRectangleStateCreateInfoEXT.pNext": "",
  "VkPipelineDiscardRectangleStateCreateInfoEXT.sType": "",
  "VkPipelineDynamicStateCreateFlagBits": "",
  "VkPipelineDynamicStateCreateFlags": "",
  "VkPipelineDynamicStateCreateFlags.__none": "",
  "VkPipelineDynamicStateCreateInfo": "Structure specifying parameters of a newly created pipeline dynamic state.",
  "VkPipelineDynamicStateCreateInfo.dynamicStateCount": "The number of elements in the pDynamicStates array.",
  "VkPipelineDynamicStateCreateInfo.flags": "Reserved for future use.",
  "VkPipelineDynamicStateCreateInfo.pDynamicStates": "An array of DynamicState enums which indicate which pieces of pipeline state will use the values from dynamic state commands rather than from the pipeline state creation info.",
  "VkPipelineDynamicStateCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkPipelineDynamicStateCreateInfo.sType": "The type of this structure.",
  "VkPipelineInputAssemblyStateCreateFlagBits": "",
  "VkPipelineInputAssemblyStateCreateFlags": "",
  "VkPipelineInputAssemblyStateCreateFlags.__none": "",
  "VkPipelineInputAssemblyStateCreateInfo": "Structure specifying parameters of a newly created pipeline input assembly state.",
  "VkPipelineInputAssemblyStateCreateInfo.flags": "Reserved for future use.",
  "VkPipelineInputAssemblyStateCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkPipelineInputAssemblyStateCreateInfo.primitiveRestartEnable": "primitiveRestartEnable controls whether a special vertex index value is treated as restarting the assembly of primitives. This enable only applies to indexed draws (flink:vkCmdDrawIndexed and flink:vkCmdDrawIndexedIndirect), and the special index value is either 0xFFFFFFFF when the indexType parameter of fname:vkCmdBindIndexBuffer is equal to VK_INDEX_TYPE_UINT32, or 0xFFFF when indexType is equal to VK_INDEX_TYPE_UINT16. Primitive restart is not allowed for \"`list`\" topologies.",
  "VkPipelineInputAssemblyStateCreateInfo.sType": "The type of this structure.",
  "VkPipelineInputAssemblyStateCreateInfo.topology": "A PrimitiveTopology defining the primitive topology, as described below.",
  "VkPipelineLayout": "Opaque handle to a pipeline layout object.",
  "VkPipelineLayoutCreateFlagBits": "",
  "VkPipelineLayoutCreateFlags": "",
  "VkPipelineLayoutCreateFlags.__none": "",
  "VkPipelineLayoutCreateInfo": "Structure specifying the parameters of a newly created pipeline layout object.",
  "VkPipelineLayoutCreateInfo.flags": "Reserved for future use.",
  "VkPipelineLayoutCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkPipelineLayoutCreateInfo.pPushConstantRanges": "An array of PushConstantRange structures defining a set of push constant ranges for use in a single pipeline layout. In addition to descriptor set layouts, a pipeline layout also describes how many push constants can be accessed by each stage of the pipeline. + [NOTE] .Note ==== Push constants represent a high speed path to modify constant data in pipelines that is expected to outperform memory-backed resource updates. ====",
  "VkPipelineLayoutCreateInfo.pSetLayouts": "An array of DescriptorSetLayout objects.",
  "VkPipelineLayoutCreateInfo.pushConstantRangeCount": "The number of push constant ranges included in the pipeline layout.",
  "VkPipelineLayoutCreateInfo.setLayoutCount": "The number of descriptor sets included in the pipeline layout.",
  "VkPipelineLayoutCreateInfo.sType": "The type of this structure.",
  "VkPipelineMultisampleStateCreateFlagBits": "",
  "VkPipelineMultisampleStateCreateFlags": "",
  "VkPipelineMultisampleStateCreateFlags.__none": "",
  "VkPipelineMultisampleStateCreateInfo": "Structure specifying parameters of a newly created pipeline multisample state.",
  "VkPipelineMultisampleStateCreateInfo.alphaToCoverageEnable": "alphaToCoverageEnable controls whether a temporary coverage value is generated based on the alpha component of the fragment's first color output as specified in the Multisample Coverage section.",
  "VkPipelineMultisampleStateCreateInfo.alphaToOneEnable": "alphaToOneEnable controls whether the alpha component of the fragment's first color output is replaced with one as described in Multisample Coverage.",
  "VkPipelineMultisampleStateCreateInfo.flags": "Reserved for future use.",
  "VkPipelineMultisampleStateCreateInfo.minSampleShading": "The minimum fraction of sample shading, as described in Sample Shading.",
  "VkPipelineMultisampleStateCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkPipelineMultisampleStateCreateInfo.pSampleMask": "A bitmask of static coverage information that is ANDed with the coverage information generated during rasterization, as described in Sample Mask.",
  "VkPipelineMultisampleStateCreateInfo.rasterizationSamples": "A SampleCountFlagBits specifying the number of samples per pixel used in rasterization.",
  "VkPipelineMultisampleStateCreateInfo.sampleShadingEnable": "Specifies that fragment shading executes per-sample if VK_TRUE, or per-fragment if VK_FALSE, as described in Sample Shading.",
  "VkPipelineMultisampleStateCreateInfo.sType": "The type of this structure.",
  "VkPipelineRasterizationConservativeStateCreateFlagsEXT": "",
  "VkPipelineRasterizationConservativeStateCreateFlagsEXT.__none": "",
  "VkPipelineRasterizationConservativeStateCreateInfoEXT": "",
  "VkPipelineRasterizationConservativeStateCreateInfoEXT.conservativeRasterizationMode": "",
  "VkPipelineRasterizationConservativeStateCreateInfoEXT.extraPrimitiveOverestimationSize": "",
  "VkPipelineRasterizationConservativeStateCreateInfoEXT.flags": "",
  "VkPipelineRasterizationConservativeStateCreateInfoEXT.pNext": "",
  "VkPipelineRasterizationConservativeStateCreateInfoEXT.sType": "",
  "VkPipelineRasterizationStateCreateFlagBits": "",
  "VkPipelineRasterizationStateCreateFlags": "",
  "VkPipelineRasterizationStateCreateFlags.__none": "",
  "VkPipelineRasterizationStateCreateInfo": "Structure specifying parameters of a newly created pipeline rasterization state.",
  "VkPipelineRasterizationStateCreateInfo.cullMode": "The triangle facing direction used for primitive culling. See CullModeFlagBits.",
  "VkPipelineRasterizationStateCreateInfo.depthBiasClamp": "The maximum (or minimum) depth bias of a fragment.",
  "VkPipelineRasterizationStateCreateInfo.depthBiasConstantFactor": "A scalar factor controlling the constant depth value added to each fragment.",
  "VkPipelineRasterizationStateCreateInfo.depthBiasEnable": "depthBiasEnable controls whether to bias fragment depth values.",
  "VkPipelineRasterizationStateCreateInfo.depthBiasSlopeFactor": "A scalar factor applied to a fragment's slope in depth bias calculations.",
  "VkPipelineRasterizationStateCreateInfo.depthClampEnable": "depthClampEnable controls whether to clamp the fragment's depth values instead of clipping primitives to the z planes of the frustum, as described in Primitive Clipping.",
  "VkPipelineRasterizationStateCreateInfo.flags": "Reserved for future use.",
  "VkPipelineRasterizationStateCreateInfo.frontFace": "The front-facing triangle orientation to be used for culling. See FrontFace.",
  "VkPipelineRasterizationStateCreateInfo.lineWidth": "The width of rasterized line segments.",
  "VkPipelineRasterizationStateCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkPipelineRasterizationStateCreateInfo.polygonMode": "The triangle rendering mode. See PolygonMode.",
  "VkPipelineRasterizationStateCreateInfo.rasterizerDiscardEnable": "rasterizerDiscardEnable controls whether primitives are discarded immediately before the rasterization stage.",
  "VkPipelineRasterizationStateCreateInfo.sType": "The type of this structure.",
  "VkPipelineRasterizationStateRasterizationOrderAMD": "",
  "VkPipelineRasterizationStateRasterizationOrderAMD.pNext": "",
  "VkPipelineRasterizationStateRasterizationOrderAMD.rasterizationOrder": "",
  "VkPipelineRasterizationStateRasterizationOrderAMD.sType": "",
  "VkPipelineSampleLocationsStateCreateInfoEXT": "",
  "VkPipelineSampleLocationsStateCreateInfoEXT.pNext": "",
  "VkPipelineSampleLocationsStateCreateInfoEXT.sampleLocationsEnable": "",
  "VkPipelineSampleLocationsStateCreateInfoEXT.sampleLocationsInfo": "",
  "VkPipelineSampleLocationsStateCreateInfoEXT.sType": "",
  "VkPipelineShaderStageCreateFlagBits": "",
  "VkPipelineShaderStageCreateFlags": "",
  "VkPipelineShaderStageCreateFlags.__none": "",
  "VkPipelineShaderStageCreateInfo": "Structure specifying parameters of a newly created pipeline shader stage.",
  "VkPipelineShaderStageCreateInfo.flags": "Reserved for future use.",
  "VkPipelineShaderStageCreateInfo.module": "",
  "VkPipelineShaderStageCreateInfo.pName": "",
  "VkPipelineShaderStageCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkPipelineShaderStageCreateInfo.pSpecializationInfo": "",
  "VkPipelineShaderStageCreateInfo.stage": "stage names a single pipeline stage. Bits which can be set include: + --",
  "VkPipelineShaderStageCreateInfo.sType": "The type of this structure.",
  "VkPipelineStageFlagBits": "Bitmask specifying pipeline stages.",
  "VkPipelineStageFlagBits.__none": "",
  "VkPipelineStageFlagBits.VK_PIPELINE_STAGE_ALL_COMMANDS_BIT": "All stages supported on the queue",
  "VkPipelineStageFlagBits.VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT": "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT: Execution of all graphics pipeline stages. Equivalent to the logical or of:",
  "VkPipelineStageFlagBits.VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT": "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT: Final stage in the pipeline where operations generated by all commands complete execution.",
  "VkPipelineStageFlagBits.VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT": "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT: Stage of the pipeline after blending where the final color values are output from the pipeline. This stage also includes subpass load and store operations and multisample resolve operations for framebuffer attachments with a color format.",
  "VkPipelineStageFlagBits.VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX": "VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX: Stage of the pipeline where device-side generation of commands via flink:vkCmdProcessCommandsNVX is handled.",
  "VkPipelineStageFlagBits.VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT": "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT: Execution of a compute shader.",
  "VkPipelineStageFlagBits.VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT": "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT: Stage of the pipeline where Draw/DispatchIndirect data structures are consumed. This stage also includes reading commands written by flink:vkCmdProcessCommandsNVX.",
  "VkPipelineStageFlagBits.VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT": "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT: Stage of the pipeline where early fragment tests (depth and stencil tests before fragment shading) are performed. This stage also includes subpass load operations for framebuffer attachments with a depth/stencil format.",
  "VkPipelineStageFlagBits.VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT": "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT: Fragment shader stage.",
  "VkPipelineStageFlagBits.VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT": "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT: Geometry shader stage.",
  "VkPipelineStageFlagBits.VK_PIPELINE_STAGE_HOST_BIT": "VK_PIPELINE_STAGE_HOST_BIT: A pseudo-stage indicating execution on the host of reads/writes of device memory. This stage is not invoked by any commands recorded in a command buffer.",
  "VkPipelineStageFlagBits.VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT": "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT: Stage of the pipeline where late fragment tests (depth and stencil tests after fragment shading) are performed. This stage also includes subpass store operations for framebuffer attachments with a depth/stencil format.",
  "VkPipelineStageFlagBits.VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT": "Tessellation control shader stage.",
  "VkPipelineStageFlagBits.VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT": "Tessellation evaluation shader stage.",
  "VkPipelineStageFlagBits.VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT": "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT: Stage of the pipeline where any commands are initially received by the queue.",
  "VkPipelineStageFlagBits.VK_PIPELINE_STAGE_TRANSFER_BIT": " VK_PIPELINE_STAGE_TRANSFER_BIT: Execution of copy commands. This includes the operations resulting from all copy commands, clear commands (with the exception of flink:vkCmdClearAttachments), and flink:vkCmdCopyQueryPoolResults.",
  "VkPipelineStageFlagBits.VK_PIPELINE_STAGE_VERTEX_INPUT_BIT": "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT: Stage of the pipeline where vertex and index buffers are consumed.",
  "VkPipelineStageFlagBits.VK_PIPELINE_STAGE_VERTEX_SHADER_BIT": "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT: Vertex shader stage.",
  "VkPipelineStageFlags": "",
  "VkPipelineTessellationDomainOriginStateCreateInfoKHR": "",
  "VkPipelineTessellationDomainOriginStateCreateInfoKHR.domainOrigin": "",
  "VkPipelineTessellationDomainOriginStateCreateInfoKHR.pNext": "",
  "VkPipelineTessellationDomainOriginStateCreateInfoKHR.sType": "",
  "VkPipelineTessellationStateCreateFlagBits": "",
  "VkPipelineTessellationStateCreateFlags": "",
  "VkPipelineTessellationStateCreateFlags.__none": "",
  "VkPipelineTessellationStateCreateInfo": "Structure specifying parameters of a newly created pipeline tessellation state.",
  "VkPipelineTessellationStateCreateInfo.flags": "Reserved for future use.",
  "VkPipelineTessellationStateCreateInfo.patchControlPoints": "patchControlPoints number of control points per patch.",
  "VkPipelineTessellationStateCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkPipelineTessellationStateCreateInfo.sType": "The type of this structure.",
  "VkPipelineVertexInputStateCreateFlagBits": "",
  "VkPipelineVertexInputStateCreateFlags": "",
  "VkPipelineVertexInputStateCreateFlags.__none": "",
  "VkPipelineVertexInputStateCreateInfo": "Structure specifying parameters of a newly created pipeline vertex input state.",
  "VkPipelineVertexInputStateCreateInfo.flags": "Reserved for future use.",
  "VkPipelineVertexInputStateCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkPipelineVertexInputStateCreateInfo.pVertexAttributeDescriptions": "An array of VertexInputAttributeDescription structures.",
  "VkPipelineVertexInputStateCreateInfo.pVertexBindingDescriptions": "An array of VertexInputBindingDescription structures.",
  "VkPipelineVertexInputStateCreateInfo.sType": "The type of this structure.",
  "VkPipelineVertexInputStateCreateInfo.vertexAttributeDescriptionCount": "The number of vertex attribute descriptions provided in pVertexAttributeDescriptions.",
  "VkPipelineVertexInputStateCreateInfo.vertexBindingDescriptionCount": "The number of vertex binding descriptions provided in pVertexBindingDescriptions.",
  "VkPipelineViewportStateCreateFlagBits": "",
  "VkPipelineViewportStateCreateFlags": "",
  "VkPipelineViewportStateCreateFlags.__none": "",
  "VkPipelineViewportStateCreateInfo": "Structure specifying parameters of a newly created pipeline viewport state.",
  "VkPipelineViewportStateCreateInfo.flags": "Reserved for future use.",
  "VkPipelineViewportStateCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkPipelineViewportStateCreateInfo.pScissors": "An array of Rect2D structures which define the rectangular bounds of the scissor for the corresponding viewport. If the scissor state is dynamic, this member is ignored.",
  "VkPipelineViewportStateCreateInfo.pViewports": "An array of Viewport structures, defining the viewport transforms. If the viewport state is dynamic, this member is ignored.",
  "VkPipelineViewportStateCreateInfo.scissorCount": "The number of scissors and must match the number of viewports.",
  "VkPipelineViewportStateCreateInfo.sType": "The type of this structure.",
  "VkPipelineViewportStateCreateInfo.viewportCount": "The number of viewports used by the pipeline.",
  "VkPipelineViewportSwizzleStateCreateFlagsNV": "",
  "VkPipelineViewportSwizzleStateCreateFlagsNV.__none": "",
  "VkPipelineViewportSwizzleStateCreateInfoNV": "",
  "VkPipelineViewportSwizzleStateCreateInfoNV.flags": "",
  "VkPipelineViewportSwizzleStateCreateInfoNV.pNext": "",
  "VkPipelineViewportSwizzleStateCreateInfoNV.pViewportSwizzles": "",
  "VkPipelineViewportSwizzleStateCreateInfoNV.sType": "",
  "VkPipelineViewportSwizzleStateCreateInfoNV.viewportCount": "",
  "VkPipelineViewportWScalingStateCreateInfoNV": "Structure specifying parameters of a newly created pipeline viewport W scaling state.",
  "VkPipelineViewportWScalingStateCreateInfoNV.pNext": "Null or an extension-specific structure",
  "VkPipelineViewportWScalingStateCreateInfoNV.pViewportWScalings": "An array of ViewportWScalingNV structures which define the W scaling parameters for the corresponding viewport. If the viewport W scaling state is dynamic, this member is ignored.",
  "VkPipelineViewportWScalingStateCreateInfoNV.sType": "The type of this structure",
  "VkPipelineViewportWScalingStateCreateInfoNV.viewportCount": "The number of viewports used by W scaling and must match the number of viewports in the pipeline if viewport W scaling is enabled.",
  "VkPipelineViewportWScalingStateCreateInfoNV.viewportWScalingEnable": "The enable for viewport W scaling",
  "VkPointClippingBehaviorKHR": "",
  "VkPointClippingBehaviorKHR.VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR": "",
  "VkPointClippingBehaviorKHR.VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR": "",
  "VkPolygonMode": "Control polygon rasterization mode.",
  "VkPolygonMode.VK_POLYGON_MODE_FILL": "",
  "VkPolygonMode.VK_POLYGON_MODE_FILL_RECTANGLE_NV": "",
  "VkPolygonMode.VK_POLYGON_MODE_LINE": "",
  "VkPolygonMode.VK_POLYGON_MODE_POINT": "",
  "VkPresentInfoKHR": "Structure describing parameters of a queue presentation.",
  "VkPresentInfoKHR.pImageIndices": "An array of indices into the array of each swapchain's presentable images, with swapchainCount entries. Each entry in this array identifies the image to present on the corresponding entry in the pSwapchains array.",
  "VkPresentInfoKHR.pNext": "Null or an extension-specific structure.",
  "VkPresentInfoKHR.pResults": "An array of Result typed elements with swapchainCount entries. Applications that do not need per-swapchain results can use Null for pResults. If non-Null, each entry in pResults will be set to the Result for presenting the swapchain corresponding to the same index in pSwapchains.",
  "VkPresentInfoKHR.pSwapchains": "An array of SwapchainKHR objects with swapchainCount entries. A given swapchain must not appear in this list more than once.",
  "VkPresentInfoKHR.pWaitSemaphores": "If not Null, is an array of Semaphore objects with waitSemaphoreCount entries, and specifies the semaphores to wait for before issuing the present request.",
  "VkPresentInfoKHR.sType": "The type of this structure.",
  "VkPresentInfoKHR.swapchainCount": "The number of swapchains being presented to by this command.",
  "VkPresentInfoKHR.waitSemaphoreCount": "The number of semaphores to wait for before issuing the present request. The number may be zero.",
  "VkPresentModeKHR": "Presentation mode supported for a surface.",
  "VkPresentModeKHR.VK_PRESENT_MODE_FIFO_KHR": "The presentation engine waits for the next vertical blanking period to update the current image. Tearing cannot: be observed. An internal queue is used to hold pending presentation requests. New requests are appended to the end of the queue, and one request is removed from the beginning of the queue and processed during each vertical blanking period in which the queue is non-empty. This is the only value of presentMode that is required: to be supported.",
  "VkPresentModeKHR.VK_PRESENT_MODE_FIFO_RELAXED_KHR": "The presentation engine generally waits for the next vertical blanking period to update the current image. If a vertical blanking period has already passed since the last update of the current image then the presentation engine does not wait for another vertical blanking period for the update, meaning this mode may result in visible tearing in this case. This mode is useful for reducing visual stutter with an application that will mostly present a new image before the next vertical blanking period, but may occasionally be late, and present a new image just after the next vertical blanking period. An internal queue is used to hold pending presentation requests. New requests are appended to the end of the queue, and one request is removed from the beginning of the queue and processed during or after each vertical blanking period in which the queue is non-empty.",
  "VkPresentModeKHR.VK_PRESENT_MODE_IMMEDIATE_KHR": "The presentation engine does not wait for a vertical blanking period to update the current image, meaning this mode may result in visible tearing. No internal queuing of presentation requests is needed, as the requests are applied immediately.",
  "VkPresentModeKHR.VK_PRESENT_MODE_MAILBOX_KHR": "The presentation engine waits for the next vertical blanking period to update the current image. Tearing cannot: be observed. An internal single-entry queue is used to hold pending presentation requests. If the queue is full when a new presentation request is received, the new request replaces the existing entry, and any images associated with the prior entry become available for re-use by the application. One request is removed from the queue and processed during each vertical blanking period in which the queue is non-empty.",
  "VkPresentModeKHR.VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR": "",
  "VkPresentModeKHR.VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR": "",
  "VkPresentRegionKHR": "",
  "VkPresentRegionKHR.pRectangles": "",
  "VkPresentRegionKHR.rectangleCount": "",
  "VkPresentRegionsKHR": "",
  "VkPresentRegionsKHR.pNext": "",
  "VkPresentRegionsKHR.pRegions": "",
  "VkPresentRegionsKHR.sType": "",
  "VkPresentRegionsKHR.swapchainCount": "",
  "VkPresentTimeGOOGLE": "",
  "VkPresentTimeGOOGLE.desiredPresentTime": "",
  "VkPresentTimeGOOGLE.presentID": "",
  "VkPresentTimesInfoGOOGLE": "",
  "VkPresentTimesInfoGOOGLE.pNext": "",
  "VkPresentTimesInfoGOOGLE.pTimes": "",
  "VkPresentTimesInfoGOOGLE.sType": "",
  "VkPresentTimesInfoGOOGLE.swapchainCount": "",
  "VkPrimitiveTopology": "Supported primitive topologies.",
  "VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_LINE_LIST": "",
  "VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY": "",
  "VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_LINE_STRIP": "",
  "VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY": "",
  "VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_PATCH_LIST": "",
  "VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_POINT_LIST": "",
  "VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN": "",
  "VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST": "",
  "VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY": "",
  "VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP": "",
  "VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY": "",
  "VkPushConstantRange": "Structure specifying a push constant range.",
  "VkPushConstantRange.offset": "offset and size are the start offset and size, respectively, consumed by the range. Both offset and size are in units of bytes and must be a multiple of 4. The layout of the push constant variables is specified in the shader.",
  "VkPushConstantRange.size": "",
  "VkPushConstantRange.stageFlags": "A set of stage flags describing the shader stages that will access a range of push constants. If a particular stage is not included in the range, then accessing members of that range of push constants from the corresponding shader stage will result in undefined data being read.",
  "VkQueryControlFlagBits": "Bitmask specifying constraints on a query.",
  "VkQueryControlFlagBits.__none": "",
  "VkQueryControlFlagBits.VK_QUERY_CONTROL_PRECISE_BIT": "",
  "VkQueryControlFlags": "",
  "VkQueryPipelineStatisticFlagBits": "Bitmask specifying queried pipeline statistics.",
  "VkQueryPipelineStatisticFlagBits.__none": "",
  "VkQueryPipelineStatisticFlagBits.VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT": "",
  "VkQueryPipelineStatisticFlagBits.VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT": "",
  "VkQueryPipelineStatisticFlagBits.VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT": "",
  "VkQueryPipelineStatisticFlagBits.VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT": "",
  "VkQueryPipelineStatisticFlagBits.VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT": "",
  "VkQueryPipelineStatisticFlagBits.VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT": "",
  "VkQueryPipelineStatisticFlagBits.VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT": "",
  "VkQueryPipelineStatisticFlagBits.VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT": "",
  "VkQueryPipelineStatisticFlagBits.VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT": "",
  "VkQueryPipelineStatisticFlagBits.VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT": "",
  "VkQueryPipelineStatisticFlagBits.VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT": "",
  "VkQueryPipelineStatisticFlags": "",
  "VkQueryPool": "Opaque handle to a query pool object.",
  "VkQueryPoolCreateFlagBits": "",
  "VkQueryPoolCreateFlags": "",
  "VkQueryPoolCreateFlags.__none": "",
  "VkQueryPoolCreateInfo": "Structure specifying parameters of a newly created query pool.",
  "VkQueryPoolCreateInfo.flags": "Reserved for future use.",
  "VkQueryPoolCreateInfo.pipelineStatistics": "",
  "VkQueryPoolCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkQueryPoolCreateInfo.queryCount": "",
  "VkQueryPoolCreateInfo.queryType": "The type of queries managed by the pool.",
  "VkQueryPoolCreateInfo.sType": "The type of this structure.",
  "VkQueryResultFlagBits": "Bitmask specifying how and when query results are returned.",
  "VkQueryResultFlagBits.__none": "",
  "VkQueryResultFlagBits.VK_QUERY_RESULT_64_BIT": "",
  "VkQueryResultFlagBits.VK_QUERY_RESULT_PARTIAL_BIT": "",
  "VkQueryResultFlagBits.VK_QUERY_RESULT_WAIT_BIT": "",
  "VkQueryResultFlagBits.VK_QUERY_RESULT_WITH_AVAILABILITY_BIT": "",
  "VkQueryResultFlags": "",
  "VkQueryType": "Specify the type of queries managed by a query pool.",
  "VkQueryType.VK_QUERY_TYPE_OCCLUSION": "",
  "VkQueryType.VK_QUERY_TYPE_PIPELINE_STATISTICS": "",
  "VkQueryType.VK_QUERY_TYPE_TIMESTAMP": "",
  "VkQueue": "Opaque handle to a queue object.",
  "vkQueueBindSparse": "Bind device memory to a sparse resource object.",
  "vkQueueBindSparse.bindInfoCount": "",
  "vkQueueBindSparse.fence": "",
  "vkQueueBindSparse.pBindInfo": "",
  "vkQueueBindSparse.queue": "",
  "VkQueueFamilyProperties": "Structure providing information about a queue family.",
  "VkQueueFamilyProperties.minImageTransferGranularity": "The minimum granularity supported for image transfer operations on the queues in this queue family.",
  "VkQueueFamilyProperties.queueCount": "The unsigned integer count of queues in this queue family.",
  "VkQueueFamilyProperties.queueFlags": "queueFlags contains flags indicating the capabilities of the queues in this queue family.",
  "VkQueueFamilyProperties.timestampValidBits": "The unsigned integer count of meaningful bits in the timestamps written via fname:vkCmdWriteTimestamp. The valid range for the count is 36..64 bits, or a value of 0, indicating no support for timestamps. Bits outside the valid range are guaranteed to be zeros.",
  "VkQueueFamilyProperties2KHR": "Structure providing information about a queue family.",
  "VkQueueFamilyProperties2KHR.pNext": "Null or an extension-specific structure.",
  "VkQueueFamilyProperties2KHR.queueFamilyProperties": "A structure of type QueueFamilyProperties which is populated with the same values as in flink:vkGetPhysicalDeviceQueueFamilyProperties.",
  "VkQueueFamilyProperties2KHR.sType": "The type of this structure.",
  "VkQueueFlagBits": "Bitmask specifying capabilities of queues in a queue family.",
  "VkQueueFlagBits.__none": "",
  "VkQueueFlagBits.VK_QUEUE_COMPUTE_BIT": "The queues in this queue family support compute operations.",
  "VkQueueFlagBits.VK_QUEUE_GRAPHICS_BIT": "The queues in this queue family support graphics operations.",
  "VkQueueFlagBits.VK_QUEUE_SPARSE_BINDING_BIT": "The queues in this queue family support sparse memory management operations. If any of the sparse resource features are enabled, then at least one queue family must support this bit.",
  "VkQueueFlagBits.VK_QUEUE_TRANSFER_BIT": "The queues in this queue family support transfer operations.",
  "VkQueueFlags": "",
  "VkQueueGlobalPriorityEXT": "",
  "VkQueueGlobalPriorityEXT.VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT": "",
  "VkQueueGlobalPriorityEXT.VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT": "",
  "VkQueueGlobalPriorityEXT.VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT": "",
  "VkQueueGlobalPriorityEXT.VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT": "",
  "vkQueuePresentKHR": "Queue an image for presentation.",
  "vkQueuePresentKHR.pPresentInfo": "",
  "vkQueuePresentKHR.queue": "",
  "vkQueueSubmit": "Submits a sequence of semaphores or command buffers to a queue.",
  "vkQueueSubmit.fence": "",
  "vkQueueSubmit.pSubmits": "",
  "vkQueueSubmit.queue": "",
  "vkQueueSubmit.submitCount": "",
  "vkQueueWaitIdle": "Wait for a queue to become idle.",
  "vkQueueWaitIdle.queue": "",
  "VkRasterizationOrderAMD": "",
  "VkRasterizationOrderAMD.VK_RASTERIZATION_ORDER_RELAXED_AMD": "",
  "VkRasterizationOrderAMD.VK_RASTERIZATION_ORDER_STRICT_AMD": "",
  "VkRect2D": "Structure specifying a two-dimensional subregion.",
  "VkRect2D.extent": "",
  "VkRect2D.offset": "",
  "VkRectLayerKHR": "",
  "VkRectLayerKHR.extent": "",
  "VkRectLayerKHR.layer": "",
  "VkRectLayerKHR.offset": "",
  "VkRefreshCycleDurationGOOGLE": "",
  "VkRefreshCycleDurationGOOGLE.refreshDuration": "",
  "vkRegisterDeviceEventEXT": "Signal a fence when a device event occurs.",
  "vkRegisterDeviceEventEXT.device": "",
  "vkRegisterDeviceEventEXT.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkRegisterDeviceEventEXT.pDeviceEventInfo": "",
  "vkRegisterDeviceEventEXT.pFence": "",
  "vkRegisterDisplayEventEXT": "Signal a fence when a display event occurs.",
  "vkRegisterDisplayEventEXT.device": "",
  "vkRegisterDisplayEventEXT.display": "",
  "vkRegisterDisplayEventEXT.pAllocator": "An optional AllocationCallbacks instance that controls host memory allocation.",
  "vkRegisterDisplayEventEXT.pDisplayEventInfo": "",
  "vkRegisterDisplayEventEXT.pFence": "",
  "vkRegisterObjectsNVX": "",
  "vkRegisterObjectsNVX.device": "",
  "vkRegisterObjectsNVX.objectCount": "",
  "vkRegisterObjectsNVX.objectTable": "",
  "vkRegisterObjectsNVX.pObjectIndices": "",
  "vkRegisterObjectsNVX.ppObjectTableEntries": "",
  "vkReleaseDisplayEXT": "Release access to an acquired Display.",
  "vkReleaseDisplayEXT.display": "",
  "vkReleaseDisplayEXT.physicalDevice": "",
  "VkRenderPass": "Opaque handle to a render pass object.",
  "VkRenderPassBeginInfo": "Structure specifying render pass begin info.",
  "VkRenderPassBeginInfo.clearValueCount": "The number of elements in pClearValues.",
  "VkRenderPassBeginInfo.framebuffer": "The framebuffer containing the attachments that are used with the render pass.",
  "VkRenderPassBeginInfo.pClearValues": "An array of ClearValue structures that contains clear values for each attachment, if the attachment uses a loadOp value of VK_ATTACHMENT_LOAD_OP_CLEAR or if the attachment has a depth/stencil format and uses a stencilLoadOp value of VK_ATTACHMENT_LOAD_OP_CLEAR. The array is indexed by attachment number. Only elements corresponding to cleared attachments are used. Other elements of pClearValues are ignored.",
  "VkRenderPassBeginInfo.pNext": "Null or an extension-specific structure.",
  "VkRenderPassBeginInfo.renderArea": "The render area that is affected by the render pass instance, and is described in more detail below.",
  "VkRenderPassBeginInfo.renderPass": "The render pass to begin an instance of.",
  "VkRenderPassBeginInfo.sType": "The type of this structure.",
  "VkRenderPassCreateFlagBits": "",
  "VkRenderPassCreateFlags": "",
  "VkRenderPassCreateFlags.__none": "",
  "VkRenderPassCreateInfo": "Structure specifying parameters of a newly created render pass.",
  "VkRenderPassCreateInfo.attachmentCount": "The number of attachments used by this render pass, or zero indicating no attachments. Attachments are referred to by zero-based indices in the range [0,attachmentCount).",
  "VkRenderPassCreateInfo.dependencyCount": "The number of dependencies between pairs of subpasses, or zero indicating no dependencies.",
  "VkRenderPassCreateInfo.flags": "Reserved for future use.",
  "VkRenderPassCreateInfo.pAttachments": "An array of attachmentCount number of AttachmentDescription structures describing properties of the attachments, or Null if attachmentCount is zero.",
  "VkRenderPassCreateInfo.pDependencies": "An array of dependencyCount number of SubpassDependency structures describing dependencies between pairs of subpasses, or Null if dependencyCount is zero.",
  "VkRenderPassCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkRenderPassCreateInfo.pSubpasses": "An array of SubpassDescription structures describing properties of the subpasses.",
  "VkRenderPassCreateInfo.sType": "The type of this structure.",
  "VkRenderPassCreateInfo.subpassCount": "The number of subpasses to create for this render pass. Subpasses are referred to by zero-based indices in the range [0,subpassCount). A render pass must have at least one subpass.",
  "VkRenderPassInputAttachmentAspectCreateInfoKHR": "",
  "VkRenderPassInputAttachmentAspectCreateInfoKHR.aspectReferenceCount": "",
  "VkRenderPassInputAttachmentAspectCreateInfoKHR.pAspectReferences": "",
  "VkRenderPassInputAttachmentAspectCreateInfoKHR.pNext": "",
  "VkRenderPassInputAttachmentAspectCreateInfoKHR.sType": "",
  "VkRenderPassMultiviewCreateInfoKHX": "Structure containing multiview info for all subpasses.",
  "VkRenderPassMultiviewCreateInfoKHX.correlationMaskCount": "correlationMaskCount is zero or a number of correlation masks.",
  "VkRenderPassMultiviewCreateInfoKHX.dependencyCount": "dependencyCount is zero or the number of dependencies in the render pass.",
  "VkRenderPassMultiviewCreateInfoKHX.pCorrelationMasks": "An array of view masks indicating sets of views that may be more efficient to render concurrently.",
  "VkRenderPassMultiviewCreateInfoKHX.pNext": "Null or an extension-specific structure.",
  "VkRenderPassMultiviewCreateInfoKHX.pViewMasks": "An array of view masks, where each mask is a bitfield of view indices describing which views rendering is broadcast to in each subpass, when multiview is enabled. If subpassCount is zero, each view mask is treated as zero.",
  "VkRenderPassMultiviewCreateInfoKHX.pViewOffsets": "An array of dependencyCount view offsets, one for each dependency. If dependencyCount is zero, each dependency's view offset is treated as zero. Each view offset controls which views in the source subpass the views in the destination subpass depend on.",
  "VkRenderPassMultiviewCreateInfoKHX.sType": "The type of this structure.",
  "VkRenderPassMultiviewCreateInfoKHX.subpassCount": "Zero or is the number of subpasses in the render pass.",
  "VkRenderPassSampleLocationsBeginInfoEXT": "",
  "VkRenderPassSampleLocationsBeginInfoEXT.attachmentInitialSampleLocationsCount": "",
  "VkRenderPassSampleLocationsBeginInfoEXT.pAttachmentInitialSampleLocations": "",
  "VkRenderPassSampleLocationsBeginInfoEXT.pNext": "",
  "VkRenderPassSampleLocationsBeginInfoEXT.postSubpassSampleLocationsCount": "",
  "VkRenderPassSampleLocationsBeginInfoEXT.pPostSubpassSampleLocations": "",
  "VkRenderPassSampleLocationsBeginInfoEXT.sType": "",
  "vkResetCommandBuffer": "Reset a command buffer.",
  "vkResetCommandBuffer.commandBuffer": "",
  "vkResetCommandBuffer.flags": "",
  "vkResetCommandPool": "Reset a command pool.",
  "vkResetCommandPool.commandPool": "",
  "vkResetCommandPool.device": "",
  "vkResetCommandPool.flags": "",
  "vkResetDescriptorPool": "Resets a descriptor pool object.",
  "vkResetDescriptorPool.descriptorPool": "",
  "vkResetDescriptorPool.device": "",
  "vkResetDescriptorPool.flags": "",
  "vkResetEvent": "Reset an event to non-signaled state.",
  "vkResetEvent.device": "",
  "vkResetEvent.event": "",
  "vkResetFences": "Resets one or more fence objects.",
  "vkResetFences.device": "",
  "vkResetFences.fenceCount": "",
  "vkResetFences.pFences": "",
  "VkResult": "Vulkan command return codes.",
  "VkResult.VK_ERROR_DEVICE_LOST": "",
  "VkResult.VK_ERROR_EXTENSION_NOT_PRESENT": "",
  "VkResult.VK_ERROR_FEATURE_NOT_PRESENT": "",
  "VkResult.VK_ERROR_FORMAT_NOT_SUPPORTED": "",
  "VkResult.VK_ERROR_FRAGMENTED_POOL": "",
  "VkResult.VK_ERROR_INCOMPATIBLE_DISPLAY_KHR": "",
  "VkResult.VK_ERROR_INCOMPATIBLE_DRIVER": "",
  "VkResult.VK_ERROR_INITIALIZATION_FAILED": "",
  "VkResult.VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR": "",
  "VkResult.VK_ERROR_INVALID_SHADER_NV": "",
  "VkResult.VK_ERROR_LAYER_NOT_PRESENT": "",
  "VkResult.VK_ERROR_MEMORY_MAP_FAILED": "",
  "VkResult.VK_ERROR_NATIVE_WINDOW_IN_USE_KHR": "",
  "VkResult.VK_ERROR_NOT_PERMITTED_EXT": "",
  "VkResult.VK_ERROR_OUT_OF_DATE_KHR": "",
  "VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY": "",
  "VkResult.VK_ERROR_OUT_OF_HOST_MEMORY": "",
  "VkResult.VK_ERROR_OUT_OF_POOL_MEMORY_KHR": "",
  "VkResult.VK_ERROR_SURFACE_LOST_KHR": "",
  "VkResult.VK_ERROR_TOO_MANY_OBJECTS": "",
  "VkResult.VK_ERROR_VALIDATION_FAILED_EXT": "",
  "VkResult.VK_EVENT_RESET": "",
  "VkResult.VK_EVENT_SET": "",
  "VkResult.VK_INCOMPLETE": "",
  "VkResult.VK_NOT_READY": "",
  "VkResult.VK_SUBOPTIMAL_KHR": "",
  "VkResult.VK_SUCCESS": "",
  "VkResult.VK_TIMEOUT": "",
  "VkSampleCountFlagBits": "Bitmask specifying sample counts supported for an image used for storage operations.",
  "VkSampleCountFlagBits.__none": "",
  "VkSampleCountFlagBits.VK_SAMPLE_COUNT_1_BIT": "",
  "VkSampleCountFlagBits.VK_SAMPLE_COUNT_16_BIT": "",
  "VkSampleCountFlagBits.VK_SAMPLE_COUNT_2_BIT": "",
  "VkSampleCountFlagBits.VK_SAMPLE_COUNT_32_BIT": "",
  "VkSampleCountFlagBits.VK_SAMPLE_COUNT_4_BIT": "",
  "VkSampleCountFlagBits.VK_SAMPLE_COUNT_64_BIT": "",
  "VkSampleCountFlagBits.VK_SAMPLE_COUNT_8_BIT": "",
  "VkSampleCountFlags": "",
  "VkSampleLocationEXT": "",
  "VkSampleLocationEXT.x": "",
  "VkSampleLocationEXT.y": "",
  "VkSampleLocationsInfoEXT": "",
  "VkSampleLocationsInfoEXT.pNext": "",
  "VkSampleLocationsInfoEXT.pSampleLocations": "",
  "VkSampleLocationsInfoEXT.sampleLocationGridSize": "",
  "VkSampleLocationsInfoEXT.sampleLocationsCount": "",
  "VkSampleLocationsInfoEXT.sampleLocationsPerPixel": "",
  "VkSampleLocationsInfoEXT.sType": "",
  "VkSampler": "Opaque handle to a sampler object.",
  "VkSamplerAddressMode": "Specify behavior of sampling with texture coordinates outside an image.",
  "VkSamplerAddressMode.VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER": "Indicates that the clamp to border wrap mode will be used.",
  "VkSamplerAddressMode.VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE": "Indicates that the clamp to edge wrap mode will be used.",
  "VkSamplerAddressMode.VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE": "Indicates that the mirror clamp to edge wrap mode will be used. This is only valid if the \"VK_KHR_mirror_clamp_to_edge\" extension is enabled.",
  "VkSamplerAddressMode.VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT": "Indicates that the mirrored repeat wrap mode will be used.",
  "VkSamplerAddressMode.VK_SAMPLER_ADDRESS_MODE_REPEAT": "Indicates that the repeat wrap mode will be used.",
  "VkSamplerCreateFlagBits": "",
  "VkSamplerCreateFlags": "",
  "VkSamplerCreateFlags.__none": "",
  "VkSamplerCreateInfo": "Structure specifying parameters of a newly created sampler.",
  "VkSamplerCreateInfo.addressModeU": "",
  "VkSamplerCreateInfo.addressModeV": "",
  "VkSamplerCreateInfo.addressModeW": "",
  "VkSamplerCreateInfo.anisotropyEnable": "",
  "VkSamplerCreateInfo.borderColor": "",
  "VkSamplerCreateInfo.compareEnable": "",
  "VkSamplerCreateInfo.compareOp": "",
  "VkSamplerCreateInfo.flags": "Reserved for future use.",
  "VkSamplerCreateInfo.magFilter": "The magnification filter to apply to lookups.",
  "VkSamplerCreateInfo.maxAnisotropy": "",
  "VkSamplerCreateInfo.maxLod": "",
  "VkSamplerCreateInfo.minFilter": "",
  "VkSamplerCreateInfo.minLod": "",
  "VkSamplerCreateInfo.mipLodBias": "",
  "VkSamplerCreateInfo.mipmapMode": "",
  "VkSamplerCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkSamplerCreateInfo.sType": "The type of this structure.",
  "VkSamplerCreateInfo.unnormalizedCoordinates": "",
  "VkSamplerMipmapMode": "Specify mipmap mode used for texture lookups.",
  "VkSamplerMipmapMode.VK_SAMPLER_MIPMAP_MODE_LINEAR": "",
  "VkSamplerMipmapMode.VK_SAMPLER_MIPMAP_MODE_NEAREST": "",
  "VkSamplerReductionModeCreateInfoEXT": "",
  "VkSamplerReductionModeCreateInfoEXT.pNext": "",
  "VkSamplerReductionModeCreateInfoEXT.reductionMode": "",
  "VkSamplerReductionModeCreateInfoEXT.sType": "",
  "VkSamplerReductionModeEXT": "",
  "VkSamplerReductionModeEXT.VK_SAMPLER_REDUCTION_MODE_MAX_EXT": "",
  "VkSamplerReductionModeEXT.VK_SAMPLER_REDUCTION_MODE_MIN_EXT": "",
  "VkSamplerReductionModeEXT.VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT": "",
  "VkSamplerYcbcrConversionCreateInfoKHR": "",
  "VkSamplerYcbcrConversionCreateInfoKHR.chromaFilter": "",
  "VkSamplerYcbcrConversionCreateInfoKHR.components": "",
  "VkSamplerYcbcrConversionCreateInfoKHR.forceExplicitReconstruction": "",
  "VkSamplerYcbcrConversionCreateInfoKHR.format": "",
  "VkSamplerYcbcrConversionCreateInfoKHR.pNext": "",
  "VkSamplerYcbcrConversionCreateInfoKHR.sType": "",
  "VkSamplerYcbcrConversionCreateInfoKHR.xChromaOffset": "",
  "VkSamplerYcbcrConversionCreateInfoKHR.ycbcrModel": "",
  "VkSamplerYcbcrConversionCreateInfoKHR.ycbcrRange": "",
  "VkSamplerYcbcrConversionCreateInfoKHR.yChromaOffset": "",
  "VkSamplerYcbcrConversionImageFormatPropertiesKHR": "",
  "VkSamplerYcbcrConversionImageFormatPropertiesKHR.combinedImageSamplerDescriptorCount": "",
  "VkSamplerYcbcrConversionImageFormatPropertiesKHR.pNext": "",
  "VkSamplerYcbcrConversionImageFormatPropertiesKHR.sType": "",
  "VkSamplerYcbcrConversionInfoKHR": "",
  "VkSamplerYcbcrConversionInfoKHR.conversion": "",
  "VkSamplerYcbcrConversionInfoKHR.pNext": "",
  "VkSamplerYcbcrConversionInfoKHR.sType": "",
  "VkSamplerYcbcrConversionKHR": "",
  "VkSamplerYcbcrModelConversionKHR": "",
  "VkSamplerYcbcrModelConversionKHR.VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR": "",
  "VkSamplerYcbcrModelConversionKHR.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR": "",
  "VkSamplerYcbcrModelConversionKHR.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR": "",
  "VkSamplerYcbcrModelConversionKHR.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR": "",
  "VkSamplerYcbcrModelConversionKHR.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR": "",
  "VkSamplerYcbcrRangeKHR": "",
  "VkSamplerYcbcrRangeKHR.VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR": "",
  "VkSamplerYcbcrRangeKHR.VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR": "",
  "VkSemaphore": "Opaque handle to a semaphore object.",
  "VkSemaphoreCreateFlags": "",
  "VkSemaphoreCreateFlags.__none": "",
  "VkSemaphoreCreateInfo": "Structure specifying parameters of a newly created semaphore.",
  "VkSemaphoreCreateInfo.flags": "Reserved for future use.",
  "VkSemaphoreCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkSemaphoreCreateInfo.sType": "The type of this structure.",
  "VkSemaphoreGetFdInfoKHR": "",
  "VkSemaphoreGetFdInfoKHR.handleType": "",
  "VkSemaphoreGetFdInfoKHR.pNext": "",
  "VkSemaphoreGetFdInfoKHR.semaphore": "",
  "VkSemaphoreGetFdInfoKHR.sType": "",
  "VkSemaphoreGetWin32HandleInfoKHR": "",
  "VkSemaphoreGetWin32HandleInfoKHR.handleType": "",
  "VkSemaphoreGetWin32HandleInfoKHR.pNext": "",
  "VkSemaphoreGetWin32HandleInfoKHR.semaphore": "",
  "VkSemaphoreGetWin32HandleInfoKHR.sType": "",
  "VkSemaphoreImportFlagBitsKHR": "",
  "VkSemaphoreImportFlagBitsKHR.__none": "",
  "VkSemaphoreImportFlagBitsKHR.VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR": "",
  "VkSemaphoreImportFlagsKHR": "",
  "vkSetEvent": "Set an event to signaled state.",
  "vkSetEvent.device": "",
  "vkSetEvent.event": "",
  "vkSetHdrMetadataEXT": "",
  "vkSetHdrMetadataEXT.device": "",
  "vkSetHdrMetadataEXT.pMetadata": "",
  "vkSetHdrMetadataEXT.pSwapchains": "",
  "vkSetHdrMetadataEXT.swapchainCount": "",
  "VkShaderInfoTypeAMD": "",
  "VkShaderInfoTypeAMD.VK_SHADER_INFO_TYPE_BINARY_AMD": "",
  "VkShaderInfoTypeAMD.VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD": "",
  "VkShaderInfoTypeAMD.VK_SHADER_INFO_TYPE_STATISTICS_AMD": "",
  "VkShaderModule": "Opaque handle to a shader module object.",
  "VkShaderModuleCreateFlags": "",
  "VkShaderModuleCreateFlags.__none": "",
  "VkShaderModuleCreateInfo": "Structure specifying parameters of a newly created shader module.",
  "VkShaderModuleCreateInfo.codeSize": "The size, in bytes, of the code pointed to by pCode.",
  "VkShaderModuleCreateInfo.flags": "Reserved for future use.",
  "VkShaderModuleCreateInfo.pCode": "pCode points to code that is used to create the shader module. The type and format of the code is determined from the content of the memory addressed by pCode.",
  "VkShaderModuleCreateInfo.pNext": "Null or an extension-specific structure.",
  "VkShaderModuleCreateInfo.sType": "The type of this structure.",
  "VkShaderModuleValidationCacheCreateInfoEXT": "",
  "VkShaderModuleValidationCacheCreateInfoEXT.pNext": "",
  "VkShaderModuleValidationCacheCreateInfoEXT.sType": "",
  "VkShaderModuleValidationCacheCreateInfoEXT.validationCache": "",
  "VkShaderResourceUsageAMD": "",
  "VkShaderResourceUsageAMD.ldsSizePerLocalWorkGroup": "",
  "VkShaderResourceUsageAMD.ldsUsageSizeInBytes": "",
  "VkShaderResourceUsageAMD.numUsedSgprs": "",
  "VkShaderResourceUsageAMD.numUsedVgprs": "",
  "VkShaderResourceUsageAMD.scratchMemUsageInBytes": "",
  "VkShaderStageFlagBits": "Bitmask specifying a pipeline stage.",
  "VkShaderStageFlagBits.__none": "",
  "VkShaderStageFlagBits.VK_SHADER_STAGE_ALL": "",
  "VkShaderStageFlagBits.VK_SHADER_STAGE_ALL_GRAPHICS": "",
  "VkShaderStageFlagBits.VK_SHADER_STAGE_COMPUTE_BIT": "",
  "VkShaderStageFlagBits.VK_SHADER_STAGE_FRAGMENT_BIT": "",
  "VkShaderStageFlagBits.VK_SHADER_STAGE_GEOMETRY_BIT": "",
  "VkShaderStageFlagBits.VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT": "",
  "VkShaderStageFlagBits.VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT": "",
  "VkShaderStageFlagBits.VK_SHADER_STAGE_VERTEX_BIT": "",
  "VkShaderStageFlags": "",
  "VkShaderStatisticsInfoAMD": "",
  "VkShaderStatisticsInfoAMD.computeWorkGroupSize": "",
  "VkShaderStatisticsInfoAMD.numAvailableSgprs": "",
  "VkShaderStatisticsInfoAMD.numAvailableVgprs": "",
  "VkShaderStatisticsInfoAMD.numPhysicalSgprs": "",
  "VkShaderStatisticsInfoAMD.numPhysicalVgprs": "",
  "VkShaderStatisticsInfoAMD.resourceUsage": "",
  "VkShaderStatisticsInfoAMD.shaderStageMask": "",
  "VkSharedPresentSurfaceCapabilitiesKHR": "",
  "VkSharedPresentSurfaceCapabilitiesKHR.pNext": "",
  "VkSharedPresentSurfaceCapabilitiesKHR.sharedPresentSupportedUsageFlags": "",
  "VkSharedPresentSurfaceCapabilitiesKHR.sType": "",
  "VkSharingMode": "Buffer and image sharing modes.",
  "VkSharingMode.VK_SHARING_MODE_CONCURRENT": "Specifies that concurrent access to any range or image subresource of the object from multiple queue families is supported.",
  "VkSharingMode.VK_SHARING_MODE_EXCLUSIVE": "Specifies that access to any range or image subresource of the object will be exclusive to a single queue family at a time.",
  "VkSparseBufferMemoryBindInfo": "Structure specifying a sparse buffer memory bind operation.",
  "VkSparseBufferMemoryBindInfo.bindCount": "The number of SparseMemoryBind structures in the pBinds array.",
  "VkSparseBufferMemoryBindInfo.buffer": "The Buffer object to be bound.",
  "VkSparseBufferMemoryBindInfo.pBinds": "Array of SparseMemoryBind structures.",
  "VkSparseImageFormatFlagBits": "Bitmask specifying additional information about a sparse image resource.",
  "VkSparseImageFormatFlagBits.__none": "",
  "VkSparseImageFormatFlagBits.VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT": "",
  "VkSparseImageFormatFlagBits.VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT": "",
  "VkSparseImageFormatFlagBits.VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT": "",
  "VkSparseImageFormatFlags": "",
  "VkSparseImageFormatProperties": "Structure specifying sparse image format properties.",
  "VkSparseImageFormatProperties.aspectMask": "A bitmask of ImageAspectFlagBits specifying which aspects of the image the properties apply to.",
  "VkSparseImageFormatProperties.flags": "A bitmask specifying additional information about the sparse resource. Bits which can be set include: + --",
  "VkSparseImageFormatProperties.imageGranularity": "The width, height, and depth of the sparse image block in texels or compressed texel blocks.",
  "VkSparseImageFormatProperties2KHR": "Structure specifying sparse image format properties.",
  "VkSparseImageFormatProperties2KHR.pNext": "Null or an extension-specific structure.",
  "VkSparseImageFormatProperties2KHR.properties": "A structure of type SparseImageFormatProperties which is populated with the same values as in flink:vkGetPhysicalDeviceSparseImageFormatProperties.",
  "VkSparseImageFormatProperties2KHR.sType": "The type of this structure.",
  "VkSparseImageMemoryBind": "Structure specifying sparse image memory bind.",
  "VkSparseImageMemoryBind.extent": "The size in texels of the region within the image subresource to bind. The extent must be a multiple of the sparse image block dimensions, except when binding sparse image blocks along the edge of an image subresource it can instead be such that any coordinate of [eq]#offset + extent# equals the corresponding dimensions of the image subresource.",
  "VkSparseImageMemoryBind.flags": "flags are sparse memory binding flags.",
  "VkSparseImageMemoryBind.memory": "The DeviceMemory object that the sparse image blocks of the image are bound to. If memory is null, the sparse image blocks are unbound.",
  "VkSparseImageMemoryBind.memoryOffset": "An offset into DeviceMemory object. If memory is null, this value is ignored.",
  "VkSparseImageMemoryBind.offset": "offset are the coordinates of the first texel within the image subresource to bind.",
  "VkSparseImageMemoryBind.subresource": "The aspectMask and region of interest in the image.",
  "VkSparseImageMemoryBindInfo": "Structure specifying sparse image memory bind info.",
  "VkSparseImageMemoryBindInfo.bindCount": "The number of SparseImageMemoryBind structures in pBinds array",
  "VkSparseImageMemoryBindInfo.image": "The Image object to be bound",
  "VkSparseImageMemoryBindInfo.pBinds": "Array of SparseImageMemoryBind structures",
  "VkSparseImageMemoryRequirements": "Structure specifying sparse image memory requirements.",
  "VkSparseImageMemoryRequirements.formatProperties": "",
  "VkSparseImageMemoryRequirements.imageMipTailFirstLod": "The first mip level at which image subresources are included in the mip tail region.",
  "VkSparseImageMemoryRequirements.imageMipTailOffset": "The opaque memory offset used with SparseImageOpaqueMemoryBindInfo to bind the mip tail region(s).",
  "VkSparseImageMemoryRequirements.imageMipTailSize": "The memory size (in bytes) of the mip tail region. If formatProperties.flags contains VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT, this is the size of the whole mip tail, otherwise this is the size of the mip tail of a single array layer. This value is guaranteed to be a multiple of the sparse block size in bytes.",
  "VkSparseImageMemoryRequirements.imageMipTailStride": "The offset stride between each array-layer's mip tail, if formatProperties.flags does not contain VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT (otherwise the value is undefined).",
  "VkSparseImageMemoryRequirements2KHR": "",
  "VkSparseImageMemoryRequirements2KHR.memoryRequirements": "",
  "VkSparseImageMemoryRequirements2KHR.pNext": "",
  "VkSparseImageMemoryRequirements2KHR.sType": "",
  "VkSparseImageOpaqueMemoryBindInfo": "Structure specifying sparse image opaque memory bind info.",
  "VkSparseImageOpaqueMemoryBindInfo.bindCount": "The number of SparseMemoryBind structures in the pBinds array.",
  "VkSparseImageOpaqueMemoryBindInfo.image": "The Image object to be bound.",
  "VkSparseImageOpaqueMemoryBindInfo.pBinds": "Array of SparseMemoryBind structures.",
  "VkSparseMemoryBind": "Structure specifying a sparse memory bind operation.",
  "VkSparseMemoryBind.flags": "A bitmask specifying usage of the binding operation. Bits which can be set include: + --",
  "VkSparseMemoryBind.memory": "The DeviceMemory object that the range of the resource is bound to. If memory is null, the range is unbound.",
  "VkSparseMemoryBind.memoryOffset": "The offset into the DeviceMemory object to bind the resource range to. If memory is null, this value is ignored.",
  "VkSparseMemoryBind.resourceOffset": "The offset into the resource.",
  "VkSparseMemoryBind.size": "The size of the memory region to be bound.",
  "VkSparseMemoryBindFlagBits": "Bitmask specifying usage of a sparse memory binding operation.",
  "VkSparseMemoryBindFlagBits.__none": "",
  "VkSparseMemoryBindFlagBits.VK_SPARSE_MEMORY_BIND_METADATA_BIT": "",
  "VkSparseMemoryBindFlags": "",
  "VkSpecializationInfo": "Structure specifying specialization info.",
  "VkSpecializationInfo.dataSize": "The byte size of the pData buffer.",
  "VkSpecializationInfo.mapEntryCount": "The number of entries in the pMapEntries array.",
  "VkSpecializationInfo.pData": "pData contains the actual constant values to specialize with.",
  "VkSpecializationInfo.pMapEntries": "An array of SpecializationMapEntry which maps constant IDs to offsets in pData.",
  "VkSpecializationMapEntry": "Structure specifying a specialization map entry.",
  "VkSpecializationMapEntry.constantID": "The ID of the specialization constant in SPIR-V.",
  "VkSpecializationMapEntry.offset": "The byte offset of the specialization constant value within the supplied data buffer.",
  "VkSpecializationMapEntry.size": "The byte size of the specialization constant value within the supplied data buffer.",
  "VkStencilFaceFlagBits": "Bitmask specifying sets of stencil state for which to update the compare mask.",
  "VkStencilFaceFlagBits.__none": "",
  "VkStencilFaceFlagBits.VK_STENCIL_FACE_BACK_BIT": "",
  "VkStencilFaceFlagBits.VK_STENCIL_FACE_FRONT_BIT": "",
  "VkStencilFaceFlagBits.VK_STENCIL_FRONT_AND_BACK": "",
  "VkStencilFaceFlags": "",
  "VkStencilOp": "Stencil comparison function.",
  "VkStencilOp.VK_STENCIL_OP_DECREMENT_AND_CLAMP": "VK_STENCIL_OP_DECREMENT_AND_CLAMP decrements the current value and clamps to 0.",
  "VkStencilOp.VK_STENCIL_OP_DECREMENT_AND_WRAP": "VK_STENCIL_OP_DECREMENT_AND_WRAP decrements the current value and wraps to the maximum possible value when the value would go below 0.",
  "VkStencilOp.VK_STENCIL_OP_INCREMENT_AND_CLAMP": "VK_STENCIL_OP_INCREMENT_AND_CLAMP increments the current value and clamps to the maximum representable unsigned value.",
  "VkStencilOp.VK_STENCIL_OP_INCREMENT_AND_WRAP": "VK_STENCIL_OP_INCREMENT_AND_WRAP increments the current value and wraps to 0 when the maximum value would have been exceeded.",
  "VkStencilOp.VK_STENCIL_OP_INVERT": "VK_STENCIL_OP_INVERT bitwise-inverts the current value.",
  "VkStencilOp.VK_STENCIL_OP_KEEP": "VK_STENCIL_OP_KEEP keeps the current value.",
  "VkStencilOp.VK_STENCIL_OP_REPLACE": "VK_STENCIL_OP_REPLACE sets the value to reference.",
  "VkStencilOp.VK_STENCIL_OP_ZERO": "VK_STENCIL_OP_ZERO sets the value to 0.",
  "VkStencilOpState": "Structure specifying stencil operation state.",
  "VkStencilOpState.compareMask": "Selects the bits of the unsigned integer stencil values participating in the stencil test.",
  "VkStencilOpState.compareOp": "The comparison operator used in the stencil test.",
  "VkStencilOpState.depthFailOp": "The action performed on samples that pass the stencil test and fail the depth test.",
  "VkStencilOpState.failOp": "The action performed on samples that fail the stencil test.",
  "VkStencilOpState.passOp": "The action performed on samples that pass both the depth and stencil tests.",
  "VkStencilOpState.reference": "An integer reference value that is used in the unsigned stencil comparison.",
  "VkStencilOpState.writeMask": "Selects the bits of the unsigned integer stencil values updated by the stencil test in the stencil framebuffer attachment.",
  "VkStructureType": "",
  "VkStructureType.VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_APPLICATION_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_BIND_SPARSE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER": "",
  "VkStructureType.VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET": "",
  "VkStructureType.VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EVENT_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_FENCE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_HDR_METADATA_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK": "",
  "VkStructureType.VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MEMORY_BARRIER": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID": "",
  "VkStructureType.VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE": "",
  "VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD": "",
  "VkStructureType.VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN": "",
  "VkStructureType.VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV": "",
  "VkStructureType.VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET": "",
  "VkStructureType.VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR": "",
  "VkSubmitInfo": "Structure specifying a queue submit operation.",
  "VkSubmitInfo.commandBufferCount": "The number of command buffers to execute in the batch.",
  "VkSubmitInfo.pCommandBuffers": "An array of command buffers to execute in the batch.",
  "VkSubmitInfo.pNext": "Null or an extension-specific structure.",
  "VkSubmitInfo.pSignalSemaphores": "An array of semaphores which will be signaled when the command buffers for this batch have completed execution. If semaphores to be signaled are provided, they define a semaphore signal operation.",
  "VkSubmitInfo.pWaitDstStageMask": "An array of pipeline stages at which each corresponding semaphore wait will occur.",
  "VkSubmitInfo.pWaitSemaphores": "An array of semaphores upon which to wait before the command buffers for this batch begin execution. If semaphores to wait on are provided, they define a semaphore wait operation.",
  "VkSubmitInfo.signalSemaphoreCount": "The number of semaphores to be signaled once the commands specified in pCommandBuffers have completed execution.",
  "VkSubmitInfo.sType": "The type of this structure.",
  "VkSubmitInfo.waitSemaphoreCount": "The number of semaphores upon which to wait before executing the command buffers for the batch.",
  "VkSubpassContents": "Specify how commands in the first subpass of a render pass are provided.",
  "VkSubpassContents.VK_SUBPASS_CONTENTS_INLINE": "",
  "VkSubpassContents.VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS": "",
  "VkSubpassDependency": "Structure specifying a subpass dependency.",
  "VkSubpassDependency.dependencyFlags": "A bitmask of DependencyFlagBits.",
  "VkSubpassDependency.dstAccessMask": "dstAccessMask defines a destination access mask.",
  "VkSubpassDependency.dstStageMask": "dstStageMask defines a destination stage mask.",
  "VkSubpassDependency.dstSubpass": "The subpass index of the second subpass in the dependency, or VK_SUBPASS_EXTERNAL.",
  "VkSubpassDependency.srcAccessMask": "srcAccessMask defines a source access mask.",
  "VkSubpassDependency.srcStageMask": "srcStageMask defines a source stage mask.",
  "VkSubpassDependency.srcSubpass": "The subpass index of the first subpass in the dependency, or VK_SUBPASS_EXTERNAL.",
  "VkSubpassDescription": "Structure specifying a subpass description.",
  "VkSubpassDescription.colorAttachmentCount": "",
  "VkSubpassDescription.flags": "A bitmask indicating usage of the subpass. Bits which can be set include: + --",
  "VkSubpassDescription.inputAttachmentCount": "",
  "VkSubpassDescription.pColorAttachments": "",
  "VkSubpassDescription.pDepthStencilAttachment": "",
  "VkSubpassDescription.pInputAttachments": "",
  "VkSubpassDescription.pipelineBindPoint": "",
  "VkSubpassDescription.pPreserveAttachments": "",
  "VkSubpassDescription.preserveAttachmentCount": "",
  "VkSubpassDescription.pResolveAttachments": "",
  "VkSubpassDescriptionFlagBits": "Bitmask specifying usage of a subpass.",
  "VkSubpassDescriptionFlagBits.__none": "",
  "VkSubpassDescriptionFlagBits.VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX": "",
  "VkSubpassDescriptionFlagBits.VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX": "",
  "VkSubpassDescriptionFlags": "",
  "VkSubpassSampleLocationsEXT": "",
  "VkSubpassSampleLocationsEXT.sampleLocationsInfo": "",
  "VkSubpassSampleLocationsEXT.subpassIndex": "",
  "VkSubresourceLayout": "Structure specifying subresource layout.",
  "VkSubresourceLayout.arrayPitch": "arrayPitch describes the number of bytes between each array layer of an image.",
  "VkSubresourceLayout.depthPitch": "depthPitch describes the number of bytes between each slice of 3D image.",
  "VkSubresourceLayout.offset": "The byte offset from the start of the image where the image subresource begins.",
  "VkSubresourceLayout.rowPitch": "rowPitch describes the number of bytes between each row of texels in an image.",
  "VkSubresourceLayout.size": "The size in bytes of the image subresource. size includes any extra memory that is required based on rowPitch.",
  "VkSurfaceCapabilities2EXT": "Structure describing capabilities of a surface.",
  "VkSurfaceCapabilities2EXT.currentExtent": "",
  "VkSurfaceCapabilities2EXT.currentTransform": "",
  "VkSurfaceCapabilities2EXT.maxImageArrayLayers": "",
  "VkSurfaceCapabilities2EXT.maxImageCount": "",
  "VkSurfaceCapabilities2EXT.maxImageExtent": "",
  "VkSurfaceCapabilities2EXT.minImageCount": "",
  "VkSurfaceCapabilities2EXT.minImageExtent": "",
  "VkSurfaceCapabilities2EXT.pNext": "Null or an extension-specific structure.",
  "VkSurfaceCapabilities2EXT.sType": "The type of this structure.",
  "VkSurfaceCapabilities2EXT.supportedCompositeAlpha": "",
  "VkSurfaceCapabilities2EXT.supportedSurfaceCounters": "A bitfield containing one bit set for each surface counter type supported.",
  "VkSurfaceCapabilities2EXT.supportedTransforms": "",
  "VkSurfaceCapabilities2EXT.supportedUsageFlags": "",
  "VkSurfaceCapabilities2KHR": "",
  "VkSurfaceCapabilities2KHR.pNext": "",
  "VkSurfaceCapabilities2KHR.sType": "",
  "VkSurfaceCapabilities2KHR.surfaceCapabilities": "",
  "VkSurfaceCapabilitiesKHR": "Structure describing capabilities of a surface.",
  "VkSurfaceCapabilitiesKHR.currentExtent": "The current width and height of the surface, or the special value [eq]#(0xFFFFFFFF, 0xFFFFFFFF)# indicating that the surface size will be determined by the extent of a swapchain targeting the surface.",
  "VkSurfaceCapabilitiesKHR.currentTransform": "The surface's current transform relative to the presentation engine's natural orientation, as described by SurfaceTransformFlagBitsKHR.",
  "VkSurfaceCapabilitiesKHR.maxImageArrayLayers": "The maximum number of layers presentable images can have for a swapchain created for this device and surface, and will be at least one.",
  "VkSurfaceCapabilitiesKHR.maxImageCount": "The maximum number of images the specified device supports for a swapchain created for the surface, and will be either 0, or greater than or equal to minImageCount. A value of 0 means that there is no limit on the number of images, though there may be limits related to the total amount of memory used by presentable images.",
  "VkSurfaceCapabilitiesKHR.maxImageExtent": "maxImageExtent contains the largest valid swapchain extent for the surface on the specified device. The width and height of the extent will each be greater than or equal to the corresponding width and height of minImageExtent. The width and height of the extent will each be greater than or equal to the corresponding width and height of currentExtent, unless currentExtent has the special value described above.",
  "VkSurfaceCapabilitiesKHR.minImageCount": "The minimum number of images the specified device supports for a swapchain created for the surface, and will be at least one.",
  "VkSurfaceCapabilitiesKHR.minImageExtent": "minImageExtent contains the smallest valid swapchain extent for the surface on the specified device. The width and height of the extent will each be less than or equal to the corresponding width and height of currentExtent, unless currentExtent has the special value described above.",
  "VkSurfaceCapabilitiesKHR.supportedCompositeAlpha": "A bitmask of CompositeAlphaFlagBitsKHR, representing the alpha compositing modes supported by the presentation engine for the surface on the specified device, and at least one bit will be set. Opaque composition can be achieved in any alpha compositing mode by either using an image format that has no alpha component, or by ensuring that all pixels in the presentable images have an alpha value of 1.0.",
  "VkSurfaceCapabilitiesKHR.supportedTransforms": "A bitmask of SurfaceTransformFlagBitsKHR, describing the presentation transforms supported for the surface on the specified device, and at least one bit will be set.",
  "VkSurfaceCapabilitiesKHR.supportedUsageFlags": "A bitmask of ImageUsageFlagBits representing the ways the application can use the presentable images of a swapchain created for the surface on the specified device. VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT must be included in the set but implementations may support additional usages.",
  "VkSurfaceCounterFlagBitsEXT": "Surface-relative counter types.",
  "VkSurfaceCounterFlagBitsEXT.__none": "",
  "VkSurfaceCounterFlagBitsEXT.VK_SURFACE_COUNTER_VBLANK_EXT": "VK_SURFACE_COUNTER_VBLANK_EXT A counter incrementing once every time a vblank period occurs on the display associated with the surface.",
  "VkSurfaceCounterFlagsEXT": "",
  "VkSurfaceFormat2KHR": "",
  "VkSurfaceFormat2KHR.pNext": "",
  "VkSurfaceFormat2KHR.sType": "",
  "VkSurfaceFormat2KHR.surfaceFormat": "",
  "VkSurfaceFormatKHR": "Structure describing a supported swapchain format-color space pair.",
  "VkSurfaceFormatKHR.colorSpace": "A presentation ColorSpaceKHR that is compatible with the surface.",
  "VkSurfaceFormatKHR.format": "A Format that is compatible with the specified surface.",
  "VkSurfaceKHR": "",
  "VkSurfaceTransformFlagBitsKHR": "Presentation transforms supported on a device.",
  "VkSurfaceTransformFlagBitsKHR.__none": "",
  "VkSurfaceTransformFlagBitsKHR.VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR": "The image content is mirrored horizontally.",
  "VkSurfaceTransformFlagBitsKHR.VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR": "The image content is mirrored horizontally, then rotated 180 degrees clockwise.",
  "VkSurfaceTransformFlagBitsKHR.VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR": "The image content is mirrored horizontally, then rotated 270 degrees clockwise.",
  "VkSurfaceTransformFlagBitsKHR.VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR": "The image content is mirrored horizontally, then rotated 90 degrees clockwise.",
  "VkSurfaceTransformFlagBitsKHR.VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR": "The image content is presented without being transformed.",
  "VkSurfaceTransformFlagBitsKHR.VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR": "The presentation transform is not specified, and is instead determined by platform-specific considerations and mechanisms outside Vulkan.",
  "VkSurfaceTransformFlagBitsKHR.VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR": "The image content is rotated 180 degrees clockwise.",
  "VkSurfaceTransformFlagBitsKHR.VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR": "The image content is rotated 270 degrees clockwise.",
  "VkSurfaceTransformFlagBitsKHR.VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR": "The image content is rotated 90 degrees clockwise.",
  "VkSurfaceTransformFlagsKHR": "",
  "VkSwapchainCounterCreateInfoEXT": "Specify the surface counters desired.",
  "VkSwapchainCounterCreateInfoEXT.pNext": "Null or an extension-specific structure.",
  "VkSwapchainCounterCreateInfoEXT.sType": "The type of this structure.",
  "VkSwapchainCounterCreateInfoEXT.surfaceCounters": "A bitmask containing a bit set for each surface counter to enable for the swapchain.",
  "VkSwapchainCreateFlagBitsKHR": "Bitmask controlling swapchain creation.",
  "VkSwapchainCreateFlagBitsKHR.__none": "",
  "VkSwapchainCreateFlagBitsKHR.VK_SWAPCHAIN_CREATE_BIND_SFR_BIT_KHX": "",
  "VkSwapchainCreateFlagsKHR": "",
  "VkSwapchainCreateInfoKHR": "Structure specifying parameters of a newly created swapchain object.",
  "VkSwapchainCreateInfoKHR.clipped": "",
  "VkSwapchainCreateInfoKHR.compositeAlpha": "",
  "VkSwapchainCreateInfoKHR.flags": "A bitmask indicating parameters of swapchain creation. Bits which can be set include: + --",
  "VkSwapchainCreateInfoKHR.imageArrayLayers": "",
  "VkSwapchainCreateInfoKHR.imageColorSpace": "",
  "VkSwapchainCreateInfoKHR.imageExtent": "",
  "VkSwapchainCreateInfoKHR.imageFormat": "",
  "VkSwapchainCreateInfoKHR.imageSharingMode": "",
  "VkSwapchainCreateInfoKHR.imageUsage": "",
  "VkSwapchainCreateInfoKHR.minImageCount": "",
  "VkSwapchainCreateInfoKHR.oldSwapchain": "",
  "VkSwapchainCreateInfoKHR.pNext": "Null or an extension-specific structure.",
  "VkSwapchainCreateInfoKHR.pQueueFamilyIndices": "",
  "VkSwapchainCreateInfoKHR.presentMode": "",
  "VkSwapchainCreateInfoKHR.preTransform": "",
  "VkSwapchainCreateInfoKHR.queueFamilyIndexCount": "",
  "VkSwapchainCreateInfoKHR.sType": "The type of this structure.",
  "VkSwapchainCreateInfoKHR.surface": "",
  "VkSwapchainKHR": "",
  "VkSystemAllocationScope": "Allocation scope.",
  "VkSystemAllocationScope.VK_SYSTEM_ALLOCATION_SCOPE_CACHE": "VK_SYSTEM_ALLOCATION_SCOPE_CACHE - The allocation is scoped to the lifetime of a PipelineCache object.",
  "VkSystemAllocationScope.VK_SYSTEM_ALLOCATION_SCOPE_COMMAND": "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND - The allocation is scoped to the duration of the Vulkan command.",
  "VkSystemAllocationScope.VK_SYSTEM_ALLOCATION_SCOPE_DEVICE": "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE - The allocation is scoped to the lifetime of the Vulkan device.",
  "VkSystemAllocationScope.VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE": "VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE - The allocation is scoped to the lifetime of the Vulkan instance.",
  "VkSystemAllocationScope.VK_SYSTEM_ALLOCATION_SCOPE_OBJECT": "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT - The allocation is scoped to the lifetime of the Vulkan object that is being created or used.",
  "VkTessellationDomainOriginKHR": "",
  "VkTessellationDomainOriginKHR.VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR": "",
  "VkTessellationDomainOriginKHR.VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR": "",
  "VkTextureLODGatherFormatPropertiesAMD": "",
  "VkTextureLODGatherFormatPropertiesAMD.pNext": "",
  "VkTextureLODGatherFormatPropertiesAMD.sType": "",
  "VkTextureLODGatherFormatPropertiesAMD.supportsTextureGatherLODBiasAMD": "",
  "vkTrimCommandPoolKHR": "Trim a command pool.",
  "vkTrimCommandPoolKHR.commandPool": "",
  "vkTrimCommandPoolKHR.device": "",
  "vkTrimCommandPoolKHR.flags": "",
  "vkUnmapMemory": "Unmap a previously mapped memory object.",
  "vkUnmapMemory.device": "",
  "vkUnmapMemory.memory": "",
  "vkUnregisterObjectsNVX": "",
  "vkUnregisterObjectsNVX.device": "",
  "vkUnregisterObjectsNVX.objectCount": "",
  "vkUnregisterObjectsNVX.objectTable": "",
  "vkUnregisterObjectsNVX.pObjectEntryTypes": "",
  "vkUnregisterObjectsNVX.pObjectIndices": "",
  "vkUpdateDescriptorSets": "Update the contents of a descriptor set object.",
  "vkUpdateDescriptorSets.descriptorCopyCount": "",
  "vkUpdateDescriptorSets.descriptorWriteCount": "",
  "vkUpdateDescriptorSets.device": "",
  "vkUpdateDescriptorSets.pDescriptorCopies": "",
  "vkUpdateDescriptorSets.pDescriptorWrites": "",
  "vkUpdateDescriptorSetWithTemplateKHR": "",
  "vkUpdateDescriptorSetWithTemplateKHR.descriptorSet": "",
  "vkUpdateDescriptorSetWithTemplateKHR.descriptorUpdateTemplate": "",
  "vkUpdateDescriptorSetWithTemplateKHR.device": "",
  "vkUpdateDescriptorSetWithTemplateKHR.pData": "",
  "VkValidationCacheCreateFlagsEXT": "",
  "VkValidationCacheCreateFlagsEXT.__none": "",
  "VkValidationCacheCreateInfoEXT": "",
  "VkValidationCacheCreateInfoEXT.flags": "",
  "VkValidationCacheCreateInfoEXT.initialDataSize": "",
  "VkValidationCacheCreateInfoEXT.pInitialData": "",
  "VkValidationCacheCreateInfoEXT.pNext": "",
  "VkValidationCacheCreateInfoEXT.sType": "",
  "VkValidationCacheEXT": "",
  "VkValidationCacheHeaderVersionEXT": "",
  "VkValidationCacheHeaderVersionEXT.VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT": "",
  "VkValidationCheckEXT": "Specify validation checks to disable.",
  "VkValidationCheckEXT.VK_VALIDATION_CHECK_ALL_EXT": "",
  "VkValidationCheckEXT.VK_VALIDATION_CHECK_SHADERS_EXT": "",
  "VkValidationFlagsEXT": "Specify validation checks to disable for a Vulkan instance.",
  "VkValidationFlagsEXT.disabledValidationCheckCount": "The number of checks to disable.",
  "VkValidationFlagsEXT.pDisabledValidationChecks": "An array of values specifying the validation checks to be disabled. Checks which may be specified include: + --",
  "VkValidationFlagsEXT.pNext": "Null or an extension-specific structure.",
  "VkValidationFlagsEXT.sType": "The type of this structure.",
  "VkVertexInputAttributeDescription": "Structure specifying vertex input attribute description.",
  "VkVertexInputAttributeDescription.binding": "The binding number which this attribute takes its data from.",
  "VkVertexInputAttributeDescription.format": "The size and type of the vertex attribute data.",
  "VkVertexInputAttributeDescription.location": "The shader binding location number for this attribute.",
  "VkVertexInputAttributeDescription.offset": "A byte offset of this attribute relative to the start of an element in the vertex input binding.",
  "VkVertexInputBindingDescription": "Structure specifying vertex input binding description.",
  "VkVertexInputBindingDescription.binding": "The binding number that this structure describes.",
  "VkVertexInputBindingDescription.inputRate": "Specifies whether vertex attribute addressing is a function of the vertex index or of the instance index. Possible values include: + --",
  "VkVertexInputBindingDescription.stride": "The distance in bytes between two consecutive elements within the buffer.",
  "VkVertexInputRate": "Specify rate at which vertex attributes are pulled from buffers.",
  "VkVertexInputRate.VK_VERTEX_INPUT_RATE_INSTANCE": "",
  "VkVertexInputRate.VK_VERTEX_INPUT_RATE_VERTEX": "",
  "VkViewport": "Structure specifying a viewport.",
  "VkViewport.height": "",
  "VkViewport.maxDepth": "",
  "VkViewport.minDepth": "minDepth and maxDepth are the depth range for the viewport. It is valid for minDepth to be greater than or equal to maxDepth.",
  "VkViewport.width": "width and height are the viewport's width and height, respectively.",
  "VkViewport.x": "x and y are the viewport's upper left corner [eq]#(x,y)#.",
  "VkViewport.y": "",
  "VkViewportCoordinateSwizzleNV": "",
  "VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV": "",
  "VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV": "",
  "VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV": "",
  "VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV": "",
  "VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV": "",
  "VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV": "",
  "VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV": "",
  "VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV": "",
  "VkViewportSwizzleNV": "Structure specifying a viewport swizzle.",
  "VkViewportSwizzleNV.w": "The swizzle operation to apply to the w component of the primitive",
  "VkViewportSwizzleNV.x": "The swizzle operation to apply to the x component of the primitive",
  "VkViewportSwizzleNV.y": "The swizzle operation to apply to the y component of the primitive",
  "VkViewportSwizzleNV.z": "The swizzle operation to apply to the z component of the primitive",
  "VkViewportWScalingNV": "Structure specifying a viewport.",
  "VkViewportWScalingNV.xcoeff": "xcoeff and ycoeff are the viewport's W scaling factor for x and y respectively.",
  "VkViewportWScalingNV.ycoeff": "",
  "VkViSurfaceCreateFlagsNN": "",
  "VkViSurfaceCreateFlagsNN.__none": "",
  "VkViSurfaceCreateInfoNN": "Structure specifying parameters of a newly created VI surface object.",
  "VkViSurfaceCreateInfoNN.flags": "Reserved for future use.",
  "VkViSurfaceCreateInfoNN.pNext": "Null or an extension-specific structure.",
  "VkViSurfaceCreateInfoNN.sType": "The type of this structure.",
  "VkViSurfaceCreateInfoNN.window": "The nn::vi::NativeWindowHandle for the nn::vi::Layer with which to associate the surface.",
  "vkWaitForFences": "Wait for one or more fences to become signaled.",
  "vkWaitForFences.device": "",
  "vkWaitForFences.fenceCount": "",
  "vkWaitForFences.pFences": "",
  "vkWaitForFences.timeout": "",
  "vkWaitForFences.waitAll": "",
  "VkWaylandSurfaceCreateFlagsKHR": "",
  "VkWaylandSurfaceCreateFlagsKHR.__none": "",
  "VkWaylandSurfaceCreateInfoKHR": "Structure specifying parameters of a newly created Wayland surface object.",
  "VkWaylandSurfaceCreateInfoKHR.display": "display and surface are pointers to the Wayland wl_display and wl_surface to associate the surface with.",
  "VkWaylandSurfaceCreateInfoKHR.flags": "Reserved for future use.",
  "VkWaylandSurfaceCreateInfoKHR.pNext": "Null or an extension-specific structure.",
  "VkWaylandSurfaceCreateInfoKHR.sType": "The type of this structure.",
  "VkWaylandSurfaceCreateInfoKHR.surface": "",
  "VkWin32KeyedMutexAcquireReleaseInfoKHR": "",
  "VkWin32KeyedMutexAcquireReleaseInfoKHR.acquireCount": "",
  "VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireKeys": "",
  "VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireSyncs": "",
  "VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireTimeouts": "",
  "VkWin32KeyedMutexAcquireReleaseInfoKHR.pNext": "",
  "VkWin32KeyedMutexAcquireReleaseInfoKHR.pReleaseKeys": "",
  "VkWin32KeyedMutexAcquireReleaseInfoKHR.pReleaseSyncs": "",
  "VkWin32KeyedMutexAcquireReleaseInfoKHR.releaseCount": "",
  "VkWin32KeyedMutexAcquireReleaseInfoKHR.sType": "",
  "VkWin32KeyedMutexAcquireReleaseInfoNV": "Use Windows keyex mutex mechanism to synchronize work.",
  "VkWin32KeyedMutexAcquireReleaseInfoNV.acquireCount": "",
  "VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireKeys": "",
  "VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireSyncs": "",
  "VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireTimeoutMilliseconds": "",
  "VkWin32KeyedMutexAcquireReleaseInfoNV.pNext": "",
  "VkWin32KeyedMutexAcquireReleaseInfoNV.pReleaseKeys": "",
  "VkWin32KeyedMutexAcquireReleaseInfoNV.pReleaseSyncs": "",
  "VkWin32KeyedMutexAcquireReleaseInfoNV.releaseCount": "",
  "VkWin32KeyedMutexAcquireReleaseInfoNV.sType": "",
  "VkWin32SurfaceCreateFlagsKHR": "",
  "VkWin32SurfaceCreateFlagsKHR.__none": "",
  "VkWin32SurfaceCreateInfoKHR": "Structure specifying parameters of a newly created Win32 surface object.",
  "VkWin32SurfaceCreateInfoKHR.flags": "Reserved for future use.",
  "VkWin32SurfaceCreateInfoKHR.hinstance": "Win32 HINSTANCE for the window to associate the surface with.",
  "VkWin32SurfaceCreateInfoKHR.hwnd": "Win32 HWND for the window to associate the surface with.",
  "VkWin32SurfaceCreateInfoKHR.pNext": "Null or an extension-specific structure.",
  "VkWin32SurfaceCreateInfoKHR.sType": "The type of this structure.",
  "VkWriteDescriptorSet": "Structure specifying the parameters of a descriptor set write operation.",
  "VkWriteDescriptorSet.descriptorCount": "The number of descriptors to update (the number of elements in pImageInfo, pBufferInfo, or pTexelBufferView).",
  "VkWriteDescriptorSet.descriptorType": "A DescriptorType specifying the type of each descriptor in pImageInfo, pBufferInfo, or pTexelBufferView, as described below. It must be the same type as that specified in DescriptorSetLayoutBinding for dstSet at dstBinding. The type of the descriptor also controls which array the descriptors are taken from.",
  "VkWriteDescriptorSet.dstArrayElement": "The starting element in that array.",
  "VkWriteDescriptorSet.dstBinding": "The descriptor binding within that set.",
  "VkWriteDescriptorSet.dstSet": "The destination descriptor set to update.",
  "VkWriteDescriptorSet.pBufferInfo": "An array of DescriptorBufferInfo structures or is ignored, as described below.",
  "VkWriteDescriptorSet.pImageInfo": "An array of DescriptorImageInfo structures or is ignored, as described below.",
  "VkWriteDescriptorSet.pNext": "Null or an extension-specific structure.",
  "VkWriteDescriptorSet.pTexelBufferView": "An array of BufferView handles as described in the Buffer Views section or is ignored, as described below.",
  "VkWriteDescriptorSet.sType": "The type of this structure.",
  "VkXcbSurfaceCreateFlagsKHR": "",
  "VkXcbSurfaceCreateFlagsKHR.__none": "",
  "VkXcbSurfaceCreateInfoKHR": "Structure specifying parameters of a newly created Xcb surface object.",
  "VkXcbSurfaceCreateInfoKHR.connection": "An xcb_connection_t to the X server.",
  "VkXcbSurfaceCreateInfoKHR.flags": "Reserved for future use.",
  "VkXcbSurfaceCreateInfoKHR.pNext": "Null or an extension-specific structure.",
  "VkXcbSurfaceCreateInfoKHR.sType": "The type of this structure.",
  "VkXcbSurfaceCreateInfoKHR.window": "The xcb_window_t for the X11 window to associate the surface with.",
  "VkXlibSurfaceCreateFlagsKHR": "",
  "VkXlibSurfaceCreateFlagsKHR.__none": "",
  "VkXlibSurfaceCreateInfoKHR": "Structure specifying parameters of a newly created Xlib surface object.",
  "VkXlibSurfaceCreateInfoKHR.dpy": "An Xlib Display connection to the X server.",
  "VkXlibSurfaceCreateInfoKHR.flags": "Reserved for future use.",
  "VkXlibSurfaceCreateInfoKHR.pNext": "Null or an extension-specific structure.",
  "VkXlibSurfaceCreateInfoKHR.sType": "The type of this structure.",
  "VkXlibSurfaceCreateInfoKHR.window": "An Xlib Window to associate the surface with.",
  "VkXYColorEXT": "Structure to specify X,Y chromaticity coordinates.",
  "VkXYColorEXT.x": "",
  "VkXYColorEXT.y": ""
}